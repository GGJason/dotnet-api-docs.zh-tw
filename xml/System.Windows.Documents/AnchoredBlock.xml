<Type Name="AnchoredBlock" FullName="System.Windows.Documents.AnchoredBlock">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f177b45e327296fc504b9bbfdd02cd41e2baa974" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39781049" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class AnchoredBlock : System.Windows.Documents.Inline" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit AnchoredBlock extends System.Windows.Documents.Inline" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.AnchoredBlock" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class AnchoredBlock&#xA;Inherits Inline" />
  <TypeSignature Language="C++ CLI" Value="public ref class AnchoredBlock abstract : System::Windows::Documents::Inline" />
  <TypeSignature Language="F#" Value="type AnchoredBlock = class&#xA;    inherit Inline" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Documents.Inline</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Windows.Markup.ContentProperty("Blocks")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>抽象類別 (Abstract Class)，它會提供基底給 <see cref="T:System.Windows.Documents.Inline" /> 項目，這個項目可用於將 <see cref="T:System.Windows.Documents.Block" /> 項目錨定至非固定格式內容.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected AnchoredBlock (System.Windows.Documents.Block block, System.Windows.Documents.TextPointer insertionPosition);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Windows.Documents.Block block, class System.Windows.Documents.TextPointer insertionPosition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.AnchoredBlock.#ctor(System.Windows.Documents.Block,System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; AnchoredBlock(System::Windows::Documents::Block ^ block, System::Windows::Documents::TextPointer ^ insertionPosition);" />
      <MemberSignature Language="F#" Value="new System.Windows.Documents.AnchoredBlock : System.Windows.Documents.Block * System.Windows.Documents.TextPointer -&gt; System.Windows.Documents.AnchoredBlock" Usage="new System.Windows.Documents.AnchoredBlock (block, insertionPosition)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="block" Type="System.Windows.Documents.Block" />
        <Parameter Name="insertionPosition" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="block">
          <see cref="T:System.Windows.Documents.Block" /> 物件，用來指定新項目的初始內容。  這個參數可能是 <see langword="null" />，在這個情況下，不會插入 <see cref="T:System.Windows.Documents.Block" />。</param>
        <param name="insertionPosition">
          <see cref="T:System.Windows.Documents.TextPointer" />，指定項目在建立之後所要插入的位置，<see langword="null" /> 表示不會自動插入。</param>
        <summary>由衍生類別呼叫時，初始化基底類別值，將指定的 <see cref="T:System.Windows.Documents.Block" /> 物件做為新 <see cref="T:System.Windows.Documents.AnchoredBlock" /> 子代的初始內容，以及會替新 <see cref="T:System.Windows.Documents.TextPointer" /> 子代指定插入位置的 <see cref="T:System.Windows.Documents.AnchoredBlock" />。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Blocks">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.BlockCollection Blocks { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.BlockCollection Blocks" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.AnchoredBlock.Blocks" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Blocks As BlockCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::BlockCollection ^ Blocks { System::Windows::Documents::BlockCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Blocks : System.Windows.Documents.BlockCollection" Usage="System.Windows.Documents.AnchoredBlock.Blocks" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.BlockCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得包含最上層 <see cref="T:System.Windows.Documents.Block" /> 項目的 <see cref="T:System.Windows.Documents.BlockCollection" />，這些項目組成項目的內容。</summary>
        <value>包含 <see cref="T:System.Windows.Documents.Block" /> 項目的 <see cref="T:System.Windows.Documents.BlockCollection" />，這些項目組成項目的內容。  
  
此屬性沒有預設值。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BorderBrush">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush BorderBrush { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush BorderBrush" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.AnchoredBlock.BorderBrush" />
      <MemberSignature Language="VB.NET" Value="Public Property BorderBrush As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ BorderBrush { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BorderBrush : System.Windows.Media.Brush with get, set" Usage="System.Windows.Documents.AnchoredBlock.BorderBrush" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要在繪製項目框線時使用的 <see cref="T:System.Windows.Media.Brush" />。</summary>
        <value>用來套用至項目框線的筆刷。  
  
預設值是**null**筆刷。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需顯示可用的預先定義筆刷色彩的樣本的表格，請參閱<xref:System.Windows.Media.Brushes>。  
  
<a name="dependencyPropertyInfo_BorderBrush"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.Documents.AnchoredBlock.BorderBrushProperty>|  
|若要設定的中繼資料屬性 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
   
  
## Examples  
 下列範例示範如何設定<xref:System.Windows.Documents.Block.BorderBrush%2A>項目的屬性 (<xref:System.Windows.Documents.Paragraph>)。  
  
 [!code-xaml[BlockSnippets#_Block_BordersXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml#_block_bordersxaml)]  
  
 下圖顯示此範例的轉譯方式。  
  
 ![螢幕擷取畫面： 藍色，1&#47;4 英吋框線圍繞在 Block 周圍](~/add/media/block-borders.png "螢幕擷取畫面： 圍繞在 Block 周圍的藍色，1/4 英吋框線")  
  
 下列範例示範如何設定<xref:System.Windows.Documents.Block.BorderBrush%2A>屬性以程式設計的方式。  
  
 [!code-csharp[BlockSnippets#_Block_Borders](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml.cs#_block_borders)]
 [!code-vb[BlockSnippets#_Block_Borders](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BlockSnippets/visualbasic/window1.xaml.vb#_block_borders)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.AnchoredBlock.BorderThickness" />
      </Docs>
    </Member>
    <Member MemberName="BorderBrushProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BorderBrushProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BorderBrushProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.AnchoredBlock.BorderBrushProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BorderBrushProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BorderBrushProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BorderBrushProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.AnchoredBlock.BorderBrushProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.Documents.AnchoredBlock.BorderBrush" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BorderThickness">
      <MemberSignature Language="C#" Value="public System.Windows.Thickness BorderThickness { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Thickness BorderThickness" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.AnchoredBlock.BorderThickness" />
      <MemberSignature Language="VB.NET" Value="Public Property BorderThickness As Thickness" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Thickness BorderThickness { System::Windows::Thickness get(); void set(System::Windows::Thickness value); };" />
      <MemberSignature Language="F#" Value="member this.BorderThickness : System.Windows.Thickness with get, set" Usage="System.Windows.Documents.AnchoredBlock.BorderThickness" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Thickness</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定項目的框線粗細。</summary>
        <value>A<see cref="T:System.Windows.Thickness" />結構，指定要套用，與裝置無關的像素的框線數量。  
  
預設值是粗細一致的零 (**0.0**)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="xamlAttributeUsage_BorderThickness"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object BorderThickness="uniformThickness"/>  
- or -  
<object BorderThickness="independentThickness"/>  
- or -  
<object BorderThickness="qualifiedUniformThickness"/>  
- or -  
<object BorderThickness="qualifiedIndependentThickness"/>  
```  
  
<a name="xamlValues_BorderThickness"></a>   
## <a name="xaml-values"></a>XAML 值  
 *uniformThickness*  
 單一的字串表示法<xref:System.Double>一致地套用所有的四個粗細維度值。  例如，值`"10"`相當於針對`"10,10,10,10"`。  不合格的值被以與裝置無關的像素。 字串不需要明確包含小數位數。  
  
 *independentThickness*  
 四個已排序的字串表示法<xref:System.Double>值對應至獨立的粗細維度 left，top，以滑鼠右鍵，並 bottom，依此順序。  四個值必須是以逗號分隔的;不允許有空格。  比方說，「 5,10,15,20"會導致 5 像素框線的左邊的內容、 內容上方的框線的 10 個像素、 15 像素框線右邊的內容和 20 個像素框線下方的內容。  
  
 *qualifiedUniformThickness*  
 所描述的值*uniformThickness*後面接著一個下列的單位規範： `px`， `in`。  
  
 `px` （預設值） [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 是英吋為單位;1in = = 96px  
  
 比方說，`"1in"`提供統一的框線，往所有方向的 1 英吋。  
  
 *qualifiedIndependentThickness*  
 所描述的值*independentThickness*，以每個獨立的值，後面接著一個下列的單位規範： `px`， `in`。  
  
 `px` （預設值） [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 是英吋為單位;1in = = 96px  
  
 例如，`"1.5in,0.8in,1.5in,0.8in"`。  單位規範可能會混合，或從一個或多個值中省略。  
  
<a name="dependencyPropertyInfo_BorderThickness"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.Documents.AnchoredBlock.BorderThicknessProperty>|  
|若要設定的中繼資料屬性 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 下列範例示範如何設定<xref:System.Windows.Documents.Block.BorderThickness%2A>的屬性<xref:System.Windows.Documents.Block>項目 (<xref:System.Windows.Documents.Paragraph>)。  
  
 [!code-xaml[BlockSnippets#_Block_BordersXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml#_block_bordersxaml)]  
  
 下圖顯示此範例的轉譯方式。  
  
 ![螢幕擷取畫面： 藍色，1&#47;4 英吋框線圍繞在 Block 周圍](~/add/media/block-borders.png "螢幕擷取畫面： 圍繞在 Block 周圍的藍色，1/4 英吋框線")  
  
 下列範例示範如何設定<xref:System.Windows.Documents.Block.BorderThickness%2A>屬性以程式設計的方式。  
  
 [!code-csharp[BlockSnippets#_Block_Borders](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml.cs#_block_borders)]
 [!code-vb[BlockSnippets#_Block_Borders](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BlockSnippets/visualbasic/window1.xaml.vb#_block_borders)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.AnchoredBlock.BorderBrush" />
      </Docs>
    </Member>
    <Member MemberName="BorderThicknessProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BorderThicknessProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BorderThicknessProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.AnchoredBlock.BorderThicknessProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BorderThicknessProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BorderThicknessProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BorderThicknessProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.AnchoredBlock.BorderThicknessProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.Documents.AnchoredBlock.BorderThickness" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LineHeight">
      <MemberSignature Language="C#" Value="public double LineHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 LineHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.AnchoredBlock.LineHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property LineHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double LineHeight { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.LineHeight : double with get, set" Usage="System.Windows.Documents.AnchoredBlock.LineHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定每行內容的高度。</summary>
        <value>指定行高的雙精度浮點數值 (以與裝置無關的像素為單位)。  <see cref="P:System.Windows.Documents.AnchoredBlock.LineHeight" /> 必須等於或大於<c>0.0034</c>而且等於或小於<c>160000</c>。  
  
值為<see cref="F:System.Double.NaN" />(相當於屬性值"<c>自動</c>") 行高由目前字型特性自動決定的原因。  
  
預設值是 <see cref="F:System.Double.NaN" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 變更此值不會變更相關聯的文字; 的高度相反地，它會變更行包含文字的高度。  
  
 除了這個屬性，版面配置中的總行<xref:System.Windows.Documents.AnchoredBlock>受到其<xref:System.Windows.Documents.AnchoredBlock.LineStackingStrategy%2A>屬性。  
  
<a name="xamlAttributeUsage_LineHeight"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object LineHeight="double"/>  
- or -  
<object LineHeight="qualifiedDouble"/>  
- or -  
<object LineHeight="Auto"/>  
```  
  
<a name="xamlValues_LineHeight"></a>   
## <a name="xaml-values"></a>XAML 值  
 *double*  
 字串表示法<xref:System.Double>值等於或大於`0.0034`但比等於或小於`160000`。 不合格的值被以與裝置無關的像素。 字串不需要明確包含小數位數。  
  
 *qualifiedDouble*  
 A*雙*值，上面所述 (但不支援`Auto`) 後面接著一個下列的單位規範： `px`， `in`， `cm`， `pt`。  
  
 `px` （預設值） [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 是英吋為單位;1in = = 96px  
  
 `cm` 是公釐。1cm==(96/2.54) 像素  
  
 `pt` 為點;1pt==(96/72) 像素  
  
 自動  
 行高由目前字型特性自動決定的原因。  相當於屬性值<xref:System.Double.NaN>。  
  
<a name="dependencyPropertyInfo_LineHeight"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.Documents.AnchoredBlock.LineHeightProperty>|  
|若要設定的中繼資料屬性 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 下列範例示範如何設定<xref:System.Windows.Documents.AnchoredBlock.LineHeight%2A>屬性的<xref:System.Windows.Documents.Block>項目。  
  
 [!code-xaml[BlockSnippets#_Block_LineHeightXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml#_block_lineheightxaml)]  
  
 下圖顯示先前範例的轉譯方式。  
  
 ![螢幕擷取畫面： FlowDocument LineHeight](~/add/media/flowdocument-lineheight.png "螢幕擷取畫面： FlowDocument LineHeight")  
  
 下圖顯示相同的範例使用的預設設定的轉譯方式<xref:System.Windows.Documents.AnchoredBlock.LineHeight%2A> = <xref:System.Double.NaN>。  
  
 ![螢幕擷取畫面： FlowDocument lineheight](~/add/media/flowdocument-lineheightdefault.png "螢幕擷取畫面： FlowDocument lineheight 為預設值")  
  
 下列範例示範如何設定<xref:System.Windows.Documents.AnchoredBlock.LineHeight%2A>屬性以程式設計的方式。  
  
 [!code-csharp[BlockSnippets#_Block_LineHeight](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml.cs#_block_lineheight)]
 [!code-vb[BlockSnippets#_Block_LineHeight](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BlockSnippets/visualbasic/window1.xaml.vb#_block_lineheight)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">如果嘗試將 <see cref="P:System.Windows.Controls.TextBlock.LineHeight" /> 設為非正數的值，就會引發。</exception>
      </Docs>
    </Member>
    <Member MemberName="LineHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LineHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LineHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.AnchoredBlock.LineHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LineHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LineHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LineHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.AnchoredBlock.LineHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.Documents.AnchoredBlock.LineHeight" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LineStackingStrategy">
      <MemberSignature Language="C#" Value="public System.Windows.LineStackingStrategy LineStackingStrategy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.LineStackingStrategy LineStackingStrategy" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.AnchoredBlock.LineStackingStrategy" />
      <MemberSignature Language="VB.NET" Value="Public Property LineStackingStrategy As LineStackingStrategy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::LineStackingStrategy LineStackingStrategy { System::Windows::LineStackingStrategy get(); void set(System::Windows::LineStackingStrategy value); };" />
      <MemberSignature Language="F#" Value="member this.LineStackingStrategy : System.Windows.LineStackingStrategy with get, set" Usage="System.Windows.Documents.AnchoredBlock.LineStackingStrategy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LineStackingStrategy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定機制，其中線條方塊會由文字項目中文字的每個線條決定。</summary>
        <value>針對文字項目中的每一行文字來決定線條方塊時所使用的機制。 預設值是 <see cref="F:System.Windows.LineStackingStrategy.MaxHeight" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_LineStackingStrategyProperty"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.Documents.AnchoredBlock.LineStackingStrategyProperty>|  
|若要設定的中繼資料屬性 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Windows.Controls.TextBlock.LineStackingStrategy%2A>屬性來決定線條方塊的文字行的建立方式<xref:System.Windows.Controls.TextBlock>。 第一個<xref:System.Windows.Controls.TextBlock>已經<xref:System.Windows.Controls.TextBlock.LineStackingStrategy%2A>的值<xref:System.Windows.LineStackingStrategy.MaxHeight>，第二個<xref:System.Windows.Controls.TextBlock>的值為<xref:System.Windows.LineStackingStrategy.BlockLineHeight>。  
  
 [!code-xaml[FlowMiscSnippets_snip#LineStackingStrategyExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowMiscSnippets_snip/cs/linestackingstrategyexample.xaml#linestackingstrategyexamplewholepage)]  
  
 下圖顯示上述程式碼的結果。  
  
 ![螢幕擷取畫面： 比較 LineStackingStrategy 值](~/add/media/flow-linestackingstrategy.gif "螢幕擷取畫面： 比較 LineStackingStrategy 值")  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LineStackingStrategyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LineStackingStrategyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LineStackingStrategyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.AnchoredBlock.LineStackingStrategyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LineStackingStrategyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LineStackingStrategyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LineStackingStrategyProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.AnchoredBlock.LineStackingStrategyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.Documents.AnchoredBlock.LineStackingStrategy" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Margin">
      <MemberSignature Language="C#" Value="public System.Windows.Thickness Margin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Thickness Margin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.AnchoredBlock.Margin" />
      <MemberSignature Language="VB.NET" Value="Public Property Margin As Thickness" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Thickness Margin { System::Windows::Thickness get(); void set(System::Windows::Thickness value); };" />
      <MemberSignature Language="F#" Value="member this.Margin : System.Windows.Thickness with get, set" Usage="System.Windows.Documents.AnchoredBlock.Margin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Thickness</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定項目的邊界粗細。</summary>
        <value>A<see cref="T:System.Windows.Thickness" />結構，指定要套用，與裝置無關的像素的邊界數量。  
  
預設值是粗細一致的零 (**0.0**)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.ListItem.Margin%2A> 已超出項目的內容區域，此項目的內容區域的邊緣與父項目邊緣之間的緩衝區空間。  與相反<xref:System.Windows.Documents.ListItem.Padding%2A>，也就是落在項目的內容區域中，元素的內容與內部項目的邊緣之間的緩衝區空間。  
  
<a name="xamlAttributeUsage_Margin"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object Margin="uniformThickness"/>  
- or -  
<object Margin="independentThickness"/>  
- or -  
<object Margin="qualifiedUniformThickness"/>  
- or -  
<object Margin="qualifiedIndependentThickness"/>  
```  
  
<a name="xamlValues_Margin"></a>   
## <a name="xaml-values"></a>XAML 值  
 *uniformThickness*  
 單一的字串表示法<xref:System.Double>一致地套用所有的四個粗細維度值。  例如，值`"10"`相當於針對`"10,10,10,10"`。  不合格的值被以與裝置無關的像素。 字串不需要明確包含小數位數。  
  
 *independentThickness*  
 四個已排序的字串表示法<xref:System.Double>值對應至獨立的粗細維度 left，top，以滑鼠右鍵，並 bottom，依此順序。  四個值必須是以逗號分隔的;不允許有空格。  比方說，「 5,10,15,20"會導致 5 像素邊界的內容及內容上方邊界的 10 個像素、 15 像素的邊界，右邊的內容，內容下方邊界 20 個像素的左邊。  
  
 *qualifiedUniformThickness*  
 所描述的值*uniformThickness*後面接著一個下列的單位規範： `px`， `in`。  
  
 `px` （預設值） [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 是英吋為單位;1in = = 96px  
  
 比方說，`"1in"`提供統一的邊界，往所有方向的 1 英吋。  
  
 *qualifiedIndependentThickness*  
 所描述的值*independentThickness*，以每個獨立的值，後面接著一個下列的單位規範： `px`， `in`。  
  
 `px` （預設值） [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 是英吋為單位;1in = = 96px  
  
 例如，`"1.5in,0.8in,1.5in,0.8in"`。  單位規範可能會混合，或從一個或多個值中省略。  
  
<a name="dependencyPropertyInfo_Margin"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.Documents.AnchoredBlock.MarginProperty>|  
|若要設定的中繼資料屬性 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 下列範例示範如何設定<xref:System.Windows.Documents.AnchoredBlock.Margin%2A>的屬性<xref:System.Windows.Documents.Block>項目 (<xref:System.Windows.Documents.Paragraph>)。  
  
 [!code-xaml[BlockSnippets#_Block_MarginPaddingXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml#_block_marginpaddingxaml)]  
  
 下圖顯示此範例的轉譯方式。  如需圖例可誇張的粗細和色彩。  
  
 ![螢幕擷取畫面： 段落與邊框距離及邊界](~/add/media/block-marginpadding.png "螢幕擷取畫面： 使用邊框距離及邊界的段落")  
  
 下列範例示範如何設定<xref:System.Windows.Documents.AnchoredBlock.Margin%2A>屬性以程式設計的方式。  
  
 [!code-csharp[BlockSnippets#_Block_MarginPadding](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml.cs#_block_marginpadding)]
 [!code-vb[BlockSnippets#_Block_MarginPadding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BlockSnippets/visualbasic/window1.xaml.vb#_block_marginpadding)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MarginProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MarginProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MarginProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.AnchoredBlock.MarginProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MarginProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MarginProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MarginProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.AnchoredBlock.MarginProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.Documents.AnchoredBlock.Margin" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Padding">
      <MemberSignature Language="C#" Value="public System.Windows.Thickness Padding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Thickness Padding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.AnchoredBlock.Padding" />
      <MemberSignature Language="VB.NET" Value="Public Property Padding As Thickness" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Thickness Padding { System::Windows::Thickness get(); void set(System::Windows::Thickness value); };" />
      <MemberSignature Language="F#" Value="member this.Padding : System.Windows.Thickness with get, set" Usage="System.Windows.Documents.AnchoredBlock.Padding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Thickness</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定項目的填補框線粗細。</summary>
        <value>A<see cref="T:System.Windows.Thickness" />結構，指定要套用，與裝置無關的像素的填補量。  
  
預設值是粗細一致的零 (**0.0**)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.ListItem.Padding%2A> 是落在項目的內容區域中，元素的內容與內部項目的邊緣之間的緩衝區空間。  與相反<xref:System.Windows.Documents.ListItem.Margin%2A>，也就是超出項目的內容區域，此項目的內容區域的邊緣與父項目邊緣之間的緩衝區空間。  
  
<a name="xamlAttributeUsage_Padding"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object Padding="uniformThickness"/>  
- or -  
<object Padding="independentThickness"/>  
- or -  
<object Padding="qualifiedUniformThickness"/>  
- or -  
<object Padding="qualifiedIndependentThickness"/>  
```  
  
<a name="xamlValues_Padding"></a>   
## <a name="xaml-values"></a>XAML 值  
 *uniformThickness*  
 單一的字串表示法<xref:System.Double>一致地套用所有的四個粗細維度值。  例如，值`"10"`相當於針對`"10,10,10,10"`。  不合格的值被以與裝置無關的像素。 字串不需要明確包含小數位數。  
  
 *independentThickness*  
 四個已排序的字串表示法<xref:System.Double>值對應至獨立的粗細維度 left，top，以滑鼠右鍵，並 bottom，依此順序。  四個值必須是以逗號分隔的;不允許有空格。  比方說，「 5,10,15,20"會導致 5 像素的邊框距離左邊的內容、 內容上方填補的 10 個像素、 15 像素的邊框間距右邊的內容和 20 個像素內容下方的填補。  
  
 *qualifiedUniformThickness*  
 所描述的值*uniformThickness*後面接著一個下列的單位規範： `px`， `in`。  
  
 `px` （預設值） [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 是英吋為單位;1in = = 96px  
  
 比方說，`"1in"`提供統一的填補，往所有方向的 1 英吋。  
  
 *qualifiedIndependentThickness*  
 所描述的值*independentThickness*，以每個獨立的值，後面接著一個下列的單位規範： `px`， `in`。  
  
 `px` （預設值） [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 是英吋為單位;1in = = 96px  
  
 例如，`"1.5in,0.8in,1.5in,0.8in"`。  單位規範可能會混合，或從一個或多個值中省略。  
  
<a name="dependencyPropertyInfo_Padding"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.Documents.AnchoredBlock.PaddingProperty>|  
|若要設定的中繼資料屬性 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 下列範例示範如何設定<xref:System.Windows.Documents.AnchoredBlock.Padding%2A>的屬性<xref:System.Windows.Documents.Block>項目 (<xref:System.Windows.Documents.Paragraph>)。  
  
 [!code-xaml[BlockSnippets#_Block_MarginPaddingXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml#_block_marginpaddingxaml)]  
  
 下圖顯示此範例的轉譯方式。  如需圖例可誇張的粗細和色彩。  
  
 ![螢幕擷取畫面： 段落與邊框距離及邊界](~/add/media/block-marginpadding.png "螢幕擷取畫面： 使用邊框距離及邊界的段落")  
  
 下列範例示範如何設定<xref:System.Windows.Documents.AnchoredBlock.Padding%2A>屬性以程式設計的方式。  
  
 [!code-csharp[BlockSnippets#_Block_MarginPadding](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml.cs#_block_marginpadding)]
 [!code-vb[BlockSnippets#_Block_MarginPadding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BlockSnippets/visualbasic/window1.xaml.vb#_block_marginpadding)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PaddingProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty PaddingProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty PaddingProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.AnchoredBlock.PaddingProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PaddingProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ PaddingProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable PaddingProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.AnchoredBlock.PaddingProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.Documents.AnchoredBlock.Padding" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeBlocks">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeBlocks (System.Windows.Markup.XamlDesignerSerializationManager manager);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeBlocks(class System.Windows.Markup.XamlDesignerSerializationManager manager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.AnchoredBlock.ShouldSerializeBlocks(System.Windows.Markup.XamlDesignerSerializationManager)" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeBlocks (manager As XamlDesignerSerializationManager) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeBlocks(System::Windows::Markup::XamlDesignerSerializationManager ^ manager);" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeBlocks : System.Windows.Markup.XamlDesignerSerializationManager -&gt; bool" Usage="anchoredBlock.ShouldSerializeBlocks manager" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="manager" Type="System.Windows.Markup.XamlDesignerSerializationManager" />
      </Parameters>
      <Docs>
        <param name="manager">這個物件的序列化服務管理員物件。</param>
        <summary>傳回值，這個值表示 <see cref="P:System.Windows.Documents.AnchoredBlock.Blocks" /> 屬性的有效值是否應該在 <see cref="T:System.Windows.Documents.AnchoredBlock" /> 衍生物件的序列化期間序列化。</summary>
        <returns>如果應該將 <see cref="P:System.Windows.Documents.AnchoredBlock.Blocks" /> 屬性序列化，則為 **true**，否則為 **false**。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">當 <paramref name="manager" /> 為 **null** 時引發。</exception>
      </Docs>
    </Member>
    <Member MemberName="TextAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.TextAlignment TextAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.TextAlignment TextAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.AnchoredBlock.TextAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property TextAlignment As TextAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TextAlignment TextAlignment { System::Windows::TextAlignment get(); void set(System::Windows::TextAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.TextAlignment : System.Windows.TextAlignment with get, set" Usage="System.Windows.Documents.AnchoredBlock.TextAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.TextAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出文字內容的水平對齊方式。</summary>
        <value>
          <see cref="T:System.Windows.TextAlignment" /> 列舉型別 (Enumeration) 的成員，用來指定需要的對齊方式。  
  
預設值是 <see cref="F:System.Windows.TextAlignment.Left" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_TextAlignment"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.Documents.AnchoredBlock.TextAlignmentProperty>|  
|若要設定的中繼資料屬性 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 下列範例示範如何設定<xref:System.Windows.Documents.AnchoredBlock.TextAlignment%2A>屬性的<xref:System.Windows.Documents.Block>項目。  
  
 [!code-xaml[BlockSnippets#_Block_TextAlignmentXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml#_block_textalignmentxaml)]  
  
 下圖顯示使用上述範例的轉譯方式**左**文字對齊方式 （預設值）。  
  
 ![螢幕擷取畫面： TextAlign 屬性值為 Left](~/add/media/flowdoc-textalign-left.png "螢幕擷取畫面： TextAlign 屬性值為 Left")  
  
 下圖顯示相同的範例使用的轉譯方式**右**文字對齊方式。  
  
 ![螢幕擷取畫面： 權限的 TextAlign 值](~/add/media/flowdoc-textalign-right.png "螢幕擷取畫面： TextAlign 值為 Right")  
  
 下圖顯示相同的範例使用的轉譯方式**Center**文字對齊方式。  
  
 ![螢幕擷取畫面： TextAlign 屬性值為 Center](~/add/media/flowdoc-textalign-center.png "螢幕擷取畫面： TextAlign 屬性值為 Center")  
  
 下列範例示範如何設定<xref:System.Windows.Documents.AnchoredBlock.TextAlignment%2A>屬性以程式設計的方式。  
  
 [!code-csharp[BlockSnippets#_Block_TextAlignment](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml.cs#_block_textalignment)]
 [!code-vb[BlockSnippets#_Block_TextAlignment](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BlockSnippets/visualbasic/window1.xaml.vb#_block_textalignment)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TextAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TextAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.AnchoredBlock.TextAlignmentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextAlignmentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TextAlignmentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TextAlignmentProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.AnchoredBlock.TextAlignmentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.Documents.AnchoredBlock.TextAlignment" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>