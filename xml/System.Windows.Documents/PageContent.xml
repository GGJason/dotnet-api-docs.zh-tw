<Type Name="PageContent" FullName="System.Windows.Documents.PageContent">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3c3056daf5aee84aa7ca3bfb31a7427a87650617" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36362675" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class PageContent : System.Windows.FrameworkElement, System.Windows.Markup.IUriContext" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit PageContent extends System.Windows.FrameworkElement implements class System.Windows.Markup.IAddChild, class System.Windows.Markup.IUriContext" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.PageContent" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class PageContent&#xA;Inherits FrameworkElement&#xA;Implements IUriContext" />
  <TypeSignature Language="C++ CLI" Value="public ref class PageContent sealed : System::Windows::FrameworkElement, System::Windows::Markup::IUriContext" />
  <TypeSignature Language="F#" Value="type PageContent = class&#xA;    inherit FrameworkElement&#xA;    interface IAddChild&#xA;    interface IUriContext" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.FrameworkElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Markup.IUriContext</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.ContentProperty("Child")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Provides information about the <see cref="T:System.Windows.Documents.FixedPage" /> elements within a <see cref="T:System.Windows.Documents.FixedDocument" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.PageContent> 項目是唯一允許的子元素<xref:System.Windows.Documents.FixedDocument>。 順序<xref:System.Windows.Documents.PageContent>內的項目<xref:System.Windows.Documents.FixedDocument>定義頁面順序。  
  
 <xref:System.Windows.Documents.PageContent> 相關資訊提供<xref:System.Windows.Documents.FixedPage>內的項目<xref:System.Windows.Documents.FixedDocument>而不需要應用程式載入個別頁面。  
  
 <xref:System.Windows.Documents.PageContent.Source%2A>相依性屬性會指定[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]對應<xref:System.Windows.Documents.FixedPage>。  
  
 如需有關<xref:System.Windows.Documents.PageContent>項目，請參閱第 3 章的 XPS*開啟 XML Paper Specification*下載[XPS： 規格和授權下載](http://www.microsoft.com/whdc/xps/downloads.mspx)。  
  
   
  
## Examples  
 下列範例顯示的程序加入<xref:System.Windows.Documents.PageContent>至<xref:System.Windows.Documents.FixedDocument>。  
  
 [!code-csharp[XpsSave#XpsSaveCreateFixedDocPages](~/samples/snippets/csharp/VS_Snippets_Wpf/XpsSave/CSharp/XpfContent.cs#xpssavecreatefixeddocpages)]
 [!code-vb[XpsSave#XpsSaveCreateFixedDocPages](~/samples/snippets/visualbasic/VS_Snippets_Wpf/XpsSave/visualbasic/xpfcontent.vb#xpssavecreatefixeddocpages)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PageContent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.PageContent.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PageContent();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Windows.Documents.PageContent" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會示範搭配<xref:System.Windows.Documents.PageContent.%23ctor%2A>建構函式。  
  
 [!code-csharp[XpsSave#XpsSaveCreateFixedPage5](~/samples/snippets/csharp/VS_Snippets_Wpf/XpsSave/CSharp/XpfContent.cs#xpssavecreatefixedpage5)]
 [!code-vb[XpsSave#XpsSaveCreateFixedPage5](~/samples/snippets/visualbasic/VS_Snippets_Wpf/XpsSave/visualbasic/xpfcontent.vb#xpssavecreatefixedpage5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Child">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.FixedPage Child { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.FixedPage Child" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.PageContent.Child" />
      <MemberSignature Language="VB.NET" Value="Public Property Child As FixedPage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::FixedPage ^ Child { System::Windows::Documents::FixedPage ^ get(); void set(System::Windows::Documents::FixedPage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Child : System.Windows.Documents.FixedPage with get, set" Usage="System.Windows.Documents.PageContent.Child" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.FixedPage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the <see cref="T:System.Windows.Documents.FixedPage" /> associated with this <see cref="T:System.Windows.Documents.PageContent" />.</summary>
        <value>
          <see cref="T:System.Windows.Documents.FixedPage" />與此相關聯<see cref="T:System.Windows.Documents.PageContent" />，或 * * null * * 當<see cref="T:System.Windows.Documents.FixedPage" />由設定<see cref="P:System.Windows.Documents.PageContent.Source" />屬性。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.PageContent.Child%2A>屬性會傳回<xref:System.Windows.Documents.FixedPage>時：  
  
1.  <xref:System.Windows.Documents.PageContent> 具有即時<xref:System.Windows.Documents.FixedPage>中定義的子系[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]標記。  
  
2.  <xref:System.Windows.Documents.PageContent.System%23Windows%23Markup%23IAddChild%23AddChild%2A>已呼叫以設定<xref:System.Windows.Documents.FixedPage>為的子系<xref:System.Windows.Documents.PageContent>。  
  
 <xref:System.Windows.Documents.PageContent.Child%2A>屬性會傳回**null**時：  
  
1.  <xref:System.Windows.Documents.FixedPage>由設定<xref:System.Windows.Documents.PageContent.Source%2A>屬性 (所指定的<xref:System.Windows.Documents.PageContent.Source%2A>屬性，<xref:System.Windows.Documents.FixedPage>不會快取)。  使用<xref:System.Windows.Documents.PageContent.GetPageRoot%2A>或<xref:System.Windows.Documents.PageContent.GetPageRootAsync%2A>傳回<xref:System.Windows.Documents.FixedPage>時設定<xref:System.Windows.Documents.PageContent.Source%2A>屬性。  
  
 如需有關<xref:System.Windows.Documents.PageContent>項目，請參閱第 3 章的 XPS *XML Paper Specification*下載[ http://www.microsoft.com/whdc/xps/xpsspec.mspx ](http://www.microsoft.com/whdc/xps/xpsspec.mspx)。  
  
<a name="xamlTextUsage_Child"></a>   
## <a name="xaml-text-usage"></a>XAML 文字用法  
 您無法在 XAML 中使用這個屬性。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.PageContent.Source" />
      </Docs>
    </Member>
    <Member MemberName="GetPageRoot">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.FixedPage GetPageRoot (bool forceReload);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.FixedPage GetPageRoot(bool forceReload) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.PageContent.GetPageRoot(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPageRoot (forceReload As Boolean) As FixedPage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::FixedPage ^ GetPageRoot(bool forceReload);" />
      <MemberSignature Language="F#" Value="member this.GetPageRoot : bool -&gt; System.Windows.Documents.FixedPage" Usage="pageContent.GetPageRoot forceReload" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.FixedPage</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forceReload" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="forceReload">
          <see langword="true" /> to always reload the <see cref="T:System.Windows.Documents.FixedPage" /> even if it has been previously loaded and cached; <see langword="false" /> to load the <see cref="T:System.Windows.Documents.FixedPage" /> only if there is no cached version.</param>
        <summary>Loads and returns the <see cref="T:System.Windows.Documents.FixedPage" /> content element.</summary>
        <returns>The root element of the visual tree for this page.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.PageContent.GetPageRoot%2A> 執行同步的載入和剖析<xref:System.Windows.Documents.FixedPage>。  
  
> [!NOTE]
>  使用<xref:System.Windows.Documents.PageContent.GetPageRootAsync%2A>而不是<xref:System.Windows.Documents.PageContent.GetPageRoot%2A>以避免執行緒封鎖 while<xref:System.Windows.Documents.FixedPage>載入。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPageRootAsync">
      <MemberSignature Language="C#" Value="public void GetPageRootAsync (bool forceReload);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetPageRootAsync(bool forceReload) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.PageContent.GetPageRootAsync(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetPageRootAsync (forceReload As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetPageRootAsync(bool forceReload);" />
      <MemberSignature Language="F#" Value="member this.GetPageRootAsync : bool -&gt; unit" Usage="pageContent.GetPageRootAsync forceReload" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forceReload" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="forceReload">
          <see langword="true" /> to always reload the <see cref="T:System.Windows.Documents.FixedPage" /> even if it has been previously loaded and cached; <see langword="false" /> to load the <see cref="T:System.Windows.Documents.FixedPage" /> only if there is no cached version.</param>
        <summary>Asynchronously loads and returns the <see cref="T:System.Windows.Documents.FixedPage" /> content element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.PageContent.GetPageRootAsync%2A> 以非同步方式載入和剖析<xref:System.Windows.Documents.FixedPage>與此相關聯的資料流<xref:System.Windows.Documents.PageContent>。  其他的執行緒將會繼續執行而<xref:System.Windows.Documents.PageContent.GetPageRootAsync%2A>完成。  
  
 下列步驟說明如何載入<xref:System.Windows.Documents.FixedPage>內容以非同步的方式：  
  
1.  建立<xref:System.Windows.Documents.GetPageRootCompletedEventHandler>委派，並將它加入至通知<xref:System.Windows.Documents.PageContent.GetPageRootCompleted>事件。  
  
2.  呼叫 <xref:System.Windows.Documents.PageContent.GetPageRootAsync%2A>。  
  
3.  當<xref:System.Windows.Documents.PageContent.GetPageRootCompleted>發生事件時，會呼叫的委派，<xref:System.Windows.Documents.FixedPage>內容已完成載入。  載入<xref:System.Windows.Documents.FixedPage>項目透過傳回<xref:System.Windows.Documents.GetPageRootCompletedEventArgs>。<xref:System.Windows.Documents.GetPageRootCompletedEventArgs.Result%2A> 屬性。  
  
 如需有關`<PageContent>`項目，請參閱第 3 章即可取得在 XPS 規格的[XPS： 規格和授權下載](http://www.microsoft.com/whdc/xps/downloads.mspx)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.PageContent.GetPageRoot(System.Boolean)" />
        <altmember cref="M:System.Windows.Documents.PageContent.GetPageRootAsyncCancel" />
        <altmember cref="E:System.Windows.Documents.PageContent.GetPageRootCompleted" />
        <altmember cref="T:System.Windows.Documents.GetPageRootCompletedEventArgs" />
        <altmember cref="T:System.Windows.Documents.GetPageRootCompletedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="GetPageRootAsyncCancel">
      <MemberSignature Language="C#" Value="public void GetPageRootAsyncCancel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetPageRootAsyncCancel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.PageContent.GetPageRootAsyncCancel" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetPageRootAsyncCancel ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetPageRootAsyncCancel();" />
      <MemberSignature Language="F#" Value="member this.GetPageRootAsyncCancel : unit -&gt; unit" Usage="pageContent.GetPageRootAsyncCancel " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancels any current <see cref="M:System.Windows.Documents.PageContent.GetPageRootAsync(System.Boolean)" /> operation in progress.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.PageContent.GetPageRootAsyncCancel%2A> 取消任何<xref:System.Windows.Documents.PageContent.GetPageRootAsync%2A>作業尚未完成與<xref:System.Windows.Documents.PageContent.GetPageRootCompleted>事件。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.PageContent.GetPageRootAsync(System.Boolean)" />
        <altmember cref="M:System.Windows.Documents.PageContent.GetPageRootAsyncCancel" />
        <altmember cref="E:System.Windows.Documents.PageContent.GetPageRootCompleted" />
        <altmember cref="T:System.Windows.Documents.GetPageRootCompletedEventArgs" />
        <altmember cref="T:System.Windows.Documents.GetPageRootCompletedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="GetPageRootCompleted">
      <MemberSignature Language="C#" Value="public event System.Windows.Documents.GetPageRootCompletedEventHandler GetPageRootCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Documents.GetPageRootCompletedEventHandler GetPageRootCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Documents.PageContent.GetPageRootCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Event GetPageRootCompleted As GetPageRootCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Documents::GetPageRootCompletedEventHandler ^ GetPageRootCompleted;" />
      <MemberSignature Language="F#" Value="member this.GetPageRootCompleted : System.Windows.Documents.GetPageRootCompletedEventHandler " Usage="member this.GetPageRootCompleted : System.Windows.Documents.GetPageRootCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.GetPageRootCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when <see cref="M:System.Windows.Documents.PageContent.GetPageRootAsync(System.Boolean)" /> has completed.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.PageContent.GetPageRootCompleted>事件由根據方法<xref:System.Windows.Documents.GetPageRootCompletedEventHandler>委派。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.PageContent.GetPageRootAsync(System.Boolean)" />
        <altmember cref="M:System.Windows.Documents.PageContent.GetPageRootAsyncCancel" />
        <altmember cref="T:System.Windows.Documents.GetPageRootCompletedEventArgs" />
        <altmember cref="T:System.Windows.Documents.GetPageRootCompletedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="LinkTargets">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.LinkTargetCollection LinkTargets { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.LinkTargetCollection LinkTargets" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.PageContent.LinkTargets" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LinkTargets As LinkTargetCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::LinkTargetCollection ^ LinkTargets { System::Windows::Documents::LinkTargetCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LinkTargets : System.Windows.Documents.LinkTargetCollection" Usage="System.Windows.Documents.PageContent.LinkTargets" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.LinkTargetCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a collection of <see cref="T:System.Windows.Documents.LinkTarget" /> elements that identify the hyperlink-addressable locations on the page.</summary>
        <value>
          <see cref="T:System.Windows.Documents.LinkTargetCollection" />的<see cref="T:System.Windows.Documents.LinkTarget" />識別超連結可定址的位置在頁面上的項目。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.PageContent.LinkTargets%2A> 永遠不會傳回`null`，但集合可能包含零個項目。  
  
 如需有關`<PageContent>`項目，請參閱第 3 章即可取得在 XPS 規格的[XPS： 規格和授權下載](http://www.microsoft.com/whdc/xps/downloads.mspx)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.FixedPage.NavigateUri" />
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.PageContent.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.Documents.PageContent.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeChild">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeChild (System.Windows.Markup.XamlDesignerSerializationManager manager);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeChild(class System.Windows.Markup.XamlDesignerSerializationManager manager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.PageContent.ShouldSerializeChild(System.Windows.Markup.XamlDesignerSerializationManager)" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeChild (manager As XamlDesignerSerializationManager) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeChild(System::Windows::Markup::XamlDesignerSerializationManager ^ manager);" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeChild : System.Windows.Markup.XamlDesignerSerializationManager -&gt; bool" Usage="pageContent.ShouldSerializeChild manager" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="manager" Type="System.Windows.Markup.XamlDesignerSerializationManager" />
      </Parameters>
      <Docs>
        <param name="manager">The serialization services provider.</param>
        <summary>Gets a value indicating whether the value of the <see cref="P:System.Windows.Documents.PageContent.Child" /> property should be serialized when this <see cref="T:System.Windows.Documents.PageContent" /> is serialized.</summary>
        <returns>
          <see langword="true" /> if <paramref name="manager" /> is not <see langword="null" /> and it does not have an XmlWriter; otherwise, <see langword="false" />. The default is <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public Uri Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.PageContent.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Source { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : Uri with get, set" Usage="System.Windows.Documents.PageContent.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] to the <see cref="T:System.Windows.Documents.FixedPage" /> content data stream.</summary>
        <value>
          <see cref="T:System.Uri" />對應<see cref="T:System.Windows.Documents.FixedPage" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需有關`<PageContent>`項目和其`Source`屬性，請參閱第 3 章，您可以在取得 XPS 規格的[XPS： 規格和授權下載](http://www.microsoft.com/whdc/xps/downloads.mspx)。  
  
<a name="dependencyPropertyInfo_Source"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.Documents.PageContent.SourceProperty>|  
|中繼資料屬性設定為 `true`|無|  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Documents.PageContent.SourceProperty" />
      </Docs>
    </Member>
    <Member MemberName="SourceProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty SourceProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty SourceProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.PageContent.SourceProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SourceProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ SourceProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable SourceProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.PageContent.SourceProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Documents.PageContent.Source" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddChild">
      <MemberSignature Language="C#" Value="void IAddChild.AddChild (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddChild(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.PageContent.System#Windows#Markup#IAddChild#AddChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub AddChild (value As Object) Implements IAddChild.AddChild" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddChild(System::Object ^ value) = System::Windows::Markup::IAddChild::AddChild;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddChild(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The child <see cref="T:System.Object" /> to add.</param>
        <summary>For a description of this member, see <see cref="M:System.Windows.Markup.IAddChild.AddChild(System.Object)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作。 只有在 <xref:System.Windows.Documents.PageContent> 執行個體轉換成 <xref:System.Windows.Markup.IAddChild> 介面時，才能使用這個成員。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddText">
      <MemberSignature Language="C#" Value="void IAddChild.AddText (string text);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddText(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.PageContent.System#Windows#Markup#IAddChild#AddText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub AddText (text As String) Implements IAddChild.AddText" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddText(System::String ^ text) = System::Windows::Markup::IAddChild::AddText;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddText(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">The text to add to the object.</param>
        <summary>For a description of this member, see <see cref="M:System.Windows.Markup.IAddChild.AddText(System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作。 只有在 <xref:System.Windows.Documents.PageContent> 執行個體轉換成 <xref:System.Windows.Markup.IAddChild> 介面時，才能使用這個成員。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IUriContext.BaseUri">
      <MemberSignature Language="C#" Value="Uri System.Windows.Markup.IUriContext.BaseUri { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri System.Windows.Markup.IUriContext.BaseUri" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.PageContent.System#Windows#Markup#IUriContext#BaseUri" />
      <MemberSignature Language="VB.NET" Value=" Property BaseUri As Uri Implements IUriContext.BaseUri" />
      <MemberSignature Language="C++ CLI" Value="property Uri ^ System.Windows.Markup.IUriContext.BaseUri { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Windows.Documents.PageContent.System.Windows.Markup.IUriContext.BaseUri" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Markup.IUriContext.BaseUri</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>For a description of this member, see <see cref="P:System.Windows.Markup.IUriContext.BaseUri" />.</summary>
        <value>目前內容的基底 URI。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作。 只有在 <xref:System.Windows.Documents.PageContent> 執行個體轉換成 <xref:System.Windows.Markup.IUriContext> 介面時，才能使用這個成員。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>