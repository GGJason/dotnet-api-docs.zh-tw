<Type Name="DataContext" FullName="System.Data.Linq.DataContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="71a1483d921d27225f75df3cf4d0ff5661cde8c7" /><Meta Name="ms.sourcegitcommit" Value="2dd0eede6edd6dd3d2aa8f79010848658b967609" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="04/18/2019" /><Meta Name="ms.locfileid" Value="59348022" /></Metadata><TypeSignature Language="C#" Value="public class DataContext : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DataContext extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Data.Linq.DataContext" />
  <TypeSignature Language="VB.NET" Value="Public Class DataContext&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataContext : IDisposable" />
  <TypeSignature Language="F#" Value="type DataContext = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Linq</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="01340-101">表示 LINQ to SQL 架構的主要進入點。</span><span class="sxs-lookup"><span data-stu-id="01340-101">Represents the main entry point for the LINQ to SQL framework.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01340-102"><xref:System.Data.Linq.DataContext>對應資料庫連接的所有實體的來源。</span><span class="sxs-lookup"><span data-stu-id="01340-102">The <xref:System.Data.Linq.DataContext> is the source of all entities mapped over a database connection.</span></span> <span data-ttu-id="01340-103">它會追蹤您對所有擷取的實體所做的變更，並會維護 「 身分識別快取 」，實體擷取一次以上的保證都由使用相同的物件執行個體。</span><span class="sxs-lookup"><span data-stu-id="01340-103">It tracks changes that you made to all retrieved entities and maintains an "identity cache" that guarantees that entities retrieved more than one time are represented by using the same object instance.</span></span>  
  
 <span data-ttu-id="01340-104">一般情況下，<xref:System.Data.Linq.DataContext>執行個體是最後一個 「 工作單元 」 不過您的應用程式會定義該字詞。</span><span class="sxs-lookup"><span data-stu-id="01340-104">In general, a <xref:System.Data.Linq.DataContext> instance is designed to last for one "unit of work" however your application defines that term.</span></span> <span data-ttu-id="01340-105">A<xref:System.Data.Linq.DataContext>是輕量且不耗費大量資源。</span><span class="sxs-lookup"><span data-stu-id="01340-105">A <xref:System.Data.Linq.DataContext> is lightweight and is not expensive to create.</span></span> <span data-ttu-id="01340-106">典型[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]應用程式會建立<xref:System.Data.Linq.DataContext>在方法範圍內，或為短期的類別，代表一組邏輯的成員執行個體相關的資料庫作業。</span><span class="sxs-lookup"><span data-stu-id="01340-106">A typical [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] application creates <xref:System.Data.Linq.DataContext> instances at method scope or as a member of short-lived classes that represent a logical set of related database operations.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="01340-107">初始化 <see cref="T:System.Data.Linq.DataContext" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="01340-107">Initializes a new instance of the <see cref="T:System.Data.Linq.DataContext" /> class.</span></span> <span data-ttu-id="01340-108">您使用的連接字串可以是 ADO.NET 連接字串。</span><span class="sxs-lookup"><span data-stu-id="01340-108">The connection string you use can be an ADO.NET connection string.</span></span> <span data-ttu-id="01340-109">您也可以指定 SQL Server Express 或 SQL Server Compact 檔案的檔名。</span><span class="sxs-lookup"><span data-stu-id="01340-109">You can also specify a filename to a SQL Server Express or SQL Server Compact file.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContext (System.Data.IDbConnection connection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.IDbConnection connection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connection As IDbConnection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::Data::IDbConnection ^ connection);" />
      <MemberSignature Language="F#" Value="new System.Data.Linq.DataContext : System.Data.IDbConnection -&gt; System.Data.Linq.DataContext" Usage="new System.Data.Linq.DataContext connection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.IDbConnection" />
      </Parameters>
      <Docs>
        <param name="connection"><span data-ttu-id="01340-110">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 所使用的連接。</span><span class="sxs-lookup"><span data-stu-id="01340-110">The connection used by the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].</span></span></param>
        <summary><span data-ttu-id="01340-111">參考 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 所使用的連接，以初始化 <see cref="T:System.Data.Linq.DataContext" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="01340-111">Initializes a new instance of the <see cref="T:System.Data.Linq.DataContext" /> class by referencing the connection used by the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01340-112">A<xref:System.Data.Linq.DataContext>開啟和關閉資料庫連接，視您提供關閉的連接或連接字串。</span><span class="sxs-lookup"><span data-stu-id="01340-112">A <xref:System.Data.Linq.DataContext> opens and closes a database connection as needed if you provide a closed connection or a connection string.</span></span> <span data-ttu-id="01340-113">一般情況下，您應該永遠不需要呼叫`Dispose`上<xref:System.Data.Linq.DataContext>。</span><span class="sxs-lookup"><span data-stu-id="01340-113">In general, you should never have to call `Dispose` on a <xref:System.Data.Linq.DataContext>.</span></span> <span data-ttu-id="01340-114">如果您提供的開啟連接，<xref:System.Data.Linq.DataContext>就不會關閉它。</span><span class="sxs-lookup"><span data-stu-id="01340-114">If you provide an open connection, the <xref:System.Data.Linq.DataContext> will not close it.</span></span> <span data-ttu-id="01340-115">因此，請勿執行個體化<xref:System.Data.Linq.DataContext>與開啟的連接除非您有正當的理由。</span><span class="sxs-lookup"><span data-stu-id="01340-115">Therefore, do not instantiate a <xref:System.Data.Linq.DataContext> with an open connection unless you have a good reason to do this.</span></span> <span data-ttu-id="01340-116">在 <xref:System.Transactions>交易，<xref:System.Data.Linq.DataContext>將無法開啟或關閉連接，以避免升級。</span><span class="sxs-lookup"><span data-stu-id="01340-116">In a <xref:System.Transactions> transaction, a <xref:System.Data.Linq.DataContext> will not open or close a connection to avoid promotion.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContext (System.Data.IDbConnection connection, System.Data.Linq.Mapping.MappingSource mapping);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.IDbConnection connection, class System.Data.Linq.Mapping.MappingSource mapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection,System.Data.Linq.Mapping.MappingSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connection As IDbConnection, mapping As MappingSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::Data::IDbConnection ^ connection, System::Data::Linq::Mapping::MappingSource ^ mapping);" />
      <MemberSignature Language="F#" Value="new System.Data.Linq.DataContext : System.Data.IDbConnection * System.Data.Linq.Mapping.MappingSource -&gt; System.Data.Linq.DataContext" Usage="new System.Data.Linq.DataContext (connection, mapping)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.IDbConnection" />
        <Parameter Name="mapping" Type="System.Data.Linq.Mapping.MappingSource" />
      </Parameters>
      <Docs>
        <param name="connection"><span data-ttu-id="01340-117">.NET Framework 所使用的連接。</span><span class="sxs-lookup"><span data-stu-id="01340-117">The connection used by the .NET Framework.</span></span></param>
        <param name="mapping"><span data-ttu-id="01340-118">對應來源。</span><span class="sxs-lookup"><span data-stu-id="01340-118">A source for mapping.</span></span></param>
        <summary><span data-ttu-id="01340-119">參考連接和對應來源，以初始化 <see cref="T:System.Data.Linq.DataContext" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="01340-119">Initializes a new instance of the <see cref="T:System.Data.Linq.DataContext" /> class by referencing a connection and a mapping source.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContext (string fileOrServerOrConnection, System.Data.Linq.Mapping.MappingSource mapping);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileOrServerOrConnection, class System.Data.Linq.Mapping.MappingSource mapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.String,System.Data.Linq.Mapping.MappingSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileOrServerOrConnection As String, mapping As MappingSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::String ^ fileOrServerOrConnection, System::Data::Linq::Mapping::MappingSource ^ mapping);" />
      <MemberSignature Language="F#" Value="new System.Data.Linq.DataContext : string * System.Data.Linq.Mapping.MappingSource -&gt; System.Data.Linq.DataContext" Usage="new System.Data.Linq.DataContext (fileOrServerOrConnection, mapping)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileOrServerOrConnection" Type="System.String" />
        <Parameter Name="mapping" Type="System.Data.Linq.Mapping.MappingSource" />
      </Parameters>
      <Docs>
        <param name="fileOrServerOrConnection"><span data-ttu-id="01340-120">這個引數可以是下列任一項：</span><span class="sxs-lookup"><span data-stu-id="01340-120">This argument can be any one of the following:</span></span> 
<span data-ttu-id="01340-121">SQL Server Express 資料庫所在之檔案的名稱。</span><span class="sxs-lookup"><span data-stu-id="01340-121">The name of a file where a SQL Server Express database resides.</span></span>  
  
<span data-ttu-id="01340-122">呈現資料庫之伺服器的名稱。</span><span class="sxs-lookup"><span data-stu-id="01340-122">The name of a server where a database is present.</span></span> <span data-ttu-id="01340-123">在此情況下，提供者會使用使用者的預設資料庫。</span><span class="sxs-lookup"><span data-stu-id="01340-123">In this case the provider uses the default database for a user.</span></span>  
  
<span data-ttu-id="01340-124">完整連接字串。</span><span class="sxs-lookup"><span data-stu-id="01340-124">A complete connection string.</span></span> [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] <span data-ttu-id="01340-125">只傳遞字串給提供者，但不做修改。</span><span class="sxs-lookup"><span data-stu-id="01340-125">just passes the string to the provider without modification.</span></span></param>
        <param name="mapping"><span data-ttu-id="01340-126">對應來源。</span><span class="sxs-lookup"><span data-stu-id="01340-126">A source for mapping.</span></span></param>
        <summary><span data-ttu-id="01340-127">參考檔案來源和對應來源，以初始化 <see cref="T:System.Data.Linq.DataContext" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="01340-127">Initializes a new instance of the <see cref="T:System.Data.Linq.DataContext" /> class by referencing a file source and a mapping source.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContext (string fileOrServerOrConnection);" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileOrServerOrConnection) cil managed" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileOrServerOrConnection As String)" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::String ^ fileOrServerOrConnection);" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.5;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="C#" Value="public DataContext (string connectionString);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string connectionString) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connectionString As String)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::String ^ connectionString);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.String)" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="new System.Data.Linq.DataContext : string -&gt; System.Data.Linq.DataContext" Usage="new System.Data.Linq.DataContext connectionString" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.String)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="new System.Data.Linq.DataContext : string -&gt; System.Data.Linq.DataContext" Usage="new System.Data.Linq.DataContext connectionString" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileOrServerOrConnection" Type="System.String" Index="0" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="connectionString" Type="System.String" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileOrServerOrConnection"><span data-ttu-id="01340-128">這個引數可以是下列任一項：SQL Server Express 資料庫所在之檔案的名稱。</span><span class="sxs-lookup"><span data-stu-id="01340-128">This argument can be any one of the following: The name of a file where a SQL Server Express database resides.</span></span>

<span data-ttu-id="01340-129">呈現資料庫之伺服器的名稱。</span><span class="sxs-lookup"><span data-stu-id="01340-129">The name of a server where a database is present.</span></span> <span data-ttu-id="01340-130">在此情況下，提供者會使用使用者的預設資料庫。</span><span class="sxs-lookup"><span data-stu-id="01340-130">In this case the provider uses the default database for a user.</span></span>  
  
<span data-ttu-id="01340-131">完整連接字串。</span><span class="sxs-lookup"><span data-stu-id="01340-131">A complete connection string.</span></span> <span data-ttu-id="01340-132">LINQ to SQL 只會傳遞字串給提供者，但不會進行修改。</span><span class="sxs-lookup"><span data-stu-id="01340-132">LINQ to SQL just passes the string to the provider without modification.</span></span></param>
        <param name="connectionString"><span data-ttu-id="01340-133">這個引數可以是下列任一項：SQL Server Express 資料庫所在之檔案的名稱。</span><span class="sxs-lookup"><span data-stu-id="01340-133">This argument can be any one of the following: The name of a file where a SQL Server Express database resides.</span></span>

<span data-ttu-id="01340-134">呈現資料庫之伺服器的名稱。</span><span class="sxs-lookup"><span data-stu-id="01340-134">The name of a server where a database is present.</span></span> <span data-ttu-id="01340-135">在此情況下，提供者會使用使用者的預設資料庫。</span><span class="sxs-lookup"><span data-stu-id="01340-135">In this case the provider uses the default database for a user.</span></span>  
  
<span data-ttu-id="01340-136">完整連接字串。</span><span class="sxs-lookup"><span data-stu-id="01340-136">A complete connection string.</span></span> <span data-ttu-id="01340-137">LINQ to SQL 只會傳遞字串給提供者，但不會進行修改。</span><span class="sxs-lookup"><span data-stu-id="01340-137">LINQ to SQL just passes the string to the provider without modification.</span></span></param>
        <summary><span data-ttu-id="01340-138">參考檔案來源，以初始化 <see cref="T:System.Data.Linq.DataContext" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="01340-138">Initializes a new instance of the <see cref="T:System.Data.Linq.DataContext" /> class by referencing a file source.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ChangeConflicts">
      <MemberSignature Language="C#" Value="public System.Data.Linq.ChangeConflictCollection ChangeConflicts { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Linq.ChangeConflictCollection ChangeConflicts" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.ChangeConflicts" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChangeConflicts As ChangeConflictCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Linq::ChangeConflictCollection ^ ChangeConflicts { System::Data::Linq::ChangeConflictCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ChangeConflicts : System.Data.Linq.ChangeConflictCollection" Usage="System.Data.Linq.DataContext.ChangeConflicts" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.ChangeConflictCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="01340-139">取得當呼叫 <see cref="M:System.Data.Linq.DataContext.SubmitChanges" /> 時，會導致並行存取衝突的物件集合。</span><span class="sxs-lookup"><span data-stu-id="01340-139">Gets a collection of objects that caused concurrency conflicts when <see cref="M:System.Data.Linq.DataContext.SubmitChanges" /> was called.</span></span></summary>
        <value><span data-ttu-id="01340-140">導致並行存取衝突之物件的集合。</span><span class="sxs-lookup"><span data-stu-id="01340-140">A collection of objects that caused concurrency conflicts.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01340-141">下列範例會示範如何集合可以反覆擷取衝突資訊。</span><span class="sxs-lookup"><span data-stu-id="01340-141">The following example shows how the collection can be iterated over to retrieve conflict information.</span></span>  
  
   
  
## Examples  
 [!code-csharp[System.Data.Linq.ObjectChangeConflict#1](~/samples/snippets/csharp/VS_Snippets_Data/system.data.linq.objectchangeconflict/cs/program.cs#1)]
 [!code-vb[System.Data.Linq.ObjectChangeConflict#1](~/samples/snippets/visualbasic/VS_Snippets_Data/system.data.linq.objectchangeconflict/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandTimeout">
      <MemberSignature Language="C#" Value="public int CommandTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CommandTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.CommandTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CommandTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CommandTimeout : int with get, set" Usage="System.Data.Linq.DataContext.CommandTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="01340-142">取得或設定值，該值會增加查詢的逾時期間 (以秒為單位)，否則查詢會在預設逾時期間內逾時。</span><span class="sxs-lookup"><span data-stu-id="01340-142">Gets or sets a value that increases the time-out period (in seconds) for queries that would otherwise time out during the default time-out period.</span></span></summary>
        <value><span data-ttu-id="01340-143">整數值，會增加會否則預設逾時期間的查詢逾時期限 （以秒為單位）。</span><span class="sxs-lookup"><span data-stu-id="01340-143">An integer value that increases the time-out period (in seconds) for queries that would otherwise time out during the default time-out period.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01340-144">此屬性會取得或設定用來執行產生的命令 （以秒為單位） 命令逾時 (`IDbCommands`)。</span><span class="sxs-lookup"><span data-stu-id="01340-144">This property gets or sets the command time-out (in seconds) used to execute generated commands (`IDbCommands`).</span></span> <span data-ttu-id="01340-145">如需詳細資訊，請參閱<xref:System.Data.IDbCommand.CommandTimeout%2A>。</span><span class="sxs-lookup"><span data-stu-id="01340-145">For more information, see <xref:System.Data.IDbCommand.CommandTimeout%2A>.</span></span>  
  
 <span data-ttu-id="01340-146">當這個屬性未設定，預設值<xref:System.Data.IDbCommand.CommandTimeout%2A>用於執行查詢命令。</span><span class="sxs-lookup"><span data-stu-id="01340-146">When this property is not set, the default value of <xref:System.Data.IDbCommand.CommandTimeout%2A> is used for query command execution.</span></span> <span data-ttu-id="01340-147">此預設值是由設定存放裝置提供者。</span><span class="sxs-lookup"><span data-stu-id="01340-147">This default value is set by the storage provider.</span></span> <span data-ttu-id="01340-148">請注意，某些提供者可能會擲回例外狀況是否此值設為非零的值。</span><span class="sxs-lookup"><span data-stu-id="01340-148">Note that some providers may throw exceptions if this value is set to a non-zero value.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbConnection Connection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbConnection Connection" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.Connection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connection As DbConnection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbConnection ^ Connection { System::Data::Common::DbConnection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Connection : System.Data.Common.DbConnection" Usage="System.Data.Linq.DataContext.Connection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbConnection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="01340-149">取得架構所使用的連接。</span><span class="sxs-lookup"><span data-stu-id="01340-149">Gets the connection used by the framework.</span></span></summary>
        <value><span data-ttu-id="01340-150">Framework 所使用的連接。</span><span class="sxs-lookup"><span data-stu-id="01340-150">The connection used by the framework.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01340-151">您可以使用這個屬性與關聯式的 ADO.NET 程式碼交互操作。</span><span class="sxs-lookup"><span data-stu-id="01340-151">You can use this property to interoperate with relational ADO.NET code.</span></span>  
  
 <span data-ttu-id="01340-152">傳回的連接將會關閉，除非它已由使用者明確地開啟。</span><span class="sxs-lookup"><span data-stu-id="01340-152">The returned connection will be closed unless it has been explicitly opened by the user.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDatabase">
      <MemberSignature Language="C#" Value="public void CreateDatabase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateDatabase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.CreateDatabase" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateDatabase ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateDatabase();" />
      <MemberSignature Language="F#" Value="member this.CreateDatabase : unit -&gt; unit" Usage="dataContext.CreateDatabase " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="01340-153">在伺服器上建立資料庫。</span><span class="sxs-lookup"><span data-stu-id="01340-153">Creates a database on the server.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01340-154">使用下列演算法衍生的資料庫名稱：</span><span class="sxs-lookup"><span data-stu-id="01340-154">The name of the database is derived by using the following algorithm:</span></span>  
  
1. <span data-ttu-id="01340-155">如果資料庫中的連接字串，則會使用其名稱。</span><span class="sxs-lookup"><span data-stu-id="01340-155">If a database is identified in the connection string, its name is used.</span></span>  
1. <span data-ttu-id="01340-156">如果<xref:System.Data.Linq.Mapping.DatabaseAttribute>屬性已存在，其<xref:System.Data.Linq.Mapping.DatabaseAttribute.Name%2A>屬性做為資料庫的名稱。</span><span class="sxs-lookup"><span data-stu-id="01340-156">If a <xref:System.Data.Linq.Mapping.DatabaseAttribute> attribute is present, its <xref:System.Data.Linq.Mapping.DatabaseAttribute.Name%2A> property is used as the name of the database.</span></span>  
1. <span data-ttu-id="01340-157">如果沒有資料庫中沒有標記的連接字串和強型別<xref:System.Data.Linq.DataContext>使用時，具有相同名稱的資料庫<xref:System.Data.Linq.DataContext>繼承類別建立。</span><span class="sxs-lookup"><span data-stu-id="01340-157">If there is no database tag in the connection string and a strongly typed <xref:System.Data.Linq.DataContext> is used, a database that has the same name as the <xref:System.Data.Linq.DataContext> inheriting class is created.</span></span>  
1. <span data-ttu-id="01340-158">如果弱型別<xref:System.Data.Linq.DataContext>是使用，會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="01340-158">If a weakly typed <xref:System.Data.Linq.DataContext> is used, an exception is thrown.</span></span>  
1. <span data-ttu-id="01340-159">如果<xref:System.Data.Linq.DataContext>已建立藉由使用檔案名稱，建立對應至該檔案名稱的資料庫。</span><span class="sxs-lookup"><span data-stu-id="01340-159">If the <xref:System.Data.Linq.DataContext> has been created by using a file name, the database corresponding to that file name is created.</span></span>  
     
  
## Examples  
 <span data-ttu-id="01340-160">下列程式碼示範如何設定暫存資料庫並加以移除。</span><span class="sxs-lookup"><span data-stu-id="01340-160">The following code shows how to set up a temporary database and then remove it.</span></span>  
  
 [!code-csharp[System.Data.Linq.DataContext#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.DataContext/cs/Program.cs#1)]
 [!code-vb[System.Data.Linq.DataContext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.DataContext/vb/Module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/fb7f23c4-4572-4c38-9898-a287807d070c"><span data-ttu-id="01340-161">HOW TO：動態建立資料庫 (LINQ to SQL)</span><span class="sxs-lookup"><span data-stu-id="01340-161">How to: Dynamically Create a Database (LINQ to SQL)</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/4ed76327-54a7-414b-82a9-7579bfcec04b"><span data-ttu-id="01340-162">SQL-CLR 類型對應 (LINQ to SQL)</span><span class="sxs-lookup"><span data-stu-id="01340-162">SQL-CLR Type Mapping (LINQ to SQL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CreateMethodCallQuery&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="protected internal System.Linq.IQueryable&lt;TResult&gt; CreateMethodCallQuery&lt;TResult&gt; (object instance, System.Reflection.MethodInfo methodInfo, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Linq.IQueryable`1&lt;!!TResult&gt; CreateMethodCallQuery&lt;TResult&gt;(object instance, class System.Reflection.MethodInfo methodInfo, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.CreateMethodCallQuery``1(System.Object,System.Reflection.MethodInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Linq::IQueryable&lt;TResult&gt; ^ CreateMethodCallQuery(System::Object ^ instance, System::Reflection::MethodInfo ^ methodInfo, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.CreateMethodCallQuery : obj * System.Reflection.MethodInfo * obj[] -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="dataContext.CreateMethodCallQuery (instance, methodInfo, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
        <Parameter Name="methodInfo" Type="System.Reflection.MethodInfo" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="01340-163">所傳回集合中項目的型別。</span><span class="sxs-lookup"><span data-stu-id="01340-163">The type of the elements in the returned collection.</span></span></typeparam>
        <param name="instance"><span data-ttu-id="01340-164">方法引動過程的執行個體 (目前物件)。</span><span class="sxs-lookup"><span data-stu-id="01340-164">The instance of the method invocation (the current object).</span></span></param>
        <param name="methodInfo"><span data-ttu-id="01340-165">指出對應到資料庫方法之 .NET 方法的 <see cref="T:System.Reflection.MethodInfo" />。</span><span class="sxs-lookup"><span data-stu-id="01340-165">The <see cref="T:System.Reflection.MethodInfo" /> that identifies the .NET method that corresponds to a database method.</span></span></param>
        <param name="parameters"><span data-ttu-id="01340-166">要傳遞至命令的參數陣列。</span><span class="sxs-lookup"><span data-stu-id="01340-166">The array of parameters to be passed to the command.</span></span></param>
        <summary><span data-ttu-id="01340-167">執行與指定之 .NET 方法關聯的資料表值資料庫函式。</span><span class="sxs-lookup"><span data-stu-id="01340-167">Executes the table-valued database function associated with the specified .NET method.</span></span></summary>
        <returns><span data-ttu-id="01340-168">資料庫查詢所傳回結果值的集合。</span><span class="sxs-lookup"><span data-stu-id="01340-168">A collection of resultant values returned by the database query.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01340-169"><xref:System.Data.Linq.DataContext.CreateMethodCallQuery%2A>方法用於自動產生的程式碼，並做為資料庫函式的 proxy。</span><span class="sxs-lookup"><span data-stu-id="01340-169">The <xref:System.Data.Linq.DataContext.CreateMethodCallQuery%2A> method is used in automatically generated code and acts as a proxy to database functions.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DatabaseExists">
      <MemberSignature Language="C#" Value="public bool DatabaseExists ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DatabaseExists() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.DatabaseExists" />
      <MemberSignature Language="VB.NET" Value="Public Function DatabaseExists () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DatabaseExists();" />
      <MemberSignature Language="F#" Value="member this.DatabaseExists : unit -&gt; bool" Usage="dataContext.DatabaseExists " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="01340-170">判斷是否可以開啟關聯的資料庫。</span><span class="sxs-lookup"><span data-stu-id="01340-170">Determines whether the associated database can be opened.</span></span></summary>
        <returns><span data-ttu-id="01340-171">如果可以開啟指定的資料庫，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="01340-171"><see langword="true" /> if the specified database can be opened; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01340-172">這個方法會使用中的連接<xref:System.Data.Linq.DataContext.Connection%2A>嘗試開啟相關聯的資料庫的屬性。</span><span class="sxs-lookup"><span data-stu-id="01340-172">This method uses the connection in the <xref:System.Data.Linq.DataContext.Connection%2A> property to attempt to open the associated database.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="01340-173">下列範例會使用這個方法，以判斷是否已經存在的資料庫。</span><span class="sxs-lookup"><span data-stu-id="01340-173">The following example uses this method to determine whether a database already exists.</span></span>  
  
 [!code-csharp[System.Data.Linq.DataContext#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.DataContext/cs/Program.cs#1)]
 [!code-vb[System.Data.Linq.DataContext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.DataContext/vb/Module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferredLoadingEnabled">
      <MemberSignature Language="C#" Value="public bool DeferredLoadingEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DeferredLoadingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.DeferredLoadingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property DeferredLoadingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DeferredLoadingEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DeferredLoadingEnabled : bool with get, set" Usage="System.Data.Linq.DataContext.DeferredLoadingEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="01340-174">取得或設定值，指出是否要延遲載入一對多或一對一關聯性。</span><span class="sxs-lookup"><span data-stu-id="01340-174">Gets or sets a value that indicates whether to delay-load one-to-many or one-to-one relationships.</span></span></summary>
        <value><span data-ttu-id="01340-175">如果啟用延後載入則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="01340-175"><see langword="true" /> if deferred loading is enabled; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01340-176">當程式碼存取其中一個這些關聯性，null 會傳回的關聯性是一對一，以及它是否為一對多，會傳回空的集合。</span><span class="sxs-lookup"><span data-stu-id="01340-176">When the code accesses one of these relationships, null is returned if the relationship is one-to-one, and an empty collection is returned if it is one-to-many.</span></span> <span data-ttu-id="01340-177">關聯性仍然可以藉由設定填入<xref:System.Data.Linq.DataContext.LoadOptions%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="01340-177">The relationships can still be filled by setting the <xref:System.Data.Linq.DataContext.LoadOptions%2A> property.</span></span>  
  
 <span data-ttu-id="01340-178">這個屬性的主要案例是要讓您擷取一種物件模型，並將它傳送 （比方說，給 Web 服務）。</span><span class="sxs-lookup"><span data-stu-id="01340-178">The main scenario for this property is to enable you to extract a piece of the object model and send it out (for example, to a Web service).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="01340-179">如果這個屬性設定為`false`執行查詢之後，會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="01340-179">If this property is set to `false` after a query has been executed, an exception is thrown.</span></span> <span data-ttu-id="01340-180">請參閱**有效的模式**如需詳細資訊，如下一節。</span><span class="sxs-lookup"><span data-stu-id="01340-180">See the **Valid Modes** section below for more information.</span></span>  
  
## <a name="valid-modes"></a><span data-ttu-id="01340-181">有效的模式</span><span class="sxs-lookup"><span data-stu-id="01340-181">Valid modes</span></span>  
 <span data-ttu-id="01340-182">延後的載入需要物件追蹤。</span><span class="sxs-lookup"><span data-stu-id="01340-182">Deferred loading requires object tracking.</span></span> <span data-ttu-id="01340-183">只有下列的三種模式是有效的：</span><span class="sxs-lookup"><span data-stu-id="01340-183">Only the following three modes are valid:</span></span>  
  
-   <span data-ttu-id="01340-184"><xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> = `false`.</span><span class="sxs-lookup"><span data-stu-id="01340-184"><xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> = `false`.</span></span> <span data-ttu-id="01340-185"><xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> 會忽略和推斷為`false`。</span><span class="sxs-lookup"><span data-stu-id="01340-185"><xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> is ignored and inferred to be `false`.</span></span> <span data-ttu-id="01340-186">此行為與唯讀<xref:System.Data.Linq.DataContext>。</span><span class="sxs-lookup"><span data-stu-id="01340-186">This behavior corresponds to a read-only <xref:System.Data.Linq.DataContext>.</span></span>  
  
-   <span data-ttu-id="01340-187"><xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> = `true`.</span><span class="sxs-lookup"><span data-stu-id="01340-187"><xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> = `true`.</span></span> <span data-ttu-id="01340-188"><xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> = `false`.</span><span class="sxs-lookup"><span data-stu-id="01340-188"><xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> = `false`.</span></span> <span data-ttu-id="01340-189">這種情況下對應至<xref:System.Data.Linq.DataContext>，可讓使用者使用載入的物件圖形<xref:System.Data.Linq.DataLoadOptions.LoadWith%2A>指示詞，但它不會啟用延後的載入。</span><span class="sxs-lookup"><span data-stu-id="01340-189">This situation corresponds to a <xref:System.Data.Linq.DataContext> that allows users to load an object graph by using <xref:System.Data.Linq.DataLoadOptions.LoadWith%2A> directives, but it does not enable deferred loading.</span></span>  
  
-   <span data-ttu-id="01340-190">都設為`true`。</span><span class="sxs-lookup"><span data-stu-id="01340-190">Both are set to `true`.</span></span> <span data-ttu-id="01340-191">這是預設值。</span><span class="sxs-lookup"><span data-stu-id="01340-191">This is the default.</span></span>  
  
 <span data-ttu-id="01340-192">在執行查詢之後，可能不會變更旗標。</span><span class="sxs-lookup"><span data-stu-id="01340-192">The flags may not be changed after a query has been executed.</span></span> <span data-ttu-id="01340-193">使用的第一個查詢執行之後的任何變更<xref:System.Data.Linq.DataContext>會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="01340-193">Any change after the execution of the first query that uses that <xref:System.Data.Linq.DataContext> throws an exception.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteDatabase">
      <MemberSignature Language="C#" Value="public void DeleteDatabase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteDatabase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.DeleteDatabase" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteDatabase ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteDatabase();" />
      <MemberSignature Language="F#" Value="member this.DeleteDatabase : unit -&gt; unit" Usage="dataContext.DeleteDatabase " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="01340-194">刪除關聯的資料庫。</span><span class="sxs-lookup"><span data-stu-id="01340-194">Deletes the associated database.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01340-195">這個方法會使用中的連接<xref:System.Data.Linq.DataContext.Connection%2A>屬性來識別要刪除的資料庫。</span><span class="sxs-lookup"><span data-stu-id="01340-195">This method uses the connection in the <xref:System.Data.Linq.DataContext.Connection%2A> property to identify the database to be deleted.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="01340-196">下列範例示範如何刪除已暫時建立的資料庫。</span><span class="sxs-lookup"><span data-stu-id="01340-196">The following example shows how to delete a database that has been temporarily created.</span></span>  
  
 [!code-csharp[System.Data.Linq.DataContext#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.DataContext/cs/Program.cs#1)]
 [!code-vb[System.Data.Linq.DataContext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.DataContext/vb/Module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.Linq.DataContext.Dispose" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="01340-197">釋放 <see cref="T:System.Data.Linq.DataContext" /> 類別所使用的資源。</span><span class="sxs-lookup"><span data-stu-id="01340-197">Releases the resources used by the <see cref="T:System.Data.Linq.DataContext" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="dataContext.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="01340-198">釋放 <see cref="T:System.Data.Linq.DataContext" /> 類別目前的執行個體所使用的全部資源。</span><span class="sxs-lookup"><span data-stu-id="01340-198">Releases all resources used by the current instance of the <see cref="T:System.Data.Linq.DataContext" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="dataContext.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="01340-199"><see langword="true" /> 表示會同時釋放 Managed 和 Unmanaged 資源，<see langword="false" /> 則表示只釋放 Unmanaged 資源。</span><span class="sxs-lookup"><span data-stu-id="01340-199"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="01340-200">釋放 <see cref="T:System.Data.Linq.DataContext" /> 類別所使用的 Unmanaged 資源，並選擇性地釋放 Managed 資源。</span><span class="sxs-lookup"><span data-stu-id="01340-200">Releases the unmanaged resources used by the <see cref="T:System.Data.Linq.DataContext" /> class and optionally releases the managed resource.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteCommand">
      <MemberSignature Language="C#" Value="public int ExecuteCommand (string command, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteCommand(string command, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteCommand (command As String, ParamArray parameters As Object()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteCommand(System::String ^ command, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteCommand : string * obj[] -&gt; int" Usage="dataContext.ExecuteCommand (command, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="command"><span data-ttu-id="01340-201">要執行的 SQL 命令。</span><span class="sxs-lookup"><span data-stu-id="01340-201">The SQL command to be executed.</span></span></param>
        <param name="parameters"><span data-ttu-id="01340-202">要傳遞至命令的參數陣列。</span><span class="sxs-lookup"><span data-stu-id="01340-202">The array of parameters to be passed to the command.</span></span> <span data-ttu-id="01340-203">請注意下列情況：</span><span class="sxs-lookup"><span data-stu-id="01340-203">Note the following behavior:</span></span> 
<span data-ttu-id="01340-204">如果陣列中的物件數目少於命令字串中所識別的最高數目，便會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="01340-204">If the number of objects in the array is less than the highest number identified in the command string, an exception is thrown.</span></span>  
  
<span data-ttu-id="01340-205">如果陣列包含命令字串中未參考的物件，則不會擲回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="01340-205">If the array contains objects that are not referenced in the command string, no exception is thrown.</span></span>  
  
<span data-ttu-id="01340-206">如果有任一參數為 null，則會轉換成 <see langword="DBNull.Value" />。</span><span class="sxs-lookup"><span data-stu-id="01340-206">If any one of the parameters is null, it is converted to <see langword="DBNull.Value" />.</span></span></param>
        <summary><span data-ttu-id="01340-207">直接在資料庫上執行 SQL 命令。</span><span class="sxs-lookup"><span data-stu-id="01340-207">Executes SQL commands directly on the database.</span></span></summary>
        <returns><span data-ttu-id="01340-208">已執行的命令所修改的資料列數。</span><span class="sxs-lookup"><span data-stu-id="01340-208">The number of rows modified by the executed command.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01340-209">這個方法是案例的傳遞機制其中[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]不是適當地提供特定的案例。</span><span class="sxs-lookup"><span data-stu-id="01340-209">This method is a pass-through mechanism for cases where [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] does not adequately provide for a particular scenario.</span></span>  
  
 <span data-ttu-id="01340-210">此命令的語法是用來建立 ADO.NET 語法幾乎相同`DataCommand`。</span><span class="sxs-lookup"><span data-stu-id="01340-210">The syntax for the command is almost the same as the syntax used to create an ADO.NET `DataCommand`.</span></span> <span data-ttu-id="01340-211">唯一的差別是在參數指定的方式。</span><span class="sxs-lookup"><span data-stu-id="01340-211">The only difference is in how the parameters are specified.</span></span> <span data-ttu-id="01340-212">具體來說，它們以大括號 （{...}） 括住來指定參數，並列舉它們從 0 開始。</span><span class="sxs-lookup"><span data-stu-id="01340-212">Specifically, you specify parameters by enclosing them in braces ({…}) and enumerate them starting from 0.</span></span> <span data-ttu-id="01340-213">參數陣列中的編號相等物件相關聯的參數。</span><span class="sxs-lookup"><span data-stu-id="01340-213">The parameter is associated with the equally numbered object in the parameters array.</span></span>  
  
 <span data-ttu-id="01340-214">`ExecuteQuery` 和`ExecuteCommand`可讓您指定的參數替換引數數目可變。</span><span class="sxs-lookup"><span data-stu-id="01340-214">`ExecuteQuery` and `ExecuteCommand` allow you to specify a variable number of arguments for parameter substitution.</span></span> <span data-ttu-id="01340-215">例如，您可以指定參數時叫用 ExecuteQuery\<TResult >:</span><span class="sxs-lookup"><span data-stu-id="01340-215">For example, you can specify the parameters when invoking ExecuteQuery\<TResult>:</span></span>  
  
```  
db.ExecuteQuery<Customer>("select * from dbo.Customers where City = {0}", "London");  
```  
  
 <span data-ttu-id="01340-216">和另一個範例：</span><span class="sxs-lookup"><span data-stu-id="01340-216">And, another example:</span></span>  
  
```  
db.ExecuteCommand("UPDATE Products SET QuantityPerUnit = {0} WHERE ProductID = {1}", "24 boxes", 5);  
```  
  
 <span data-ttu-id="01340-217">下列範例會開啟的連接，並將傳遞 SQL`UPDATE`命令至 SQL 引擎。</span><span class="sxs-lookup"><span data-stu-id="01340-217">The following example opens a connection and passes a SQL `UPDATE` command to the SQL engine.</span></span>  
  
   
  
## Examples  
 [!code-csharp[DLinqCommunicatingWithDatabase#3](~/samples/snippets/csharp/VS_Snippets_Data/DLinqCommunicatingWithDatabase/cs/Program.cs#3)]
 [!code-vb[DLinqCommunicatingWithDatabase#3](~/samples/snippets/visualbasic/VS_Snippets_Data/DLinqCommunicatingWithDatabase/vb/Module1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteDynamicDelete">
      <MemberSignature Language="C#" Value="protected internal void ExecuteDynamicDelete (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void ExecuteDynamicDelete(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteDynamicDelete(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub ExecuteDynamicDelete (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void ExecuteDynamicDelete(System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.ExecuteDynamicDelete : obj -&gt; unit" Usage="dataContext.ExecuteDynamicDelete entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity"><span data-ttu-id="01340-218">要刪除的實體。</span><span class="sxs-lookup"><span data-stu-id="01340-218">The entity to be deleted.</span></span></param>
        <summary><span data-ttu-id="01340-219">在刪除覆寫方法內執行，以將刪除作業所需的動態 SQL 產生與執行工作重新委派給 [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="01340-219">Executes, inside delete override methods, to redelegate to [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] the task of generating and executing dynamic SQL for delete operations.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01340-220">請參閱 <xref:System.Data.Linq.DataContext.ExecuteDynamicInsert%2A>。</span><span class="sxs-lookup"><span data-stu-id="01340-220">See <xref:System.Data.Linq.DataContext.ExecuteDynamicInsert%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteDynamicInsert">
      <MemberSignature Language="C#" Value="protected internal void ExecuteDynamicInsert (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void ExecuteDynamicInsert(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub ExecuteDynamicInsert (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void ExecuteDynamicInsert(System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.ExecuteDynamicInsert : obj -&gt; unit" Usage="dataContext.ExecuteDynamicInsert entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity"><span data-ttu-id="01340-221">要插入的實體。</span><span class="sxs-lookup"><span data-stu-id="01340-221">The entity to be inserted.</span></span></param>
        <summary><span data-ttu-id="01340-222">在插入覆寫方法內執行，以將插入作業所需的動態 SQL 產生與執行工作重新委派給 [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="01340-222">Executes, inside insert override methods, to redelegate to [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] the task of generating and executing dynamic SQL for insert operations.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01340-223">請注意下列考量：</span><span class="sxs-lookup"><span data-stu-id="01340-223">Note the following considerations:</span></span>  
  
-   <span data-ttu-id="01340-224">其使用方法具有受保護的修飾詞，因為需要子類別化<xref:System.Data.Linq.DataContext>。</span><span class="sxs-lookup"><span data-stu-id="01340-224">Because the method has a protected modifier, its use requires subclassing <xref:System.Data.Linq.DataContext>.</span></span>  
  
-   <span data-ttu-id="01340-225">如果這項作業不會呼叫內，會擲回例外狀況<xref:System.Data.Linq.DataContext.SubmitChanges%2A>作業。</span><span class="sxs-lookup"><span data-stu-id="01340-225">An exception is thrown if this operation is not called inside a <xref:System.Data.Linq.DataContext.SubmitChanges%2A> operation.</span></span> <span data-ttu-id="01340-226">它不要當做獨立的作業的範圍外呼叫<xref:System.Data.Linq.DataContext.SubmitChanges%2A>作業。</span><span class="sxs-lookup"><span data-stu-id="01340-226">It is not intended to be called as a stand-alone operation outside the scope of a <xref:System.Data.Linq.DataContext.SubmitChanges%2A> operation.</span></span> <span data-ttu-id="01340-227"><xref:System.Data.Linq.DataContext.SubmitChanges%2A> 本身呼叫覆寫方法如果它們在實作和先前的方法要覆寫方法內呼叫。</span><span class="sxs-lookup"><span data-stu-id="01340-227"><xref:System.Data.Linq.DataContext.SubmitChanges%2A> itself calls override methods if they are implemented and the previous methods are intended to be called inside the override methods.</span></span>  
  
-   <span data-ttu-id="01340-228">它是以傳入正確的實體開發人員的責任。</span><span class="sxs-lookup"><span data-stu-id="01340-228">It is the responsibility of the developer to pass in the correct entity.</span></span> <span data-ttu-id="01340-229">實作會驗證傳入的實體會追蹤。</span><span class="sxs-lookup"><span data-stu-id="01340-229">The implementation verifies that the passed-in entity is tracked.</span></span> <span data-ttu-id="01340-230">不過，它會維護訊息順序，或在相同實體中傳遞兩次，開發人員的責任。</span><span class="sxs-lookup"><span data-stu-id="01340-230">However, it is the responsibility of the developer to maintain the order or pass in the same entity two times.</span></span>  
  
-   <span data-ttu-id="01340-231">它是叫用正確的動態 API 的開發人員的責任。</span><span class="sxs-lookup"><span data-stu-id="01340-231">It is the responsibility of the developer to invoke the correct dynamic API.</span></span> <span data-ttu-id="01340-232">例如，在`Update`覆寫方法，只能<xref:System.Data.Linq.DataContext.ExecuteDynamicUpdate%2A>可以呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="01340-232">For example, in the `Update` override method, only the <xref:System.Data.Linq.DataContext.ExecuteDynamicUpdate%2A> method can be called.</span></span> [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] <span data-ttu-id="01340-233">並不會偵測或驗證所叫用的動態方法是否符合適用的作業。</span><span class="sxs-lookup"><span data-stu-id="01340-233">does not detect or verify whether the invoked dynamic method matches the applicable operation.</span></span> <span data-ttu-id="01340-234">如果不適用的方法呼叫，結果便未定義 (例如，呼叫<xref:System.Data.Linq.DataContext.ExecuteDynamicDelete%2A>更新物件)。</span><span class="sxs-lookup"><span data-stu-id="01340-234">The results are undefined if an inapplicable method is called (for example, calling <xref:System.Data.Linq.DataContext.ExecuteDynamicDelete%2A> for an object to be updated).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteDynamicUpdate">
      <MemberSignature Language="C#" Value="protected internal void ExecuteDynamicUpdate (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void ExecuteDynamicUpdate(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteDynamicUpdate(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub ExecuteDynamicUpdate (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void ExecuteDynamicUpdate(System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.ExecuteDynamicUpdate : obj -&gt; unit" Usage="dataContext.ExecuteDynamicUpdate entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity"><span data-ttu-id="01340-235">要更新的實體。</span><span class="sxs-lookup"><span data-stu-id="01340-235">The entity to be updated.</span></span></param>
        <summary><span data-ttu-id="01340-236">在更新覆寫方法內執行，以將更新作業所需的動態 SQL 產生與執行工作重新委派給 [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="01340-236">Executes, inside update override methods, to redelegate to [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] the task of generating and executing dynamic SQL for update operations.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01340-237">請參閱 <xref:System.Data.Linq.DataContext.ExecuteDynamicInsert%2A>。</span><span class="sxs-lookup"><span data-stu-id="01340-237">See <xref:System.Data.Linq.DataContext.ExecuteDynamicInsert%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteMethodCall">
      <MemberSignature Language="C#" Value="protected System.Data.Linq.IExecuteResult ExecuteMethodCall (object instance, System.Reflection.MethodInfo methodInfo, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Data.Linq.IExecuteResult ExecuteMethodCall(object instance, class System.Reflection.MethodInfo methodInfo, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteMethodCall(System.Object,System.Reflection.MethodInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Data::Linq::IExecuteResult ^ ExecuteMethodCall(System::Object ^ instance, System::Reflection::MethodInfo ^ methodInfo, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteMethodCall : obj * System.Reflection.MethodInfo * obj[] -&gt; System.Data.Linq.IExecuteResult" Usage="dataContext.ExecuteMethodCall (instance, methodInfo, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.IExecuteResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
        <Parameter Name="methodInfo" Type="System.Reflection.MethodInfo" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="01340-238">方法引動過程的執行個體 (目前物件)。</span><span class="sxs-lookup"><span data-stu-id="01340-238">The instance of the method invocation (the current object).</span></span></param>
        <param name="methodInfo"><span data-ttu-id="01340-239">指出對應到資料庫方法的 .NET 方法。</span><span class="sxs-lookup"><span data-stu-id="01340-239">Identifies the .NET method that corresponds to a database method.</span></span></param>
        <param name="parameters"><span data-ttu-id="01340-240">要傳遞至命令的參數陣列。</span><span class="sxs-lookup"><span data-stu-id="01340-240">The array of parameters to be passed to the command.</span></span></param>
        <summary><span data-ttu-id="01340-241">執行與指定之 .NET 方法關聯的預存資料庫程序或純量函式。</span><span class="sxs-lookup"><span data-stu-id="01340-241">Executes the stored database procedure or scalar function associated with the specified .NET method.</span></span></summary>
        <returns><span data-ttu-id="01340-242">執行指定之方法的結果 (傳回值和輸出參數)。</span><span class="sxs-lookup"><span data-stu-id="01340-242">The result (the return value and output parameters) of executing the specified method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01340-243"><xref:System.Data.Linq.DataContext.ExecuteMethodCall%2A>方法用於自動產生的程式碼，並做為資料庫函式的 proxy。</span><span class="sxs-lookup"><span data-stu-id="01340-243">The <xref:System.Data.Linq.DataContext.ExecuteMethodCall%2A> method is used in automatically generated code and acts as a proxy to database functions.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteQuery">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerable ExecuteQuery (Type elementType, string query, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.IEnumerable ExecuteQuery(class System.Type elementType, string query, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteQuery (elementType As Type, query As String, ParamArray parameters As Object()) As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::IEnumerable ^ ExecuteQuery(Type ^ elementType, System::String ^ query, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteQuery : Type * string * obj[] -&gt; System.Collections.IEnumerable" Usage="dataContext.ExecuteQuery (elementType, query, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="query" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType"><span data-ttu-id="01340-244">要傳回的 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 型別。</span><span class="sxs-lookup"><span data-stu-id="01340-244">The type of the <see cref="T:System.Collections.Generic.IEnumerable`1" /> to be returned.</span></span>  
  
<span data-ttu-id="01340-245">查詢結果中的資料行與物件中的欄位或屬性相符合的演算法用法如下：</span><span class="sxs-lookup"><span data-stu-id="01340-245">The algorithm for matching columns in the result of the query to fields or properties in the object works as follows:</span></span> 
<span data-ttu-id="01340-246">如果欄位或屬性已對應至特定資料行名稱，結果集 (Resultset) 必須包含該資料行名稱。</span><span class="sxs-lookup"><span data-stu-id="01340-246">If a field or property is mapped to a particular column name, that column name is expected in the resultset.</span></span>  
  
<span data-ttu-id="01340-247">如果欄位或屬性未對應，結果集必須包含與該欄位或屬性同名的資料行。</span><span class="sxs-lookup"><span data-stu-id="01340-247">If a field or property is not mapped, a column with the same name as the field or property is expected in the resultset.</span></span>  
  
<span data-ttu-id="01340-248">尋找區分大小寫的相符項時會先進行比較。</span><span class="sxs-lookup"><span data-stu-id="01340-248">The comparison is performed by looking for a case-sensitive match first.</span></span> <span data-ttu-id="01340-249">如果找不到這種相符項，就會繼續搜尋不區分大小寫的相符項。</span><span class="sxs-lookup"><span data-stu-id="01340-249">If this match is not found, a subsequent search occurs for a case-insensitive match.</span></span>  
  
<span data-ttu-id="01340-250">當下列所有條件皆為 true 時，查詢必須傳回該物件所有追蹤的欄位和屬性 (會延後載入的欄位和屬性除外)：</span><span class="sxs-lookup"><span data-stu-id="01340-250">The query must return all the tracked fields and properties of the object (except those that are loaded on a deferred basis) when all the following conditions are true:</span></span> 
 <span data-ttu-id="01340-251"><c>T</c> 是 <see cref="T:System.Data.Linq.DataContext" /> 明確追蹤的實體。</span><span class="sxs-lookup"><span data-stu-id="01340-251"><c>T</c> is an entity explicitly tracked by the <see cref="T:System.Data.Linq.DataContext" />.</span></span>  
  
 <span data-ttu-id="01340-252"><see cref="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" /> 為 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="01340-252"><see cref="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" /> is <see langword="true" />.</span></span>  
  
<span data-ttu-id="01340-253">這個實體具有主索引鍵。</span><span class="sxs-lookup"><span data-stu-id="01340-253">The entity has a primary key.</span></span>  
  
<span data-ttu-id="01340-254">否則，會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="01340-254">Otherwise an exception is thrown.</span></span></param>
        <param name="query"><span data-ttu-id="01340-255">要執行的 SQL 查詢。</span><span class="sxs-lookup"><span data-stu-id="01340-255">The SQL query to be executed.</span></span></param>
        <param name="parameters"><span data-ttu-id="01340-256">要傳遞至命令的參數陣列。</span><span class="sxs-lookup"><span data-stu-id="01340-256">The array of parameters to be passed to the command.</span></span> <span data-ttu-id="01340-257">請注意下列情況：</span><span class="sxs-lookup"><span data-stu-id="01340-257">Note the following behavior:</span></span> 
<span data-ttu-id="01340-258">如果陣列中的物件數目少於命令字串中所識別的最高數目，便會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="01340-258">If the number of objects in the array is less than the highest number identified in the command string, an exception is thrown.</span></span>  
  
<span data-ttu-id="01340-259">如果陣列包含命令字串中未參考的物件，則不會擲回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="01340-259">If the array contains objects that are not referenced in the command string, no exception is thrown.</span></span>  
  
<span data-ttu-id="01340-260">如果參數為 <see langword="null" />，則會轉換成 <see langword="DBNull.Value" />。</span><span class="sxs-lookup"><span data-stu-id="01340-260">If a parameter is <see langword="null" />, it is converted to <see langword="DBNull.Value" />.</span></span></param>
        <summary><span data-ttu-id="01340-261">直接在資料庫上執行 SQL 查詢。</span><span class="sxs-lookup"><span data-stu-id="01340-261">Executes SQL queries directly on the database.</span></span></summary>
        <returns><span data-ttu-id="01340-262">物件的 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 集合，由查詢傳回。</span><span class="sxs-lookup"><span data-stu-id="01340-262">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> collection of objects returned by the query.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteQuery&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;TResult&gt; ExecuteQuery&lt;TResult&gt; (string query, params object[] parameters) where TResult : new();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; ExecuteQuery&lt;.ctor TResult&gt;(string query, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteQuery(Of TResult As New) (query As String, ParamArray parameters As Object()) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; where TResult : gcnew() System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ ExecuteQuery(System::String ^ query, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteQuery : string * obj[] -&gt; seq&lt;'Result (requires 'Result : (new : unit -&gt; 'Result))&gt; (requires 'Result : (new : unit -&gt; 'Result))" Usage="dataContext.ExecuteQuery (query, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="query" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="01340-263">所傳回集合中項目的型別。</span><span class="sxs-lookup"><span data-stu-id="01340-263">The type of the elements in the returned collection.</span></span></typeparam>
        <param name="query"><span data-ttu-id="01340-264">要執行的 SQL 查詢。</span><span class="sxs-lookup"><span data-stu-id="01340-264">The SQL query to be executed.</span></span></param>
        <param name="parameters"><span data-ttu-id="01340-265">要傳遞至命令的參數陣列。</span><span class="sxs-lookup"><span data-stu-id="01340-265">The array of parameters to be passed to the command.</span></span> <span data-ttu-id="01340-266">請注意下列情況：</span><span class="sxs-lookup"><span data-stu-id="01340-266">Note the following behavior:</span></span> 
<span data-ttu-id="01340-267">如果陣列中的物件數目少於命令字串中所識別的最高數目，便會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="01340-267">If the number of objects in the array is less than the highest number identified in the command string, an exception is thrown.</span></span>  
  
<span data-ttu-id="01340-268">如果陣列包含命令字串中未參考的物件，則不會擲回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="01340-268">If the array contains objects that are not referenced in the command string, no exception is thrown.</span></span>  
  
<span data-ttu-id="01340-269">如果參數為 null，則會轉換成 <see langword="DBNull.Value" />。</span><span class="sxs-lookup"><span data-stu-id="01340-269">If a parameter is null, it is converted to <see langword="DBNull.Value" />.</span></span></param>
        <summary><span data-ttu-id="01340-270">直接在資料庫上執行 SQL 查詢，並傳回物件。</span><span class="sxs-lookup"><span data-stu-id="01340-270">Executes SQL queries directly on the database and returns objects.</span></span></summary>
        <returns><span data-ttu-id="01340-271">查詢所傳回物件的集合。</span><span class="sxs-lookup"><span data-stu-id="01340-271">A collection of objects returned by the query.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01340-272">這個方法是案例的傳遞機制其中[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]不提供特定的案例。</span><span class="sxs-lookup"><span data-stu-id="01340-272">This method is a pass-through mechanism for cases where [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] does not provide for a particular scenario.</span></span>  
  
 <span data-ttu-id="01340-273">欄位的查詢結果中相符的資料行和屬性之物件中的演算法的運作方式，如下所示：</span><span class="sxs-lookup"><span data-stu-id="01340-273">The algorithm for matching columns in the result of the query to fields and properties in the object works as follows:</span></span>  
  
-   <span data-ttu-id="01340-274">如果欄位或屬性已對應至特定資料行名稱，結果集 (Resultset) 必須包含該資料行名稱。</span><span class="sxs-lookup"><span data-stu-id="01340-274">If a field or property is mapped to a particular column name, that column name is expected in the resultset.</span></span>  
  
-   <span data-ttu-id="01340-275">如果欄位或屬性未對應，結果集必須包含與該欄位或屬性同名的資料行。</span><span class="sxs-lookup"><span data-stu-id="01340-275">If a field or property is not mapped, a column with the same name as the field or property is expected in the resultset.</span></span>  
  
-   <span data-ttu-id="01340-276">執行比較的第一次尋找區分大小寫的相符項目。</span><span class="sxs-lookup"><span data-stu-id="01340-276">The comparison is performed by first looking for a case-sensitive match.</span></span> <span data-ttu-id="01340-277">如果找不到這類相符項目，不區分大小寫的相符項目就會繼續搜尋。</span><span class="sxs-lookup"><span data-stu-id="01340-277">If such a match is not found, a subsequent search occurs for a case-insensitive match.</span></span>  
  
-   <span data-ttu-id="01340-278">此查詢必須傳回所有追蹤的欄位和屬性的物件 （除了那些可能延後載入） 當所有下列都條件成立：</span><span class="sxs-lookup"><span data-stu-id="01340-278">The query must return all the tracked fields and properties of the object (apart from those subject to deferred loading) when all the following are true:</span></span>  
  
    -   <span data-ttu-id="01340-279">如果`<T>`實體所明確追蹤<xref:System.Data.Linq.DataContext>。</span><span class="sxs-lookup"><span data-stu-id="01340-279">If `<T>` is an entity explicitly tracked by the <xref:System.Data.Linq.DataContext>.</span></span>  
  
    -   <span data-ttu-id="01340-280">ObjectTrackingEnabled 為 true。</span><span class="sxs-lookup"><span data-stu-id="01340-280">ObjectTrackingEnabled is true.</span></span>  
  
    -   <span data-ttu-id="01340-281">這個實體具有主索引鍵。</span><span class="sxs-lookup"><span data-stu-id="01340-281">The entity has a primary key.</span></span>  
  
     <span data-ttu-id="01340-282">否則，會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="01340-282">Otherwise an exception is thrown.</span></span>  
  
-   <span data-ttu-id="01340-283">在其他情況下，查詢可以擷取的追蹤的欄位和物件的屬性部分。</span><span class="sxs-lookup"><span data-stu-id="01340-283">In all other cases, the query can retrieve just a subset of the tracked fields and properties for the object.</span></span>  
  
 <span data-ttu-id="01340-284">下列 C# 程式碼片段示範此方法的其中一種用法：</span><span class="sxs-lookup"><span data-stu-id="01340-284">The following C# snippet shows one use for this method:</span></span>  
  
```  
var customers = db.ExecuteQuery<Customer>(@"SELECT CustomerID, CompanyName, ContactName, ContactTitle,   
   Address, City, Region, PostalCode, Country, Phone, Fax  
   FROM   dbo.Customers  
   WHERE  City = {0}", "London");  
  
foreach (Customer c in customers)  
   Console.WriteLine(c.ContactName);  
```  
  
 <span data-ttu-id="01340-285">在 Visual Basic</span><span class="sxs-lookup"><span data-stu-id="01340-285">In Visual Basic</span></span>  
  
```  
Dim customers = db.ExecuteQuery(Of Customer)("SELECT CustomerID, _    CompanyName, ContactName, ContactTitle, _  
   Address, City, Region, PostalCode, Country, Phone, Fax _  
   FROM dbo.Customers _  
WHERE City = {0}", "London")  
  
For Each c As Customer In customers  
    Console.WriteLine(c.ContactName)  
Next  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChangeSet">
      <MemberSignature Language="C#" Value="public System.Data.Linq.ChangeSet GetChangeSet ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Linq.ChangeSet GetChangeSet() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetChangeSet" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChangeSet () As ChangeSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Linq::ChangeSet ^ GetChangeSet();" />
      <MemberSignature Language="F#" Value="member this.GetChangeSet : unit -&gt; System.Data.Linq.ChangeSet" Usage="dataContext.GetChangeSet " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.ChangeSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="01340-286">取得 <see cref="T:System.Data.Linq.DataContext" /> 所追蹤的已修改物件。</span><span class="sxs-lookup"><span data-stu-id="01340-286">Gets the modified objects tracked by <see cref="T:System.Data.Linq.DataContext" />.</span></span></summary>
        <returns><span data-ttu-id="01340-287">這組物件是以三個唯讀集合傳回。</span><span class="sxs-lookup"><span data-stu-id="01340-287">The set of objects is returned as three read-only collections.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01340-288">請注意下列考量：</span><span class="sxs-lookup"><span data-stu-id="01340-288">Note the following considerations:</span></span>  
  
-   <span data-ttu-id="01340-289"><xref:System.Data.Linq.DataContext.GetChangeSet%2A> 可能有副作用，例如 推斷的插入和刪除作業，通常會執行當時的<xref:System.Data.Linq.DataContext.SubmitChanges%2A>。</span><span class="sxs-lookup"><span data-stu-id="01340-289"><xref:System.Data.Linq.DataContext.GetChangeSet%2A> might have side effects, such as inference of insert and delete operations that are usually performed at the time of <xref:System.Data.Linq.DataContext.SubmitChanges%2A>.</span></span> <span data-ttu-id="01340-290">比方說，下列作業中使用的物件可以建立下列清單中的推斷的對應作業：</span><span class="sxs-lookup"><span data-stu-id="01340-290">For example, objects that are used in the following operations can create corresponding inferred operations in the following list:</span></span>  
  
    -   <span data-ttu-id="01340-291"><xref:System.Data.Linq.EntitySet%601.Add%2A> 若要<xref:System.Data.Linq.Table%601.InsertOnSubmit%2A>。</span><span class="sxs-lookup"><span data-stu-id="01340-291"><xref:System.Data.Linq.EntitySet%601.Add%2A> to <xref:System.Data.Linq.Table%601.InsertOnSubmit%2A>.</span></span>  
  
    -   <span data-ttu-id="01340-292"><xref:System.Data.Linq.EntityRef%601> 將 null 指派 (可能是因為的<xref:System.Data.Linq.EntitySet%601.Remove%2A>至<xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A>。</span><span class="sxs-lookup"><span data-stu-id="01340-292"><xref:System.Data.Linq.EntityRef%601> assignment to null (possibly because of <xref:System.Data.Linq.EntitySet%601.Remove%2A> to <xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A>.</span></span>  
  
-   <span data-ttu-id="01340-293">根據外部索引鍵條件約束時，可能無法排序集合。</span><span class="sxs-lookup"><span data-stu-id="01340-293">The set may not be ordered according to foreign key constraints.</span></span>  
  
-   <span data-ttu-id="01340-294">無法使用資料庫產生的值 （例如，主要與外部索引鍵值、 時間戳記，等等）。</span><span class="sxs-lookup"><span data-stu-id="01340-294">Database-generated values (for example, primary and foreign key values, timestamps, and so forth) are not available.</span></span> <span data-ttu-id="01340-295">這類資訊需要執行資料庫命令以及或許散佈擷取的資訊 （例如，主索引鍵的外部索引鍵）。</span><span class="sxs-lookup"><span data-stu-id="01340-295">Such information requires database command execution and perhaps the propagation of retrieved information (for example, foreign key from primary key).</span></span>  
  
-   <span data-ttu-id="01340-296">在呼叫時計算一組已變更的物件。</span><span class="sxs-lookup"><span data-stu-id="01340-296">The set of changed objects is computed at the time of the call.</span></span> <span data-ttu-id="01340-297">後續呼叫<xref:System.Data.Linq.DataContext.SubmitChanges%2A>可以產生一組不同，如果進行其他變更。</span><span class="sxs-lookup"><span data-stu-id="01340-297">Subsequent calls to <xref:System.Data.Linq.DataContext.SubmitChanges%2A> can produce a different set if additional changes are made.</span></span>  
  
 <span data-ttu-id="01340-298">當有任何變更時的輸出看起來像這樣：</span><span class="sxs-lookup"><span data-stu-id="01340-298">Output when no changes have been made appears as follows:</span></span>  
  
 `{Added: 0, Removed: 0, Modified: 0}`  
  
   
  
## Examples  
 [!code-csharp[DLinqDebuggingSupport#2](~/samples/snippets/csharp/VS_Snippets_Data/DLinqDebuggingSupport/cs/Program.cs#2)]
 [!code-vb[DLinqDebuggingSupport#2](~/samples/snippets/visualbasic/VS_Snippets_Data/DLinqDebuggingSupport/vb/Module1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCommand">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbCommand GetCommand (System.Linq.IQueryable query);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Common.DbCommand GetCommand(class System.Linq.IQueryable query) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetCommand(System.Linq.IQueryable)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCommand (query As IQueryable) As DbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Common::DbCommand ^ GetCommand(System::Linq::IQueryable ^ query);" />
      <MemberSignature Language="F#" Value="member this.GetCommand : System.Linq.IQueryable -&gt; System.Data.Common.DbCommand" Usage="dataContext.GetCommand query" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbCommand</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="System.Linq.IQueryable" />
      </Parameters>
      <Docs>
        <param name="query"><span data-ttu-id="01340-299">會擷取內含 SQL 命令資訊的查詢。</span><span class="sxs-lookup"><span data-stu-id="01340-299">The query whose SQL command information is to be retrieved.</span></span></param>
        <summary><span data-ttu-id="01340-300">取得由 [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] 產生之有關 SQL 命令的資訊。</span><span class="sxs-lookup"><span data-stu-id="01340-300">Gets the information about SQL commands generated by [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)].</span></span></summary>
        <returns><span data-ttu-id="01340-301">要求的命令資訊物件。</span><span class="sxs-lookup"><span data-stu-id="01340-301">The requested command information object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01340-302">這個方法是只 getter，而且不會影響<xref:System.Data.Linq.DataContext>狀態。</span><span class="sxs-lookup"><span data-stu-id="01340-302">This method is only a getter and does not affect <xref:System.Data.Linq.DataContext> state.</span></span>  
  
 <span data-ttu-id="01340-303">請注意下列考量：</span><span class="sxs-lookup"><span data-stu-id="01340-303">Note the following considerations:</span></span>  
  
-   <span data-ttu-id="01340-304">引數必須為非 null。</span><span class="sxs-lookup"><span data-stu-id="01340-304">The argument must be non-null.</span></span> <span data-ttu-id="01340-305">否則，會擲回 null 引數例外狀況。</span><span class="sxs-lookup"><span data-stu-id="01340-305">Otherwise, a null argument exception is thrown.</span></span>  
  
-   <span data-ttu-id="01340-306">一般查詢期間擲回的轉譯例外狀況[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]查詢執行適用於無法轉譯的查詢。</span><span class="sxs-lookup"><span data-stu-id="01340-306">Normal query translation exceptions thrown during [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] query execution apply for a query that cannot be translated.</span></span>  
  
-   <span data-ttu-id="01340-307">會傳回第一個查詢命令。</span><span class="sxs-lookup"><span data-stu-id="01340-307">Only the first query command is returned.</span></span> <span data-ttu-id="01340-308">具體而言，其他命令，用於積極式載入 (<xref:System.Data.Linq.DataLoadOptions.LoadWith%2A>) 不會包含。</span><span class="sxs-lookup"><span data-stu-id="01340-308">Specifically, additional commands that are used for eager loading (<xref:System.Data.Linq.DataLoadOptions.LoadWith%2A>) are not included.</span></span>  
  
-   <span data-ttu-id="01340-309"><xref:System.Data.Linq.DataContext> 不會追蹤使用者沒有使用命令。</span><span class="sxs-lookup"><span data-stu-id="01340-309"><xref:System.Data.Linq.DataContext> does not track what the user does with the command.</span></span> <span data-ttu-id="01340-310">比方說，不會追蹤傳回命令執行的結果，而不會影響<xref:System.Data.Linq.DataContext>狀態。</span><span class="sxs-lookup"><span data-stu-id="01340-310">For example, results from the execution of the returned command are not tracked and do not affect <xref:System.Data.Linq.DataContext> state.</span></span>  
  
   
  
## Examples  
 [!code-csharp[DLinqDebuggingSupport#3](~/samples/snippets/csharp/VS_Snippets_Data/DLinqDebuggingSupport/cs/Program.cs#3)]
 [!code-vb[DLinqDebuggingSupport#3](~/samples/snippets/visualbasic/VS_Snippets_Data/DLinqDebuggingSupport/vb/Module1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIDbCommand">
      <MemberSignature Language="C#" Value="public System.Data.IDbCommand GetIDbCommand (System.Linq.IQueryable query);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.IDbCommand GetIDbCommand(class System.Linq.IQueryable query) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetIDbCommand(System.Linq.IQueryable)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetIDbCommand (query As IQueryable) As IDbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::IDbCommand ^ GetIDbCommand(System::Linq::IQueryable ^ query);" />
      <MemberSignature Language="F#" Value="member this.GetIDbCommand : System.Linq.IQueryable -&gt; System.Data.IDbCommand" Usage="dataContext.GetIDbCommand query" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDbCommand</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="System.Linq.IQueryable" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="query">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTable">
      <MemberSignature Language="C#" Value="public System.Data.Linq.ITable GetTable (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Linq.ITable GetTable(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetTable(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Linq::ITable ^ GetTable(Type ^ type);" />
      <MemberSignature Language="F#" Value="member this.GetTable : Type -&gt; System.Data.Linq.ITable" Usage="dataContext.GetTable type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.ITable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="01340-311">要傳回的物件型别。</span><span class="sxs-lookup"><span data-stu-id="01340-311">The type of the objects to be returned.</span></span></param>
        <summary><span data-ttu-id="01340-312">傳回特定型別的物件集合，其中型別是由 <paramref name="type" /> 參數所定義。</span><span class="sxs-lookup"><span data-stu-id="01340-312">Returns a collection of objects of a particular type, where the type is defined by the <paramref name="type" /> parameter.</span></span></summary>
        <returns><span data-ttu-id="01340-313"><paramref name="type" /> 參數所定義物件的集合。</span><span class="sxs-lookup"><span data-stu-id="01340-313">A collection of objects defined by the <paramref name="type" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01340-314">這是弱型別的版本<xref:System.Data.Linq.DataContext.GetTable%2A>。</span><span class="sxs-lookup"><span data-stu-id="01340-314">This is a weakly typed version of <xref:System.Data.Linq.DataContext.GetTable%2A>.</span></span> <span data-ttu-id="01340-315">請務必有弱型別的版本，因為它是相當常見的做法，以動態方式建構查詢。</span><span class="sxs-lookup"><span data-stu-id="01340-315">It is important to have a weakly typed version because it is a relatively common practice to construct queries dynamically.</span></span> <span data-ttu-id="01340-316">它會強制應用程式使用反映來呼叫正確的泛型方法不方便。</span><span class="sxs-lookup"><span data-stu-id="01340-316">It would be inconvenient to force the application to use reflection to call the correct generic method.</span></span>  
  
 <span data-ttu-id="01340-317">如果沒有特定型別的集合，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="01340-317">If there is no collection for a particular type, an exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTable&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Linq.Table&lt;TEntity&gt; GetTable&lt;TEntity&gt; () where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Linq.Table`1&lt;!!TEntity&gt; GetTable&lt;class TEntity&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetTable``1" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTable(Of TEntity As Class) () As Table(Of TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; where TEntity : class System::Data::Linq::Table&lt;TEntity&gt; ^ GetTable();" />
      <MemberSignature Language="F#" Value="member this.GetTable : unit -&gt; System.Data.Linq.Table&lt;'Entity (requires 'Entity : null)&gt; (requires 'Entity : null)" Usage="dataContext.GetTable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.Table&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="TEntity"><span data-ttu-id="01340-318">要傳回的物件型别。</span><span class="sxs-lookup"><span data-stu-id="01340-318">The type of the objects to be returned.</span></span></typeparam>
        <summary><span data-ttu-id="01340-319">傳回特定型別的物件集合，其中型別是由 <paramref name="TEntity" /> 參數所定義。</span><span class="sxs-lookup"><span data-stu-id="01340-319">Returns a collection of objects of a particular type, where the type is defined by the <paramref name="TEntity" /> parameter.</span></span></summary>
        <returns><span data-ttu-id="01340-320"><paramref name="TEntity" /> 參數所定義物件的集合。</span><span class="sxs-lookup"><span data-stu-id="01340-320">A collection of objects defined by the <paramref name="TEntity" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01340-321">這個方法是查詢的主要進入點。</span><span class="sxs-lookup"><span data-stu-id="01340-321">This method is the main entry point for querying.</span></span> <span data-ttu-id="01340-322">當強型別<xref:System.Data.Linq.DataContext>建立就會出現新產生的屬性將封裝至這個方法的呼叫。</span><span class="sxs-lookup"><span data-stu-id="01340-322">When a strongly typed <xref:System.Data.Linq.DataContext> is created, new generated properties encapsulate calls to this method.</span></span> <span data-ttu-id="01340-323">例如，`Customers`屬性會產生傳回`GetTable<Customer>`。</span><span class="sxs-lookup"><span data-stu-id="01340-323">For example, a `Customers` property is generated that returns `GetTable<Customer>`.</span></span>  
  
 <span data-ttu-id="01340-324">如果沒有特定型別的集合，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="01340-324">If there is no collection for a particular type, an exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadOptions">
      <MemberSignature Language="C#" Value="public System.Data.Linq.DataLoadOptions LoadOptions { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Linq.DataLoadOptions LoadOptions" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.LoadOptions" />
      <MemberSignature Language="VB.NET" Value="Public Property LoadOptions As DataLoadOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Linq::DataLoadOptions ^ LoadOptions { System::Data::Linq::DataLoadOptions ^ get(); void set(System::Data::Linq::DataLoadOptions ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LoadOptions : System.Data.Linq.DataLoadOptions with get, set" Usage="System.Data.Linq.DataContext.LoadOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.DataLoadOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="01340-325">取得或設定與這個 <see cref="T:System.Data.Linq.DataLoadOptions" /> 關聯的 <see cref="T:System.Data.Linq.DataContext" />。</span><span class="sxs-lookup"><span data-stu-id="01340-325">Gets or sets the <see cref="T:System.Data.Linq.DataLoadOptions" /> associated with this <see cref="T:System.Data.Linq.DataContext" />.</span></span></summary>
        <value><span data-ttu-id="01340-326">相關資料的預先提取載入選項。</span><span class="sxs-lookup"><span data-stu-id="01340-326">The prefetch load options for related data.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01340-327">此屬性會取得或設定用來定義用於延後載入成員和相關的集合成員資格的預先擷取行為的選項。</span><span class="sxs-lookup"><span data-stu-id="01340-327">This property gets or sets the options that are used to define prefetch behavior for deferred-loaded members and membership of related collections.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public System.IO.TextWriter Log { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.TextWriter Log" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.Log" />
      <MemberSignature Language="VB.NET" Value="Public Property Log As TextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::TextWriter ^ Log { System::IO::TextWriter ^ get(); void set(System::IO::TextWriter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Log : System.IO.TextWriter with get, set" Usage="System.Data.Linq.DataContext.Log" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="01340-328">取得或設定寫入 SQL 查詢或命令的目的。</span><span class="sxs-lookup"><span data-stu-id="01340-328">Gets or sets the destination to write the SQL query or command.</span></span></summary>
        <value><span data-ttu-id="01340-329">要用於寫入命令的 <see cref="T:System.IO.TextReader" />。</span><span class="sxs-lookup"><span data-stu-id="01340-329">The <see cref="T:System.IO.TextReader" /> to use for writing the command.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01340-330">將此屬性設定為`null`停用命令的記錄。</span><span class="sxs-lookup"><span data-stu-id="01340-330">Set this property to `null` to disable command logging.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="01340-331">下列範例顯示在主控台視窗中產生的 SQL 之前它會顯示查詢的結果。</span><span class="sxs-lookup"><span data-stu-id="01340-331">The following example displays generated SQL in the console window before it displays the results of the query.</span></span>  
  
 [!code-csharp[System.Data.Linq.DataContext#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.DataContext/cs/Program.cs#2)]
 [!code-vb[System.Data.Linq.DataContext#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.DataContext/vb/Module1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mapping">
      <MemberSignature Language="C#" Value="public System.Data.Linq.Mapping.MetaModel Mapping { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Linq.Mapping.MetaModel Mapping" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.Mapping" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Mapping As MetaModel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Linq::Mapping::MetaModel ^ Mapping { System::Data::Linq::Mapping::MetaModel ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Mapping : System.Data.Linq.Mapping.MetaModel" Usage="System.Data.Linq.DataContext.Mapping" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.Mapping.MetaModel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="01340-332">取得做為對應之基礎的 <see cref="T:System.Data.Linq.Mapping.MetaModel" />。</span><span class="sxs-lookup"><span data-stu-id="01340-332">Gets the <see cref="T:System.Data.Linq.Mapping.MetaModel" /> on which the mapping is based.</span></span></summary>
        <value><span data-ttu-id="01340-333">資料庫和網域物件之間的對應。</span><span class="sxs-lookup"><span data-stu-id="01340-333">The mapping between a database and domain objects.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ObjectTrackingEnabled">
      <MemberSignature Language="C#" Value="public bool ObjectTrackingEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ObjectTrackingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property ObjectTrackingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ObjectTrackingEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ObjectTrackingEnabled : bool with get, set" Usage="System.Data.Linq.DataContext.ObjectTrackingEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="01340-334">取得或設定值，指出物件追蹤是否已啟用。</span><span class="sxs-lookup"><span data-stu-id="01340-334">Gets or sets a value that indicates whether object tracking is enabled.</span></span></summary>
        <value><span data-ttu-id="01340-335">如果啟用物件追蹤，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="01340-335"><see langword="true" /> if the object tracking is enabled; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="01340-336">預設為 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="01340-336">The default is <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01340-337">將此屬性設定為`false`改善在擷取時的效能，因為有較少的項目追蹤。</span><span class="sxs-lookup"><span data-stu-id="01340-337">Setting this property to `false` improves performance at retrieval time, because there are fewer items to track.</span></span>  
  
 <span data-ttu-id="01340-338">擲回例外狀況：</span><span class="sxs-lookup"><span data-stu-id="01340-338">An exception is thrown:</span></span>  
  
-   <span data-ttu-id="01340-339">如果屬性設定為`false`執行查詢之後。</span><span class="sxs-lookup"><span data-stu-id="01340-339">If the property is set to `false` after a query has been executed.</span></span>  
  
     <span data-ttu-id="01340-340">如需詳細資訊，請參閱中的有效模式 > 一節<xref:System.Data.Linq.DataContext>。</span><span class="sxs-lookup"><span data-stu-id="01340-340">For more information, see the Valid Modes section in <xref:System.Data.Linq.DataContext>.</span></span>  
  
-   <span data-ttu-id="01340-341">如果屬性設定為`false`和<xref:System.Data.Linq.DataContext.SubmitChanges%2A>呼叫。</span><span class="sxs-lookup"><span data-stu-id="01340-341">If the property is set to `false` and <xref:System.Data.Linq.DataContext.SubmitChanges%2A> is called.</span></span>  
  
 <span data-ttu-id="01340-342">如果<xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A>已`false`，<xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A>會被忽略，並將視為`false`。</span><span class="sxs-lookup"><span data-stu-id="01340-342">If <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> is `false`, <xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> is ignored and treated as `false`.</span></span> <span data-ttu-id="01340-343">在此情況下，<xref:System.Data.Linq.DataContext>處於唯讀狀態。</span><span class="sxs-lookup"><span data-stu-id="01340-343">In this case, the <xref:System.Data.Linq.DataContext> is read-only.</span></span>  
  
 <span data-ttu-id="01340-344">如果<xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A>已`true`，<xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A>是`false`。</span><span class="sxs-lookup"><span data-stu-id="01340-344">If <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> is `true`, <xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> is `false`.</span></span> <span data-ttu-id="01340-345">在此情況下，<xref:System.Data.Linq.DataContext>可讓您使用載入的物件圖形<xref:System.Data.Linq.DataLoadOptions.LoadWith%2A>指示詞，但不會啟用延後的載入。</span><span class="sxs-lookup"><span data-stu-id="01340-345">In this case, <xref:System.Data.Linq.DataContext> allows you to load an object graph by using <xref:System.Data.Linq.DataLoadOptions.LoadWith%2A> directives, but does not enable deferred loading.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryCacheEnabled">
      <MemberSignature Language="C#" Value="public bool QueryCacheEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool QueryCacheEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.QueryCacheEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property QueryCacheEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool QueryCacheEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.QueryCacheEnabled : bool with get, set" Usage="System.Data.Linq.DataContext.QueryCacheEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Refresh">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="01340-346">使用資料庫中的資料來重新整理物件狀態。</span><span class="sxs-lookup"><span data-stu-id="01340-346">Refreshes object state by using data in the database.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01340-347">要帶入另一次嘗試的狀態中的項目發生開放式並行存取錯誤之後，此方法相當實用。</span><span class="sxs-lookup"><span data-stu-id="01340-347">This method is useful after an optimistic concurrency error to bring items into a state for another attempt.</span></span> <span data-ttu-id="01340-348">它會更新的基本欄位和屬性的物件上的狀態。</span><span class="sxs-lookup"><span data-stu-id="01340-348">It updates the state of the primitive fields and properties on the objects.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="01340-349">如果物件位於*許多*一對多關聯性，物件上的外部索引鍵端將和關聯性另一端的物件指標會設定為新的值。</span><span class="sxs-lookup"><span data-stu-id="01340-349">If an object is on the *many* side of a one-to-many relationship, the foreign key on the object will be set and the object pointer for the other side of the relationship will be set to the new value.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Linq.RefreshMode mode, System.Collections.IEnumerable entities);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Linq.RefreshMode mode, class System.Collections.IEnumerable entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh (mode As RefreshMode, entities As IEnumerable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Linq::RefreshMode mode, System::Collections::IEnumerable ^ entities);" />
      <MemberSignature Language="F#" Value="member this.Refresh : System.Data.Linq.RefreshMode * System.Collections.IEnumerable -&gt; unit" Usage="dataContext.Refresh (mode, entities)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Data.Linq.RefreshMode" />
        <Parameter Name="entities" Type="System.Collections.IEnumerable" />
      </Parameters>
      <Docs>
        <param name="mode"><span data-ttu-id="01340-350">值，指定如何處理開放式並行存取 (Optimistic Concurrency) 衝突。</span><span class="sxs-lookup"><span data-stu-id="01340-350">A value that specifies how optimistic concurrency conflicts are handled.</span></span></param>
        <param name="entities"><span data-ttu-id="01340-351">要重新整理的實體集合。</span><span class="sxs-lookup"><span data-stu-id="01340-351">The collection of entities to be refreshed.</span></span></param>
        <summary><span data-ttu-id="01340-352">根據指定的模式重新整理實體物件集合。</span><span class="sxs-lookup"><span data-stu-id="01340-352">Refreshes a collection of entity objects according to the specified mode.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Linq.RefreshMode mode, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Linq.RefreshMode mode, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh (mode As RefreshMode, entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Linq::RefreshMode mode, System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.Refresh : System.Data.Linq.RefreshMode * obj -&gt; unit" Usage="dataContext.Refresh (mode, entity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Data.Linq.RefreshMode" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="mode"><span data-ttu-id="01340-353">值，指定如何處理開放式並行存取 (Optimistic Concurrency) 衝突。</span><span class="sxs-lookup"><span data-stu-id="01340-353">A value that specifies how optimistic concurrency conflicts are handled.</span></span></param>
        <param name="entity"><span data-ttu-id="01340-354">要重新整理的物件。</span><span class="sxs-lookup"><span data-stu-id="01340-354">The object to be refreshed.</span></span></param>
        <summary><span data-ttu-id="01340-355">根據指定的模式重新整理實體物件。</span><span class="sxs-lookup"><span data-stu-id="01340-355">Refreshes an entity object according to the specified mode.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Linq.RefreshMode mode, params object[] entities);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Linq.RefreshMode mode, object[] entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh (mode As RefreshMode, ParamArray entities As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Linq::RefreshMode mode, ... cli::array &lt;System::Object ^&gt; ^ entities);" />
      <MemberSignature Language="F#" Value="member this.Refresh : System.Data.Linq.RefreshMode * obj[] -&gt; unit" Usage="dataContext.Refresh (mode, entities)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Data.Linq.RefreshMode" />
        <Parameter Name="entities" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="mode"><span data-ttu-id="01340-356">值，指定如何處理開放式並行存取 (Optimistic Concurrency) 衝突。</span><span class="sxs-lookup"><span data-stu-id="01340-356">A value that specifies how optimistic concurrency conflicts are handled.</span></span></param>
        <param name="entities"><span data-ttu-id="01340-357">要重新整理的實體物件陣列。</span><span class="sxs-lookup"><span data-stu-id="01340-357">The array of entity objects to be refreshed.</span></span></param>
        <summary><span data-ttu-id="01340-358">根據指定的模式重新整理實體物件的陣列。</span><span class="sxs-lookup"><span data-stu-id="01340-358">Refreshes an array of entity objects according to the specified mode.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubmitChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="01340-359">計算要插入、更新或刪除的一組已修改的物件，並執行適當的命令來實作資料庫的變更。</span><span class="sxs-lookup"><span data-stu-id="01340-359">Computes the set of modified objects to be inserted, updated, or deleted, and executes the appropriate commands to implement the changes to the database.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01340-360">覆寫方法是否有 insert、 update 或 delete<xref:System.Data.Linq.DataContext.SubmitChanges%2A>執行這些方法，而非預設[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]命令。</span><span class="sxs-lookup"><span data-stu-id="01340-360">If override methods are present for insert, update, or delete, <xref:System.Data.Linq.DataContext.SubmitChanges%2A> executes these methods instead of the default [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] commands.</span></span>  
  
 <span data-ttu-id="01340-361"><xref:System.Data.Linq.DataContext.SubmitChanges%2A> 啟動交易，且會回復發生例外狀況而<xref:System.Data.Linq.DataContext.SubmitChanges%2A>正在執行。</span><span class="sxs-lookup"><span data-stu-id="01340-361"><xref:System.Data.Linq.DataContext.SubmitChanges%2A> starts a transaction and will roll back if an exception occurs while <xref:System.Data.Linq.DataContext.SubmitChanges%2A> is executing.</span></span> <span data-ttu-id="01340-362">不過，這不會回復所做的變更在記憶體中或由追蹤<xref:System.Data.Linq.DataContext>; 這些變更將需要回復以手動方式。</span><span class="sxs-lookup"><span data-stu-id="01340-362">However, this does not roll back the changes in memory or tracked by the <xref:System.Data.Linq.DataContext>; those changes will need to be rolled back manually.</span></span> <span data-ttu-id="01340-363">您可以使用的新執行個體啟動<xref:System.Data.Linq.DataContext>如果記憶體中的變更會遭到捨棄。</span><span class="sxs-lookup"><span data-stu-id="01340-363">You can start with a new instance of the <xref:System.Data.Linq.DataContext> if the changes in memory are to be discarded.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubmitChanges">
      <MemberSignature Language="C#" Value="public void SubmitChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SubmitChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.SubmitChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub SubmitChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SubmitChanges();" />
      <MemberSignature Language="F#" Value="member this.SubmitChanges : unit -&gt; unit" Usage="dataContext.SubmitChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="01340-364">計算要插入、更新或刪除的一組已修改的物件，並執行適當的命令來實作資料庫的變更。</span><span class="sxs-lookup"><span data-stu-id="01340-364">Computes the set of modified objects to be inserted, updated, or deleted, and executes the appropriate commands to implement the changes to the database.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01340-365">覆寫方法是否有 insert、 update 或 delete<xref:System.Data.Linq.DataContext.SubmitChanges%2A>執行這些方法，而非預設[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]命令。</span><span class="sxs-lookup"><span data-stu-id="01340-365">If override methods are present for insert, update, or delete, <xref:System.Data.Linq.DataContext.SubmitChanges%2A> executes these methods instead of the default [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] commands.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SubmitChanges">
      <MemberSignature Language="C#" Value="public virtual void SubmitChanges (System.Data.Linq.ConflictMode failureMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SubmitChanges(valuetype System.Data.Linq.ConflictMode failureMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.SubmitChanges(System.Data.Linq.ConflictMode)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SubmitChanges (failureMode As ConflictMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SubmitChanges(System::Data::Linq::ConflictMode failureMode);" />
      <MemberSignature Language="F#" Value="abstract member SubmitChanges : System.Data.Linq.ConflictMode -&gt; unit&#xA;override this.SubmitChanges : System.Data.Linq.ConflictMode -&gt; unit" Usage="dataContext.SubmitChanges failureMode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="failureMode" Type="System.Data.Linq.ConflictMode" />
      </Parameters>
      <Docs>
        <param name="failureMode"><span data-ttu-id="01340-366">送出失敗時所要採取的動作。</span><span class="sxs-lookup"><span data-stu-id="01340-366">The action to be taken if the submission fails.</span></span> <span data-ttu-id="01340-367">有效引數如下：</span><span class="sxs-lookup"><span data-stu-id="01340-367">Valid arguments are as follows:</span></span> 
 <see cref="F:System.Data.Linq.ConflictMode.FailOnFirstConflict" /><see cref="F:System.Data.Linq.ConflictMode.ContinueOnConflict" /></param>
        <summary><span data-ttu-id="01340-368">傳送用來擷取物件至基礎資料庫中的變更，並指定送出失敗時所要採取的動作。</span><span class="sxs-lookup"><span data-stu-id="01340-368">Sends changes that were made to retrieved objects to the underlying database, and specifies the action to be taken if the submission fails.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01340-369">預設失敗模式是<xref:System.Data.Linq.ConflictMode.FailOnFirstConflict>。</span><span class="sxs-lookup"><span data-stu-id="01340-369">Default failure mode is <xref:System.Data.Linq.ConflictMode.FailOnFirstConflict>.</span></span>  
  
   
  
## Examples  
 [!code-csharp[System.Data.Linq.ConflictModeEnumeration#1](~/samples/snippets/csharp/VS_Snippets_Data/system.data.linq.conflictmodeenumeration/cs/program.cs#1)]
 [!code-vb[System.Data.Linq.ConflictModeEnumeration#1](~/samples/snippets/visualbasic/VS_Snippets_Data/system.data.linq.conflictmodeenumeration/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transaction">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbTransaction Transaction { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbTransaction Transaction" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.Transaction" />
      <MemberSignature Language="VB.NET" Value="Public Property Transaction As DbTransaction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbTransaction ^ Transaction { System::Data::Common::DbTransaction ^ get(); void set(System::Data::Common::DbTransaction ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Transaction : System.Data.Common.DbTransaction with get, set" Usage="System.Data.Linq.DataContext.Transaction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbTransaction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="01340-370">取得或設定 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 用來存取資料庫的本機交易。</span><span class="sxs-lookup"><span data-stu-id="01340-370">Gets or sets a local transaction for the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] to use to access the database.</span></span></summary>
        <value><span data-ttu-id="01340-371">執行查詢和命令時，<see cref="T:System.Data.Linq.DataContext" /> 所使用的交易物件。</span><span class="sxs-lookup"><span data-stu-id="01340-371">The transaction object used by the <see cref="T:System.Data.Linq.DataContext" /> when executing queries and commands.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01340-372">這個屬性的主要案例是互通性與關聯式[!INCLUDE[vstecado](~/includes/vstecado-md.md)]程式碼。</span><span class="sxs-lookup"><span data-stu-id="01340-372">The primary scenario for this property is interoperability with relational [!INCLUDE[vstecado](~/includes/vstecado-md.md)] code.</span></span> <span data-ttu-id="01340-373">例如，使用這個屬性，當您撰寫您自己`Create` / `Update` / `Delete`方法來設定`Transaction`ADO 屬性`Command`物件。</span><span class="sxs-lookup"><span data-stu-id="01340-373">For example, use this property when you write your own `Create`/`Update`/`Delete` methods to set the `Transaction` property on the ADO `Command` object.</span></span>  
  
 <span data-ttu-id="01340-374">請注意下列事項：</span><span class="sxs-lookup"><span data-stu-id="01340-374">Note the following:</span></span>  
  
-   <span data-ttu-id="01340-375">如果未明確設定此屬性，則 getter 會傳回 null。</span><span class="sxs-lookup"><span data-stu-id="01340-375">If this property has not been explicitly set, the getter returns null.</span></span>  
  
-   <span data-ttu-id="01340-376">如果在執行程式碼<xref:System.Transactions.Transaction>內容中，設定這個屬性會擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="01340-376">If the code is executing in a <xref:System.Transactions.Transaction> context, setting this property throws an exception.</span></span>  
  
-   <span data-ttu-id="01340-377">如果此屬性為集合與新<xref:System.Transactions.Transaction>會開啟，會擲回例外狀況時執行的查詢或更新。</span><span class="sxs-lookup"><span data-stu-id="01340-377">If this property is set and a new <xref:System.Transactions.Transaction> is opened, an exception is thrown when a query or update is executed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Translate">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="01340-378">將現有的 <see cref="T:System.Data.IDataReader" /> 轉換成物件。</span><span class="sxs-lookup"><span data-stu-id="01340-378">Converts an existing <see cref="T:System.Data.IDataReader" /> to objects.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01340-379">每個資料列<xref:System.Data.IDataReader>中的物件會轉換<xref:System.Collections.Generic.IEnumerable%601>。</span><span class="sxs-lookup"><span data-stu-id="01340-379">Each row in the <xref:System.Data.IDataReader> is converted to an object in the <xref:System.Collections.Generic.IEnumerable%601>.</span></span>  
  
```  
public IEnumerable<T> Translate<T>(IDataReader reader) {}  
```  
  
 <span data-ttu-id="01340-380">描述：這個方法用來將轉換的現有<xref:System.Data.Common.DbDataReader>物件。</span><span class="sxs-lookup"><span data-stu-id="01340-380">Description: This method is used to convert an existing <xref:System.Data.Common.DbDataReader> to objects.</span></span> <span data-ttu-id="01340-381">每個資料列<xref:System.Data.Common.DbDataReader>中的物件會轉換<xref:System.Collections.Generic.IEnumerable%601>。</span><span class="sxs-lookup"><span data-stu-id="01340-381">Each row in the <xref:System.Data.Common.DbDataReader> is converted to an object in the <xref:System.Collections.Generic.IEnumerable%601>.</span></span>  
  
 <span data-ttu-id="01340-382">**泛型參數：**</span><span class="sxs-lookup"><span data-stu-id="01340-382">**Generic parameters:**</span></span>  
  
 <span data-ttu-id="01340-383">`T`：請參閱 <xref:System.Data.Linq.DataContext.ExecuteQuery%2A>。</span><span class="sxs-lookup"><span data-stu-id="01340-383">`T`: See <xref:System.Data.Linq.DataContext.ExecuteQuery%2A>.</span></span>  
  
 <span data-ttu-id="01340-384">**參數：**</span><span class="sxs-lookup"><span data-stu-id="01340-384">**Parameters:**</span></span>  
  
 <span data-ttu-id="01340-385">`Query`：請參閱底下的命令的描述<xref:System.Data.Linq.DataContext.ExecuteCommand%2A>。</span><span class="sxs-lookup"><span data-stu-id="01340-385">`Query`: See the description for command under <xref:System.Data.Linq.DataContext.ExecuteCommand%2A>.</span></span>  
  
 <span data-ttu-id="01340-386">`Parameters`：請參閱底下的參數的描述<xref:System.Data.Linq.DataContext.ExecuteCommand%2A>。</span><span class="sxs-lookup"><span data-stu-id="01340-386">`Parameters`: See the description for parameters under <xref:System.Data.Linq.DataContext.ExecuteCommand%2A>.</span></span>  
  
 <span data-ttu-id="01340-387">**傳回類型：**</span><span class="sxs-lookup"><span data-stu-id="01340-387">**Return type:**</span></span>  
  
 <span data-ttu-id="01340-388"><xref:System.Collections.Generic.IEnumerable%601>： 轉換所傳回的物件的集合。</span><span class="sxs-lookup"><span data-stu-id="01340-388"><xref:System.Collections.Generic.IEnumerable%601>: collection of objects returned by the conversion.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Translate">
      <MemberSignature Language="C#" Value="public System.Data.Linq.IMultipleResults Translate (System.Data.Common.DbDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Linq.IMultipleResults Translate(class System.Data.Common.DbDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Translate(System.Data.Common.DbDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function Translate (reader As DbDataReader) As IMultipleResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Linq::IMultipleResults ^ Translate(System::Data::Common::DbDataReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.Translate : System.Data.Common.DbDataReader -&gt; System.Data.Linq.IMultipleResults" Usage="dataContext.Translate reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.IMultipleResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
      </Parameters>
      <Docs>
        <param name="reader"><span data-ttu-id="01340-389">要轉換的 <see cref="T:System.Data.IDataReader" />。</span><span class="sxs-lookup"><span data-stu-id="01340-389">The <see cref="T:System.Data.IDataReader" /> to be converted.</span></span></param>
        <summary><span data-ttu-id="01340-390">將現有的 <see cref="T:System.Data.Common.DbDataReader" /> 轉換成物件。</span><span class="sxs-lookup"><span data-stu-id="01340-390">Converts an existing <see cref="T:System.Data.Common.DbDataReader" /> to objects.</span></span></summary>
        <returns><span data-ttu-id="01340-391">轉換所傳回的物件清單。</span><span class="sxs-lookup"><span data-stu-id="01340-391">A list of objects returned by the conversion.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Translate">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerable Translate (Type elementType, System.Data.Common.DbDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.IEnumerable Translate(class System.Type elementType, class System.Data.Common.DbDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function Translate (elementType As Type, reader As DbDataReader) As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::IEnumerable ^ Translate(Type ^ elementType, System::Data::Common::DbDataReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.Translate : Type * System.Data.Common.DbDataReader -&gt; System.Collections.IEnumerable" Usage="dataContext.Translate (elementType, reader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
      </Parameters>
      <Docs>
        <param name="elementType"><span data-ttu-id="01340-392">要傳回的 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 型別。</span><span class="sxs-lookup"><span data-stu-id="01340-392">The type of the <see cref="T:System.Collections.Generic.IEnumerable`1" /> to be returned.</span></span>  
  
<span data-ttu-id="01340-393">結果中的資料行與物件運作中的欄位和屬性相符合的演算法用法如下：</span><span class="sxs-lookup"><span data-stu-id="01340-393">The algorithm for matching columns in the result to fields and properties in the object works as follows:</span></span> 
<span data-ttu-id="01340-394">如果欄位或屬性已對應至特定資料行名稱，結果集 (Resultset) 必須包含該資料行名稱。</span><span class="sxs-lookup"><span data-stu-id="01340-394">If a field or property is mapped to a particular column name, that column name is expected in the resultset.</span></span>  
  
<span data-ttu-id="01340-395">如果欄位或屬性未對應，結果集必須包含與該欄位或屬性同名的資料行。</span><span class="sxs-lookup"><span data-stu-id="01340-395">If a field or property is not mapped, a column with the same name as the field or property is expected in the resultset.</span></span>  
  
<span data-ttu-id="01340-396">尋找區分大小寫的相符項時會先進行比較。</span><span class="sxs-lookup"><span data-stu-id="01340-396">The comparison is performed by looking for a case-sensitive match first.</span></span> <span data-ttu-id="01340-397">如果找不到這種相符項，就會繼續搜尋不區分大小寫的相符項。</span><span class="sxs-lookup"><span data-stu-id="01340-397">If this match is not found, a subsequent search is occurs for a case-insensitive match.</span></span>  
  
<span data-ttu-id="01340-398">當下列所有條件皆為 true 時，查詢必須傳回該物件所有追蹤的欄位和屬性 (會延後載入的欄位和屬性除外)：</span><span class="sxs-lookup"><span data-stu-id="01340-398">The query must return all the tracked fields and properties of the object (except those that are loaded on a deferred basis) when all the following conditions are true:</span></span> 
 <span data-ttu-id="01340-399"><c>T</c> 是 <see cref="T:System.Data.Linq.DataContext" /> 明確追蹤的實體。</span><span class="sxs-lookup"><span data-stu-id="01340-399"><c>T</c> is an entity explicitly tracked by the <see cref="T:System.Data.Linq.DataContext" />.</span></span>  
  
 <span data-ttu-id="01340-400"><see cref="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" /> 為 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="01340-400"><see cref="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" /> is <see langword="true" />.</span></span>  
  
<span data-ttu-id="01340-401">這個實體具有主索引鍵。</span><span class="sxs-lookup"><span data-stu-id="01340-401">The entity has a primary key.</span></span>  
  
<span data-ttu-id="01340-402">否則，會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="01340-402">Otherwise an exception is thrown.</span></span></param>
        <param name="reader"><span data-ttu-id="01340-403">要轉換的 <see cref="T:System.Data.IDataReader" />。</span><span class="sxs-lookup"><span data-stu-id="01340-403">The <see cref="T:System.Data.IDataReader" /> to be converted.</span></span></param>
        <summary><span data-ttu-id="01340-404">將現有的 <see cref="T:System.Data.Common.DbDataReader" /> 轉換成物件。</span><span class="sxs-lookup"><span data-stu-id="01340-404">Converts an existing <see cref="T:System.Data.Common.DbDataReader" /> to objects.</span></span></summary>
        <returns><span data-ttu-id="01340-405">轉換所傳回的物件清單。</span><span class="sxs-lookup"><span data-stu-id="01340-405">A list of objects returned by the conversion.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Translate&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;TResult&gt; Translate&lt;TResult&gt; (System.Data.Common.DbDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Translate&lt;TResult&gt;(class System.Data.Common.DbDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Translate``1(System.Data.Common.DbDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function Translate(Of TResult) (reader As DbDataReader) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ Translate(System::Data::Common::DbDataReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.Translate : System.Data.Common.DbDataReader -&gt; seq&lt;'Result&gt;" Usage="dataContext.Translate reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="01340-406">要傳回的 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 型別。</span><span class="sxs-lookup"><span data-stu-id="01340-406">The type of the <see cref="T:System.Collections.Generic.IEnumerable`1" /> to be returned.</span></span></typeparam>
        <param name="reader"><span data-ttu-id="01340-407">要轉換的 <see cref="T:System.Data.IDataReader" />。</span><span class="sxs-lookup"><span data-stu-id="01340-407">The <see cref="T:System.Data.IDataReader" /> to be converted.</span></span></param>
        <summary><span data-ttu-id="01340-408">將現有的 <see cref="T:System.Data.Common.DbDataReader" /> 轉換成物件。</span><span class="sxs-lookup"><span data-stu-id="01340-408">Converts an existing <see cref="T:System.Data.Common.DbDataReader" /> to objects.</span></span></summary>
        <returns><span data-ttu-id="01340-409">轉換所傳回的物件集合。</span><span class="sxs-lookup"><span data-stu-id="01340-409">A collection of objects returned by the conversion.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
