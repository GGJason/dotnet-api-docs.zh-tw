<Type Name="SortedList" FullName="System.Collections.SortedList">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5ef58cc883582aa422d11b8c93787c25816a7937" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39952019" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class SortedList : ICloneable, System.Collections.IDictionary" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit SortedList extends System.Object implements class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.SortedList" />
  <TypeSignature Language="VB.NET" Value="Public Class SortedList&#xA;Implements ICloneable, IDictionary" />
  <TypeSignature Language="C++ CLI" Value="public ref class SortedList : ICloneable, System::Collections::IDictionary" />
  <TypeSignature Language="F#" Value="type SortedList = class&#xA;    interface IDictionary&#xA;    interface ICloneable&#xA;    interface ICollection&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.NonGeneric</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.SortedList/SortedListDebugView))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示索引鍵/值組配對的集合，這個集合按索引鍵排序，而且可以按索引鍵和索引存取。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此集合的泛型版本，請參閱<xref:System.Collections.Generic.SortedList%602?displayProperty=nameWithType>。  
  
 A<xref:System.Collections.SortedList>項目可以存取，請在其索引鍵，例如在任何項目<xref:System.Collections.IDictionary>實作，或依據索引，例如在任何項目<xref:System.Collections.IList>實作。  
  
 A<xref:System.Collections.SortedList>物件在內部維護兩個陣列來儲存清單，也就是一個陣列的索引鍵的項目和相關聯的值的另一個陣列。 每個項目是可以存取為索引鍵/值組<xref:System.Collections.DictionaryEntry>物件。 金鑰不能是`null`，但是值可以是。  
  
 營運<xref:System.Collections.SortedList>物件是項目數目<xref:System.Collections.SortedList>可以保存。 當項目新增至<xref:System.Collections.SortedList>，自動增加容量視需要透過重新配置。 藉由呼叫，您可以減少容量<xref:System.Collections.SortedList.TrimToSize%2A>或藉由設定<xref:System.Collections.SortedList.Capacity%2A>屬性明確。  
  
 針對非常大型<xref:System.Collections.SortedList>物件，您可以藉由設定增加到 64 位元系統上的 2 億個元素的最大容量`enabled`屬性的組態項目`true`在執行階段環境中。  
  
 項目<xref:System.Collections.SortedList>物件的索引鍵來排序是根據特定<xref:System.Collections.IComparer>實作時指定<xref:System.Collections.SortedList>是建立或根據<xref:System.IComparable>金鑰本身所提供的實作。 在任一情況下，<xref:System.Collections.SortedList>不允許重複的索引鍵。  
  
 索引的順序為基礎的排序順序。 項目新增時，它會插入<xref:System.Collections.SortedList>中正確的排序次序，以及編製索引據此調整。 移除項目時，索引編製也隨之調整。 因此，特定的索引鍵/值組的索引可能會變更加入或移除項目<xref:System.Collections.SortedList>物件。  
  
 上的作業<xref:System.Collections.SortedList>物件通常會變慢，相較於<xref:System.Collections.Hashtable>因為排序的物件。 不過，<xref:System.Collections.SortedList>藉由允許存取的值，可透過關聯的索引鍵或索引可提供更大的彈性。  
  
 可以使用整數索引來存取這個集合中的項目。  這個集合中的索引都是以零為起始的。  
  
 `foreach` C# 語言的陳述式 (`for each` Visual Basic 中) 傳回集合中的項目類型的物件。 因為每個項目的<xref:System.Collections.SortedList>物件是索引鍵/值組，項目型別不是索引鍵的類型或值的類型。 相反地，項目型別是<xref:System.Collections.DictionaryEntry>。 例如:   
  
 [!code-cpp[Classic SortedList Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList Example/CPP/remarks.cpp#2)]
 [!code-csharp[Classic SortedList Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList Example/CS/remarks.cs#2)]
 [!code-vb[Classic SortedList Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList Example/VB/remarks.vb#2)]  
  
 `foreach`陳述式是一個包裝函式可讓只讀取，不寫入至集合的列舉值。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立和初始化<xref:System.Collections.SortedList>物件，以及如何列印出其索引鍵和值。  
  
 [!code-cpp[Classic SortedList Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>公用靜態 (<see langword="Shared" /> Visual Basic 中) 的這種類型的成員都是安全執行緒。 不保證任何執行個體成員是安全執行緒。  
  
A<see cref="T:System.Collections.SortedList" />物件可同時支援多個讀取器，只要不修改集合。 若要保證的執行緒安全<see cref="T:System.Collections.SortedList" />，所有作業都必須都透過包裝函式所傳回<see cref="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)" />方法。  
  
透過集合進行列舉在本質上並非安全執行緒程序。 即使集合經過同步化，其他的執行緒仍可修改該集合，使列舉值擲回例外狀況。 若要保證列舉過程的執行緒安全，您可以在整個列舉過程中鎖定集合，或攔截由其他執行緒的變更所造成的例外狀況。</threadsafe>
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.Collections.IComparer" />
    <altmember cref="T:System.Collections.IDictionary" />
    <altmember cref="T:System.Collections.Hashtable" />
    <altmember cref="T:System.Collections.Generic.SortedList`2" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Collections.SortedList" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Collections.SortedList" /> 類別的新執行個體，其為空白、具有預設的初始容量，而且其排序依據為已加入至 <see cref="T:System.IComparable" /> 之每個索引鍵所實作的 <see cref="T:System.Collections.SortedList" /> 介面。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每個索引鍵必須實作<xref:System.IComparable>介面中的索引鍵的比較能夠<xref:System.Collections.SortedList>物件。 元素的排序根據<xref:System.IComparable>實作，每個索引鍵新增至<xref:System.Collections.SortedList>。  
  
 營運<xref:System.Collections.SortedList>物件是項目數目，<xref:System.Collections.SortedList>可以保存。 當項目新增至<xref:System.Collections.SortedList>，自動增加容量的要求以重新配置內部陣列。  
  
 如果可以估計集合的大小，指定初始容量，就不需要執行數項調整大小作業新增項目時<xref:System.Collections.SortedList>物件。  
  
 這個建構函式是 o （1） 的作業。  
  
   
  
## Examples  
 下列程式碼範例會建立集合使用不同<xref:System.Collections.SortedList>建構函式，並示範行為的集合差異。  
  
 [!code-cpp[System.Collections.SortedList_ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/CPP/sortedlist_ctor.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/CS/sortedlist_ctor.cs#1)]
 [!code-vb[System.Collections.SortedList_ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/VB/sortedlist_ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IComparable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.SortedList : System.Collections.IComparer -&gt; System.Collections.SortedList" Usage="new System.Collections.SortedList comparer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="comparer">比較索引鍵時所要使用的 <see cref="T:System.Collections.IComparer" /> 實作。  
  
-或- 
 要使用每個索引鍵之 <see cref="T:System.IComparable" /> 實作的 <see langword="null" />。</param>
        <summary>初始化 <see cref="T:System.Collections.SortedList" /> 類別的新執行個體，其為空白且具有預設的初始容量，並根據指定的 <see cref="T:System.Collections.IComparer" /> 介面排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 元素的排序根據指定<xref:System.Collections.IComparer>實作。 如果`comparer`參數是`null`，則<xref:System.IComparable>會使用每個索引鍵的實作; 因此，必須實作每個索引鍵<xref:System.IComparable>介面，以使用中的索引鍵的比較能夠<xref:System.Collections.SortedList>物件。  
  
 營運<xref:System.Collections.SortedList>物件是項目數目，<xref:System.Collections.SortedList>可以保存。 當項目新增至<xref:System.Collections.SortedList>，自動增加容量的要求以重新配置內部陣列。  
  
 如果可以估計集合的大小，指定初始容量，就不需要執行數項調整大小作業新增項目時<xref:System.Collections.SortedList>物件。  
  
 這個建構函式是 o （1） 的作業。  
  
   
  
## Examples  
 下列程式碼範例會建立集合使用不同<xref:System.Collections.SortedList>建構函式，並示範行為的集合差異。  
  
 [!code-cpp[System.Collections.SortedList_ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/CPP/sortedlist_ctor.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/CS/sortedlist_ctor.cs#1)]
 [!code-vb[System.Collections.SortedList_ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/VB/sortedlist_ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.IDictionary d);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(System::Collections::IDictionary ^ d);" />
      <MemberSignature Language="F#" Value="new System.Collections.SortedList : System.Collections.IDictionary -&gt; System.Collections.SortedList" Usage="new System.Collections.SortedList d" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="d">要複製到新 <see cref="T:System.Collections.IDictionary" /> 物件的 <see cref="T:System.Collections.SortedList" /> 實作。</param>
        <summary>初始化 <see cref="T:System.Collections.SortedList" /> 類別的新執行個體，其含有從指定的字典複製過來的元素、具有與複製的元素數一樣的初始容量且根據每一個索引鍵實作的 <see cref="T:System.IComparable" /> 介面排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每個索引鍵必須實作<xref:System.IComparable>介面中的索引鍵的比較能夠<xref:System.Collections.SortedList>物件。 元素的排序根據<xref:System.IComparable>實作，每個索引鍵新增至<xref:System.Collections.SortedList>。  
  
 A<xref:System.Collections.Hashtable>物件是範例<xref:System.Collections.IDictionary>可以傳遞至這個建構函式的實作。 新<xref:System.Collections.SortedList>物件包含索引鍵和值儲存在一份<xref:System.Collections.Hashtable>。  
  
 營運<xref:System.Collections.SortedList>物件是項目數目，<xref:System.Collections.SortedList>可以保存。 當項目新增至<xref:System.Collections.SortedList>，自動增加容量的要求以重新配置內部陣列。  
  
 如果可以估計集合的大小，指定初始容量，就不需要執行數項調整大小作業新增項目時<xref:System.Collections.SortedList>物件。  
  
 這個建構函式是 O (`n`) 運算，其中`n`是中的項目數`d`。  
  
   
  
## Examples  
 下列程式碼範例會建立集合使用不同<xref:System.Collections.SortedList>建構函式，並示範行為的集合差異。  
  
 [!code-cpp[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/CPP/sortedlist_ctordictionary.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/CS/sortedlist_ctordictionary.cs#1)]
 [!code-vb[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/VB/sortedlist_ctordictionary.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="d" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="d" /> 中的一個或多個元素沒有實作 <see cref="T:System.IComparable" /> 介面。</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (int initialCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(int initialCapacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.SortedList : int -&gt; System.Collections.SortedList" Usage="new System.Collections.SortedList initialCapacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCapacity">
          <see cref="T:System.Collections.SortedList" /> 物件可包含的初始元素數目。</param>
        <summary>初始化 <see cref="T:System.Collections.SortedList" /> 類別的新執行個體，其為空白、具有指定的初始容量，而且其排序依據為已加入至 <see cref="T:System.IComparable" /> 之每個索引鍵所實作的 <see cref="T:System.Collections.SortedList" /> 介面。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每個索引鍵必須實作<xref:System.IComparable>介面中的索引鍵的比較能夠<xref:System.Collections.SortedList>物件。 元素的排序根據<xref:System.IComparable>實作，每個索引鍵新增至<xref:System.Collections.SortedList>。  
  
 營運<xref:System.Collections.SortedList>物件是項目數目，<xref:System.Collections.SortedList>可以保存。 當項目新增至<xref:System.Collections.SortedList>，自動增加容量的要求以重新配置內部陣列。  
  
 如果可以估計集合的大小，指定初始容量，就不需要執行數項調整大小作業新增項目時<xref:System.Collections.SortedList>物件。  
  
 這個建構函式是 O (`n`) 運算，其中`n`是`initialCapacity`。  
  
   
  
## Examples  
 下列程式碼範例會建立集合使用不同<xref:System.Collections.SortedList>建構函式，並示範行為的集合差異。  
  
 [!code-cpp[System.Collections.SortedList_ctorInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/CPP/sortedlist_ctorint.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctorInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/CS/sortedlist_ctorint.cs#1)]
 [!code-vb[System.Collections.SortedList_ctorInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/VB/sortedlist_ctorint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="initialCapacity" /> 小於零。</exception>
        <exception cref="T:System.OutOfMemoryException">沒有足夠的記憶體可用，無法建立具有所指定 <paramref name="initialCapacity" /> 的 <see cref="T:System.Collections.SortedList" /> 物件。</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.IComparer comparer, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IComparer comparer, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Collections.IComparer,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (comparer As IComparer, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(System::Collections::IComparer ^ comparer, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.SortedList : System.Collections.IComparer * int -&gt; System.Collections.SortedList" Usage="new System.Collections.SortedList (comparer, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="comparer">比較索引鍵時所要使用的 <see cref="T:System.Collections.IComparer" /> 實作。  
  
-或- 
 要使用每個索引鍵之 <see cref="T:System.IComparable" /> 實作的 <see langword="null" />。</param>
        <param name="capacity">
          <see cref="T:System.Collections.SortedList" /> 物件可包含的初始元素數目。</param>
        <summary>初始化 <see cref="T:System.Collections.SortedList" /> 類別新執行個體，其為空白且具有指定的初始容量，並根據指定的 <see cref="T:System.Collections.IComparer" /> 介面排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 元素的排序根據指定<xref:System.Collections.IComparer>實作。 如果`comparer`參數是`null`，則<xref:System.IComparable>會使用每個索引鍵的實作; 因此，必須實作每個索引鍵<xref:System.IComparable>介面，以使用中的索引鍵的比較能夠<xref:System.Collections.SortedList>物件。  
  
 營運<xref:System.Collections.SortedList>物件是項目數目，<xref:System.Collections.SortedList>可以保存。 當項目新增至<xref:System.Collections.SortedList>，自動增加容量的要求以重新配置內部陣列。  
  
 如果可以估計集合的大小，指定初始容量，就不需要執行數項調整大小作業新增項目時<xref:System.Collections.SortedList>物件。  
  
 這個建構函式是 O (`n`) 運算，其中`n`是`capacity`。  
  
   
  
## Examples  
 下列程式碼範例會建立集合使用不同<xref:System.Collections.SortedList>建構函式，並示範行為的集合差異。  
  
 [!code-cpp[System.Collections.SortedList_ctorInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/CPP/sortedlist_ctorint.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctorInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/CS/sortedlist_ctorint.cs#1)]
 [!code-vb[System.Collections.SortedList_ctorInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/VB/sortedlist_ctorint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> 小於零。</exception>
        <exception cref="T:System.OutOfMemoryException">沒有足夠的記憶體可用，無法建立具有所指定 <paramref name="capacity" /> 的 <see cref="T:System.Collections.SortedList" /> 物件。</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.IDictionary d, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(System::Collections::IDictionary ^ d, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.SortedList : System.Collections.IDictionary * System.Collections.IComparer -&gt; System.Collections.SortedList" Usage="new System.Collections.SortedList (d, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="d">要複製到新 <see cref="T:System.Collections.IDictionary" /> 物件的 <see cref="T:System.Collections.SortedList" /> 實作。</param>
        <param name="comparer">比較索引鍵時所要使用的 <see cref="T:System.Collections.IComparer" /> 實作。  
  
-或- 
 要使用每個索引鍵之 <see cref="T:System.IComparable" /> 實作的 <see langword="null" />。</param>
        <summary>初始化 <see cref="T:System.Collections.SortedList" /> 類別的新執行個體，其含有從指定的字典複製過來的元素、具有與複製的元素數一樣的初始容量且根據指定的 <see cref="T:System.Collections.IComparer" /> 介面排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 元素的排序根據指定<xref:System.Collections.IComparer>實作。 如果`comparer`參數是`null`，則<xref:System.IComparable>會使用每個索引鍵的實作; 因此，必須實作每個索引鍵<xref:System.IComparable>介面，以使用中的索引鍵的比較能夠<xref:System.Collections.SortedList>物件。  
  
 A<xref:System.Collections.Hashtable>物件是範例<xref:System.Collections.IDictionary>可以傳遞至這個建構函式的實作。 新<xref:System.Collections.SortedList>物件包含索引鍵和值儲存在一份<xref:System.Collections.Hashtable>。  
  
 營運<xref:System.Collections.SortedList>物件是項目數目，<xref:System.Collections.SortedList>可以保存。 當項目新增至<xref:System.Collections.SortedList>，自動增加容量的要求以重新配置內部陣列。  
  
 如果可以估計集合的大小，指定初始容量，就不需要執行數項調整大小作業新增項目時<xref:System.Collections.SortedList>物件。  
  
 這個建構函式是 O (`n`) 運算，其中`n`是中的項目數`d`。  
  
   
  
## Examples  
 下列程式碼範例會建立集合使用不同<xref:System.Collections.SortedList>建構函式，並示範行為的集合差異。  
  
 [!code-cpp[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/CPP/sortedlist_ctordictionary.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/CS/sortedlist_ctordictionary.cs#1)]
 [!code-vb[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/VB/sortedlist_ctordictionary.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="d" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="comparer" /> 為 <see langword="null" />，而且 <paramref name="d" /> 中的一個或多個元素沒有實作 <see cref="T:System.IComparable" /> 介面。</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual void Add (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Add(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Add (key As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(System::Object ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Add : obj * obj -&gt; unit&#xA;override this.Add : obj * obj -&gt; unit" Usage="sortedList.Add (key, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Add(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">要加入的項目的索引鍵。</param>
        <param name="value">要加入的項目的值。 這個值可以是 <see langword="null" />。</param>
        <summary>將具有指定索引鍵和值的元素加入至 <see cref="T:System.Collections.SortedList" /> 物件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 插入點取決於選取，以明確或預設的比較子時<xref:System.Collections.SortedList>建立物件。  
  
 如果<xref:System.Collections.SortedList.Count%2A>已等於<xref:System.Collections.SortedList.Capacity%2A>，則容量的<xref:System.Collections.SortedList>物件會加上自動重新配置內部的陣列，並加入新項目之前，現有的項目會複製到新陣列。  
  
 您也可以使用<xref:System.Collections.SortedList.Item%2A>屬性來設定索引鍵的值加入新項目不存在於<xref:System.Collections.SortedList>物件 (例如`myCollection["myNonexistentKey"] = myValue`)。 不過，如果指定的索引鍵已存在於<xref:System.Collections.SortedList>，將<xref:System.Collections.SortedList.Item%2A>屬性會覆寫舊的值。 相反地，<xref:System.Collections.SortedList.Add%2A>方法不會修改現有的項目。  
  
 項目<xref:System.Collections.SortedList>物件的索引鍵來排序是根據特定<xref:System.Collections.IComparer>實作時指定<xref:System.Collections.SortedList>是建立或根據<xref:System.IComparable>金鑰本身所提供的實作。  
  
 金鑰不能是`null`，但是值可以是。  
  
 這個方法是 O (`n`) 作業的未排序的資料，其中`n`是<xref:System.Collections.SortedList.Count%2A>。 它是 O (log `n`) 作業，如果清單的結尾處加入新項目。 如果插入會導致一次調整大小，此作業是 O (`n`)。  
  
   
  
## Examples  
 下列程式碼範例示範如何加入項目來<xref:System.Collections.SortedList>物件。  
  
 [!code-cpp[Classic SortedList.Add Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Add Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Add Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Add Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Add Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Add Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="T:System.Collections.SortedList" /> 物件中己經包含具有指定之 <paramref name="key" /> 的元素。  
  
-或- 
<see cref="T:System.Collections.SortedList" /> 設定為使用 <see cref="T:System.IComparable" /> 介面，而且 <paramref name="key" /> 沒有實作 <see cref="T:System.IComparable" /> 介面。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.SortedList" /> 是唯讀的。  
  
-或- 
<see cref="T:System.Collections.SortedList" /> 具有固定的大小。</exception>
        <exception cref="T:System.OutOfMemoryException">沒有足夠的記憶體可用，無法將元素加入至 <see cref="T:System.Collections.SortedList" />。</exception>
        <exception cref="T:System.InvalidOperationException">比較子會擲回例外狀況。</exception>
        <altmember cref="P:System.Collections.SortedList.Item(System.Object)" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public virtual int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Collections.SortedList.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Collections.SortedList" /> 物件的容量。</summary>
        <value>
          <see cref="T:System.Collections.SortedList" /> 物件能夠包含的元素數目。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.SortedList.Capacity%2A> 是的項目數，<xref:System.Collections.SortedList>物件可以存放區。 <xref:System.Collections.SortedList.Count%2A> 是實際的項目數<xref:System.Collections.SortedList>。  
  
 <xref:System.Collections.SortedList.Capacity%2A> 永遠是大於或等於<xref:System.Collections.SortedList.Count%2A>。 如果<xref:System.Collections.SortedList.Count%2A>超過<xref:System.Collections.SortedList.Capacity%2A>同時新增項目，自動增加容量將舊的項目複製並加入新項目之前，重新配置內部陣列。  
  
 藉由呼叫，您可以減少容量<xref:System.Collections.SortedList.TrimToSize%2A>或藉由設定<xref:System.Collections.SortedList.Capacity%2A>屬性明確。 當值<xref:System.Collections.SortedList.Capacity%2A>是設定明確地內部陣列也已重新配置以符合指定的容量。  
  
 擷取這個屬性的值是 o （1） 的作業;將屬性設定為 O (`n`) 運算，其中`n`是新的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">指派的值小於 <see cref="T:System.Collections.SortedList" /> 物件中目前的元素數目。</exception>
        <exception cref="T:System.OutOfMemoryException">系統上沒有足夠的記憶體可用。</exception>
        <altmember cref="M:System.Collections.SortedList.TrimToSize" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public virtual void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="sortedList.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將所有項目從 <see cref="T:System.Collections.SortedList" /> 物件中移除。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.SortedList.Count%2A> 設定為零，且也會釋放集合的項目從其他物件的參考。  
  
 <xref:System.Collections.SortedList.Capacity%2A> 會維持不變。 若要重設的容量<xref:System.Collections.SortedList>物件，請呼叫<xref:System.Collections.SortedList.TrimToSize%2A>或設定<xref:System.Collections.SortedList.Capacity%2A>直接屬性。 修剪空白<xref:System.Collections.SortedList>設定的容量<xref:System.Collections.SortedList>預設容量。  
  
 這個方法是 O (`n`) 運算，其中`n`是<xref:System.Collections.SortedList.Count%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何修剪的未使用的部分<xref:System.Collections.SortedList>物件，以及如何清除的值<xref:System.Collections.SortedList>。  
  
 [!code-cpp[Classic SortedList.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.SortedList" /> 物件是唯讀的。  
  
-或- 
<see cref="T:System.Collections.SortedList" /> 具有固定的大小。</exception>
        <altmember cref="M:System.Collections.SortedList.TrimToSize" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <altmember cref="P:System.Collections.SortedList.Count" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="sortedList.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>建立 <see cref="T:System.Collections.SortedList" /> 物件的淺層複本 (Shallow Copy)。</summary>
        <returns>
          <see cref="T:System.Collections.SortedList" /> 物件的淺層複本。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 它們都是參考類型或值類型，但不會複製參考所參考的物件集合的元素複製集合的淺層複本。 新的集合中的參考會指向相同原始集合中的參考所指向的物件。  
  
 相反地，項目複製集合的深層複本，並直接或間接參考的元素，所有項目。  
  
 這個方法是 O (`n`) 運算，其中`n`是<xref:System.Collections.SortedList.Count%2A>。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.SortedList.CopyTo(System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public virtual bool Contains (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Contains (key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member Contains : obj -&gt; bool&#xA;override this.Contains : obj -&gt; bool" Usage="sortedList.Contains key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">要在 <see cref="T:System.Collections.SortedList" /> 物件中尋找的索引鍵。</param>
        <summary>判斷 <see cref="T:System.Collections.SortedList" /> 物件是否包含特定索引鍵。</summary>
        <returns>如果 <see cref="T:System.Collections.SortedList" /> 物件包含的元素有指定的 <paramref name="key" />，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 項目<xref:System.Collections.SortedList>物件的索引鍵來排序是根據特定<xref:System.Collections.IComparer>實作時指定<xref:System.Collections.SortedList>是建立或根據<xref:System.IComparable>金鑰本身所提供的實作。  
  
 <xref:System.Collections.SortedList.Contains%2A> 會實作 <xref:System.Collections.IDictionary.Contains%2A?displayProperty=nameWithType>。 它的行為就像<xref:System.Collections.SortedList.ContainsKey%2A>。  
  
 這個方法會使用二進位搜尋演算法;因此，這個方法是 O (log `n`) 運算，其中`n`是<xref:System.Collections.SortedList.Count%2A>。  
  
 從.NET Framework 2.0 開始，這個方法會使用集合的物件<xref:System.Object.Equals%2A>並<xref:System.IComparable.CompareTo%2A>上的方法`item`以判斷項目是否存在。 在舊版的.NET Framework 中，藉由進行這項判斷<xref:System.Object.Equals%2A>並<xref:System.IComparable.CompareTo%2A>方法`item`參數集合中的物件。  
  
   
  
## Examples  
 下列程式碼範例示範如何判斷是否<xref:System.Collections.SortedList>物件包含特定項目。  
  
 [!code-cpp[Classic SortedList.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">比較子會擲回例外狀況。</exception>
        <altmember cref="M:System.Collections.SortedList.ContainsKey(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public virtual bool ContainsKey (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsKey(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.ContainsKey(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ContainsKey (key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsKey(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member ContainsKey : obj -&gt; bool&#xA;override this.ContainsKey : obj -&gt; bool" Usage="sortedList.ContainsKey key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">要在 <see cref="T:System.Collections.SortedList" /> 物件中尋找的索引鍵。</param>
        <summary>判斷 <see cref="T:System.Collections.SortedList" /> 物件是否包含特定索引鍵。</summary>
        <returns>如果 <see cref="T:System.Collections.SortedList" /> 物件包含的元素有指定的 <paramref name="key" />，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 項目<xref:System.Collections.SortedList>物件的索引鍵來排序是根據特定<xref:System.Collections.IComparer>實作時指定<xref:System.Collections.SortedList>是建立或根據<xref:System.IComparable>金鑰本身所提供的實作。  
  
 這個方法的行為就像<xref:System.Collections.SortedList.Contains%2A>方法。  
  
 這個方法會使用二進位搜尋演算法;因此，這個方法是 O (log `n`) 運算，其中`n`是<xref:System.Collections.SortedList.Count%2A>。  
  
 從.NET Framework 2.0 開始，這個方法會使用集合的物件<xref:System.Object.Equals%2A>並<xref:System.IComparable.CompareTo%2A>上的方法`item`以判斷項目是否存在。 在舊版的.NET Framework 中，藉由進行這項判斷<xref:System.Object.Equals%2A>並<xref:System.IComparable.CompareTo%2A>方法`item`參數集合中的物件。  
  
   
  
## Examples  
 下列程式碼範例示範如何判斷是否<xref:System.Collections.SortedList>物件包含特定項目。  
  
 [!code-cpp[Classic SortedList.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">比較子會擲回例外狀況。</exception>
        <altmember cref="M:System.Collections.SortedList.Contains(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.ContainsValue(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ContainsValue">
      <MemberSignature Language="C#" Value="public virtual bool ContainsValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.ContainsValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ContainsValue (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member ContainsValue : obj -&gt; bool&#xA;override this.ContainsValue : obj -&gt; bool" Usage="sortedList.ContainsValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要在 <see cref="T:System.Collections.SortedList" /> 物件中尋找的值。 這個值可以是 <see langword="null" />。</param>
        <summary>判斷 <see cref="T:System.Collections.SortedList" /> 物件是否包含特定的值。</summary>
        <returns>如果 <see cref="T:System.Collections.SortedList" /> 物件包含的元素有指定的 <paramref name="value" />，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 項目的值<xref:System.Collections.SortedList>物件會比較指定的值使用<xref:System.Object.Equals%2A>方法。  
  
 這個方法會執行線性搜尋;因此，平均執行時間成正比<xref:System.Collections.SortedList.Count%2A>。 亦即，這個方法是 O (`n`) 運算，其中`n`是<xref:System.Collections.SortedList.Count%2A>。  
  
 從.NET Framework 2.0 開始，這個方法會使用集合的物件<xref:System.Object.Equals%2A>並<xref:System.IComparable.CompareTo%2A>上的方法`item`以判斷項目是否存在。 在舊版的.NET Framework 中，藉由進行這項判斷<xref:System.Object.Equals%2A>並<xref:System.IComparable.CompareTo%2A>方法`item`參數集合中的物件。  
  
   
  
## Examples  
 下列程式碼範例示範如何判斷是否<xref:System.Collections.SortedList>物件包含特定項目。  
  
 [!code-cpp[Classic SortedList.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.SortedList.ContainsKey(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfValue(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="sortedList.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">一維 <see cref="T:System.Array" /> 物件，其為從 <see cref="T:System.Collections.DictionaryEntry" /> 複製之 <see cref="T:System.Collections.SortedList" /> 物件的目的地。 <see cref="T:System.Array" /> 必須有以零為起始的索引。</param>
        <param name="arrayIndex">
          <c>array</c> 中以零起始的索引，複製作業從此處開始。</param>
        <summary>從陣列中指定的索引處開始，將 <see cref="T:System.Collections.SortedList" /> 元素複製到一維 <see cref="T:System.Array" /> 物件中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 索引鍵/值組複製到<xref:System.Array>中相同的順序，在其中將列舉值逐一查看物件<xref:System.Collections.SortedList>物件。  
  
 若要複製的中索引鍵<xref:System.Collections.SortedList>，使用`SortedList.Keys.CopyTo`。  
  
 若要複製中的值<xref:System.Collections.SortedList>，使用`SortedList.Values.CopyTo`。  
  
 這個方法是 O (`n`) 運算，其中`n`是<xref:System.Collections.SortedList.Count%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何將這些值<xref:System.Collections.SortedList>物件的一維<xref:System.Array>物件。  
  
 [!code-cpp[Classic SortedList.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.CopyTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> 小於零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> 是多維的。  
  
-或- 
來源 <see cref="T:System.Collections.SortedList" /> 物件中的元素數目，大於從 <paramref name="arrayIndex" /> 到目的 <paramref name="array" /> 結尾的可用空間。</exception>
        <exception cref="T:System.InvalidCastException">來源 <see cref="T:System.Collections.SortedList" /> 的類型無法自動轉換成目的 <paramref name="array" /> 的類型。</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Collections.DictionaryEntry" />
        <altmember cref="M:System.Collections.SortedList.GetEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public virtual int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Count" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.SortedList.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Collections.SortedList" /> 物件中所包含的元素數目。</summary>
        <value>
          <see cref="T:System.Collections.SortedList" /> 物件中所包含的元素數目。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每個項目是可以存取為索引鍵/值組<xref:System.Collections.DictionaryEntry>物件。  
  
 <xref:System.Collections.SortedList.Capacity%2A> 是的項目數，<xref:System.Collections.SortedList>物件可以存放區。 <xref:System.Collections.SortedList.Count%2A> 是實際的項目數<xref:System.Collections.SortedList>。  
  
 <xref:System.Collections.SortedList.Capacity%2A> 永遠是大於或等於<xref:System.Collections.SortedList.Count%2A>。 如果<xref:System.Collections.SortedList.Count%2A>超過<xref:System.Collections.SortedList.Capacity%2A>同時新增項目，自動增加容量將舊的項目複製並加入新項目之前，重新配置內部陣列。  
  
 擷取這個屬性的值是一種 O(1) 運算。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.SortedList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="GetByIndex">
      <MemberSignature Language="C#" Value="public virtual object GetByIndex (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetByIndex(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetByIndex(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByIndex (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetByIndex(int index);" />
      <MemberSignature Language="F#" Value="abstract member GetByIndex : int -&gt; obj&#xA;override this.GetByIndex : int -&gt; obj" Usage="sortedList.GetByIndex index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">要取得的值的以零為起始的索引。</param>
        <summary>取得 <see cref="T:System.Collections.SortedList" /> 物件中指定之索引處的值。</summary>
        <returns>
          <see cref="T:System.Collections.SortedList" /> 中指定之索引處的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 索引的順序為基礎的排序順序。 項目新增時，它會插入<xref:System.Collections.SortedList>中正確的排序次序，以及編製索引據此調整。 移除項目時，索引編製也隨之調整。 因此，特定的索引鍵/值組的索引可能會變更加入或移除項目<xref:System.Collections.SortedList>物件。  
  
 這個方法是 o （1） 作業。  
  
   
  
## Examples  
 下列程式碼範例示範如何取得一個或所有的索引鍵或值<xref:System.Collections.SortedList>物件。  
  
 [!code-cpp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.GetByIndex Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 在 <see cref="T:System.Collections.SortedList" /> 物件的有效索引範圍之外。</exception>
        <altmember cref="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfValue(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionaryEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumerator () As IDictionaryEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionaryEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator" Usage="sortedList.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回可在 <see cref="T:System.Collections.IDictionaryEnumerator" /> 物件中逐一查看的 <see cref="T:System.Collections.SortedList" /> 物件。</summary>
        <returns>
          <see cref="T:System.Collections.IDictionaryEnumerator" /> 物件的 <see cref="T:System.Collections.SortedList" /> 物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 C# 語言的 `foreach` 陳述式 (在 Visual Basic 中為 `for each`) 會隱藏列舉值的複雜度。  因此，建議您使用 `foreach`，而不要直接使用列舉值。  
  
 列舉程式可以用來讀取集合中的資料，但是無法用來修改基礎集合。  
  
 一開始，列舉程式位在集合中的第一個項目之前。 <xref:System.Collections.IEnumerator.Reset%2A> 也會將列舉值帶回至這個位置。  在這個位置上，<xref:System.Collections.IEnumerator.Current%2A> 並未定義。 因此，在讀取 <xref:System.Collections.IEnumerator.MoveNext%2A> 的值之前，必須呼叫 <xref:System.Collections.IEnumerator.Current%2A> 以將列舉值前移至集合的第一個項目。  
  
 <xref:System.Collections.IEnumerator.Current%2A> 會傳回相同的物件直到呼叫 <xref:System.Collections.IEnumerator.MoveNext%2A> 或 <xref:System.Collections.IEnumerator.Reset%2A>。 <xref:System.Collections.IEnumerator.MoveNext%2A> 會將 <xref:System.Collections.IEnumerator.Current%2A> 設定為下一個項目。  
  
 如果<xref:System.Collections.IEnumerator.MoveNext%2A>集合，也就是列舉值的結尾是否位於集合中的最後一個元素之後的階段和<xref:System.Collections.IEnumerator.MoveNext%2A>傳回`false`。 列舉值位於此位置，後續呼叫<xref:System.Collections.IEnumerator.MoveNext%2A>也會傳回`false`。 如果上次呼叫<xref:System.Collections.IEnumerator.MoveNext%2A>傳回`false`，<xref:System.Collections.IEnumerator.Current%2A>是未定義。 若要再次將 <xref:System.Collections.IEnumerator.Current%2A> 設定為集合的第一個元素，您可以在呼叫 <xref:System.Collections.IEnumerator.Reset%2A> 之後，接著呼叫 <xref:System.Collections.IEnumerator.MoveNext%2A>。  
  
 只要集合維持不變，列舉程式就持續有效。 如果對集合進行變更，例如加入、修改或刪除項目，列舉程式會永久失效，且其行為未定義。  
  
 列舉程式沒有集合的獨佔存取權，因此，列舉集合內容本質上並不是安全的執行緒程序。  若要確保列舉期間的執行緒安全性，您可以在整個列舉期間鎖定集合。  若要讓多重執行緒能夠存取集合以便進行讀取和寫入，您必須實作自己的同步處理。  
  
 這個方法是 o （1） 作業。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetKey">
      <MemberSignature Language="C#" Value="public virtual object GetKey (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetKey(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetKey(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetKey (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetKey(int index);" />
      <MemberSignature Language="F#" Value="abstract member GetKey : int -&gt; obj&#xA;override this.GetKey : int -&gt; obj" Usage="sortedList.GetKey index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">要取得的索引鍵之以零為起始的索引。</param>
        <summary>取得 <see cref="T:System.Collections.SortedList" /> 物件中指定之索引處的索引鍵。</summary>
        <returns>
          <see cref="T:System.Collections.SortedList" /> 物件中指定之索引處的索引鍵。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 索引的順序為基礎的排序順序。 項目新增時，它會插入<xref:System.Collections.SortedList>中正確的排序次序，以及編製索引據此調整。 移除項目時，索引編製也隨之調整。 因此，特定的索引鍵/值組的索引可能會變更加入或移除項目<xref:System.Collections.SortedList>物件。  
  
 這個方法是 o （1） 作業。  
  
   
  
## Examples  
 下列程式碼範例示範如何取得一個或所有的索引鍵或值<xref:System.Collections.SortedList>物件。  
  
 [!code-cpp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.GetByIndex Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 在 <see cref="T:System.Collections.SortedList" /> 物件的有效索引範圍之外。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetKeyList">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IList GetKeyList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IList GetKeyList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetKeyList" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetKeyList () As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IList ^ GetKeyList();" />
      <MemberSignature Language="F#" Value="abstract member GetKeyList : unit -&gt; System.Collections.IList&#xA;override this.GetKeyList : unit -&gt; System.Collections.IList" Usage="sortedList.GetKeyList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得 <see cref="T:System.Collections.SortedList" /> 物件中的索引鍵。</summary>
        <returns>
          <see cref="T:System.Collections.IList" /> 物件，其中包含 <see cref="T:System.Collections.SortedList" /> 物件中的索引鍵。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳回<xref:System.Collections.IList>物件是索引鍵的唯讀檢視<xref:System.Collections.SortedList>物件。 修改對基礎<xref:System.Collections.SortedList>會立即反映在<xref:System.Collections.IList>。  
  
 傳回的項目<xref:System.Collections.IList>排序索引鍵的順序相同<xref:System.Collections.SortedList>。  
  
 這個方法很類似<xref:System.Collections.SortedList.Keys%2A>屬性，但傳回<xref:System.Collections.IList>物件，而不是<xref:System.Collections.ICollection>物件。  
  
 這個方法是 o （1） 作業。  
  
   
  
## Examples  
 下列程式碼範例示範如何取得一個或所有的索引鍵或值<xref:System.Collections.SortedList>物件。  
  
 [!code-cpp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.GetByIndex Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.SortedList.GetValueList" />
        <altmember cref="P:System.Collections.SortedList.Keys" />
      </Docs>
    </Member>
    <Member MemberName="GetValueList">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IList GetValueList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IList GetValueList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetValueList" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValueList () As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IList ^ GetValueList();" />
      <MemberSignature Language="F#" Value="abstract member GetValueList : unit -&gt; System.Collections.IList&#xA;override this.GetValueList : unit -&gt; System.Collections.IList" Usage="sortedList.GetValueList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得 <see cref="T:System.Collections.SortedList" /> 物件中的值。</summary>
        <returns>
          <see cref="T:System.Collections.IList" /> 物件，其中含有 <see cref="T:System.Collections.SortedList" /> 物件中的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳回<xref:System.Collections.IList>物件是唯讀值的檢視<xref:System.Collections.SortedList>物件。 修改對基礎<xref:System.Collections.SortedList>會立即反映在<xref:System.Collections.IList>。  
  
 傳回的項目<xref:System.Collections.IList>的值為相同的順序排序<xref:System.Collections.SortedList>。  
  
 這個方法很類似<xref:System.Collections.SortedList.Values%2A>屬性，但傳回<xref:System.Collections.IList>物件，而不是<xref:System.Collections.ICollection>物件。  
  
 這個方法是 o （1） 作業。  
  
   
  
## Examples  
 下列程式碼範例示範如何取得一個或所有的索引鍵或值<xref:System.Collections.SortedList>物件。  
  
 [!code-cpp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.GetByIndex Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.SortedList.GetKeyList" />
        <altmember cref="P:System.Collections.SortedList.Values" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfKey">
      <MemberSignature Language="C#" Value="public virtual int IndexOfKey (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOfKey(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOfKey (key As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOfKey(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member IndexOfKey : obj -&gt; int&#xA;override this.IndexOfKey : obj -&gt; int" Usage="sortedList.IndexOfKey key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">要在 <see cref="T:System.Collections.SortedList" /> 物件中尋找的索引鍵。</param>
        <summary>傳回 <see cref="T:System.Collections.SortedList" /> 物件中指定之索引鍵的以零起始之索引。</summary>
        <returns>如果在 <see cref="T:System.Collections.SortedList" /> 物件中找到 <paramref name="key" />，則為 <paramref name="key" /> 參數之以零起始的索引，否則為 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 項目<xref:System.Collections.SortedList>物件的索引鍵來排序是根據特定<xref:System.Collections.IComparer>實作時指定<xref:System.Collections.SortedList>建立，或根據<xref:System.IComparable>金鑰本身所提供的實作。  
  
 索引的順序為基礎的排序順序。 項目新增時，它會插入<xref:System.Collections.SortedList>中正確的排序次序，以及編製索引據此調整。 移除項目時，索引編製也隨之調整。 因此，特定的索引鍵/值組的索引可能會變更加入或移除項目<xref:System.Collections.SortedList>。  
  
 這個方法會使用二進位搜尋演算法;因此，這個方法是 O (log `n`) 運算，其中`n`是<xref:System.Collections.SortedList.Count%2A>。  
  
 從.NET Framework 2.0 開始，這個方法會使用集合的物件<xref:System.Object.Equals%2A>並<xref:System.IComparable.CompareTo%2A>上的方法`item`以判斷項目是否存在。 在舊版的.NET Framework 中，藉由進行這項判斷<xref:System.Object.Equals%2A>並<xref:System.IComparable.CompareTo%2A>方法`item`參數集合中的物件。  
  
   
  
## Examples  
 下列程式碼範例示範如何判斷索引的索引鍵或值，以在<xref:System.Collections.SortedList>物件。  
  
 [!code-cpp[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">比較子會擲回例外狀況。</exception>
        <altmember cref="M:System.Collections.SortedList.ContainsKey(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfValue(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfValue">
      <MemberSignature Language="C#" Value="public virtual int IndexOfValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOfValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.IndexOfValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOfValue (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOfValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IndexOfValue : obj -&gt; int&#xA;override this.IndexOfValue : obj -&gt; int" Usage="sortedList.IndexOfValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要在 <see cref="T:System.Collections.SortedList" /> 物件中尋找的值。 這個值可以是 <see langword="null" />。</param>
        <summary>傳回 <see cref="T:System.Collections.SortedList" /> 物件中指定之值的第一個符合項目的以零起始之索引。</summary>
        <returns>如果在 <see cref="T:System.Collections.SortedList" /> 物件中找到 <paramref name="value" />，則為 <paramref name="value" /> 參數第一個符合項目之以零起始的索引，否則為 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 索引的順序為基礎的排序順序。 項目新增時，它會插入<xref:System.Collections.SortedList>中正確的排序次序，以及編製索引據此調整。 移除項目時，索引編製也隨之調整。 因此，特定的索引鍵/值組的索引可能會變更加入或移除項目<xref:System.Collections.SortedList>物件。  
  
 項目的值<xref:System.Collections.SortedList>會比較指定的值使用<xref:System.Object.Equals%2A>方法。  
  
 這個方法會使用線性搜尋;因此，這個方法是 O (`n`) 運算，其中`n`是<xref:System.Collections.SortedList.Count%2A>。  
  
 從.NET Framework 2.0 開始，這個方法會使用集合的物件<xref:System.Object.Equals%2A>並<xref:System.IComparable.CompareTo%2A>上的方法`item`以判斷項目是否存在。 在舊版的.NET Framework 中，藉由進行這項判斷<xref:System.Object.Equals%2A>並<xref:System.IComparable.CompareTo%2A>方法`item`參數集合中的物件。  
  
   
  
## Examples  
 下列程式碼範例示範如何判斷索引的索引鍵或值，以在<xref:System.Collections.SortedList>物件。  
  
 [!code-cpp[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.SortedList.ContainsValue(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public virtual bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFixedSize : bool" Usage="System.Collections.SortedList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Collections.SortedList" /> 物件是否具有固定的大小。</summary>
        <value>如果 <see cref="T:System.Collections.SortedList" /> 物件有固定大小，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 具有固定大小的集合不允許新增或移除項目集合會建立，但不允許修改現有的項目之後。  
  
 具有固定大小集合是唯讀的集合只會防止新增和移除項目; 的包裝函式因此，如果變更基礎的集合，包括新增或移除項目，固定大小的集合會反映這些變更。  
  
 擷取這個屬性的值是一種 O(1) 運算。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public virtual bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Collections.SortedList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Collections.SortedList" /> 物件是否為唯讀。</summary>
        <value>如果 <see cref="T:System.Collections.SortedList" /> 物件是唯讀，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 唯讀的集合不允許在集合建立後增加、移除或修改項目。  
  
 是唯讀的集合是可防止修改集合的包裝函式集合因此，如果基礎集合進行變更，唯讀的集合會反映這些變更。  
  
 擷取這個屬性的值是一種 O(1) 運算。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public virtual bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Collections.SortedList.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出對 <see cref="T:System.Collections.SortedList" /> 物件的存取是否為同步的 (執行緒安全)。</summary>
        <value>如果要同步處理 (執行緒安全) 對 <see cref="T:System.Collections.SortedList" /> 物件的存取，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要保證的執行緒安全<xref:System.Collections.SortedList>物件時，所有作業都必須都透過包裝函式所傳回<xref:System.Collections.SortedList.Synchronized%2A>方法。  
  
 透過集合進行列舉在本質上並非安全執行緒程序。 即使集合經過同步化，其他的執行緒仍可修改該集合，使列舉值擲回例外狀況。 若要保證列舉過程的執行緒安全，您可以在整個列舉過程中鎖定集合，或攔截由其他執行緒的變更所造成的例外狀況。  
  
   
  
## Examples  
 下列程式碼範例示範如何鎖定集合，使用<xref:System.Collections.SortedList.SyncRoot%2A>在整個列舉過程的屬性。  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source2.vb#2)]  
  
 擷取這個屬性的值是一種 O(1) 運算。  
  
 下列程式碼範例示範如何同步處理<xref:System.Collections.SortedList>物件，決定是否<xref:System.Collections.SortedList>同步處理，並使用 同步處理<xref:System.Collections.SortedList>。  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.SortedList.SyncRoot" />
        <altmember cref="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual object this[object key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable Property Item(key As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ key); void set(System::Object ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(obj) : obj with get, set" Usage="System.Collections.SortedList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Item(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">與要取得或設定的值相關聯的索引鍵。</param>
        <summary>取得並設定與 <see cref="T:System.Collections.SortedList" /> 物件中特定索引鍵相關聯的值。</summary>
        <value>如果找到 <paramref name="key" />，則為與 <see cref="T:System.Collections.SortedList" /> 物件中 <paramref name="key" /> 參數相關聯的值，否則為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用<xref:System.Collections.SortedList.Item%2A>屬性來存取集合中的特定項目，藉由指定下列語法： `myCollection[key]`。  
  
 您也可以使用這個屬性來加入新項目中不存在的索引鍵的值設定<xref:System.Collections.SortedList>物件 (例如`myCollection["myNonexistentKey"] = myValue)`。 不過，如果指定的索引鍵已存在於<xref:System.Collections.SortedList>，將<xref:System.Collections.SortedList.Item%2A>屬性會覆寫舊的值。 相反地，<xref:System.Collections.SortedList.Add%2A>方法不會修改現有的項目。  
  
 金鑰不能是`null`，但是值可以是。 區別`null`傳回因為找不到指定的索引鍵和`null`，就會傳回指定之索引鍵的值是因為`null`，使用<xref:System.Collections.SortedList.Contains%2A>方法或<xref:System.Collections.SortedList.ContainsKey%2A>方法，可判斷索引鍵存在於清單中。  
  
 項目<xref:System.Collections.SortedList>的索引鍵來排序是根據特定<xref:System.Collections.IComparer>實作時指定<xref:System.Collections.SortedList>是建立或根據<xref:System.IComparable>金鑰本身所提供的實作。  
  
 C# 語言使用關鍵字來定義索引，而不必實作<xref:System.Collections.SortedList.Keys%2A>屬性。 Visual Basic 會將 <xref:System.Collections.SortedList.Item%2A> 實作為預設屬性，這樣會提供相同的索引功能。  
  
 擷取這個屬性的值是 O (log `n`) 運算，其中`n`是<xref:System.Collections.SortedList.Count%2A>。 將屬性設定為 O (log `n`) 作業的索引鍵是否已在<xref:System.Collections.SortedList>。 如果索引鍵不在清單中，設定該屬性是 O (`n`) 運算為未排序的資料或 O (log `n`) 如果在清單結尾處加入新項目。 如果插入會導致一次調整大小，此作業是 O (`n`)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">已設定該屬性，<see cref="T:System.Collections.SortedList" /> 物件是唯讀的。  
  
-或- 
屬性已設定，<paramref name="key" /> 不存在於集合中，而且 <see cref="T:System.Collections.SortedList" /> 具有固定大小。</exception>
        <exception cref="T:System.OutOfMemoryException">沒有足夠的記憶體可用，無法將元素加入至 <see cref="T:System.Collections.SortedList" />。</exception>
        <exception cref="T:System.InvalidOperationException">比較子會擲回例外狀況。</exception>
        <altmember cref="M:System.Collections.SortedList.Add(System.Object,System.Object)" />
        <altmember cref="M:System.Collections.SortedList.Contains(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.ContainsKey(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ICollection Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Keys" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Keys As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::ICollection ^ Keys { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Keys : System.Collections.ICollection" Usage="System.Collections.SortedList.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Collections.SortedList" /> 物件中的索引鍵。</summary>
        <value>
          <see cref="T:System.Collections.ICollection" /> 物件，其中包含 <see cref="T:System.Collections.SortedList" /> 物件中的索引鍵。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ICollection>物件是索引鍵的唯讀檢視<xref:System.Collections.SortedList>物件。 修改對基礎<xref:System.Collections.SortedList>會立即反映在<xref:System.Collections.ICollection>。  
  
 項目<xref:System.Collections.ICollection>排序索引鍵的順序相同<xref:System.Collections.SortedList>。  
  
 這個屬性是類似<xref:System.Collections.SortedList.GetKeyList%2A>方法，但傳回<xref:System.Collections.ICollection>物件，而不是<xref:System.Collections.IList>物件。  
  
 這個方法是 o （1） 作業。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.SortedList.Values" />
        <altmember cref="M:System.Collections.SortedList.GetKeyList" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public virtual void Remove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Remove (key As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Remove(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member Remove : obj -&gt; unit&#xA;override this.Remove : obj -&gt; unit" Usage="sortedList.Remove key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">要移除的項目索引鍵。</param>
        <summary>從 <see cref="T:System.Collections.SortedList" /> 物件中移除具有指定之索引鍵的元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 <xref:System.Collections.SortedList> 物件不包含具有指定索引鍵的項目，則 <xref:System.Collections.SortedList> 會保持不變。 不會有例外狀況擲回。  
  
 在相鄰元素的集合中，例如清單，接在移除的元素之後的元素會向上移動以佔用空出的位置。 如果集合具有索引，則移動之項目的索引也會更新。 集合的項目若在概念上群組成 Bucket (例如雜湊資料表)，則不適用這項行為。  
  
 這個方法是 O (`n`) 運算，其中`n`是<xref:System.Collections.SortedList.Count%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何移除項目從<xref:System.Collections.SortedList>物件。  
  
 [!code-cpp[Classic SortedList.RemoveAt Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.RemoveAt Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.RemoveAt Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.SortedList" /> 物件是唯讀的。  
  
-或- 
<see cref="T:System.Collections.SortedList" /> 具有固定的大小。</exception>
        <altmember cref="M:System.Collections.SortedList.RemoveAt(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public virtual void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveAt(int index);" />
      <MemberSignature Language="F#" Value="abstract member RemoveAt : int -&gt; unit&#xA;override this.RemoveAt : int -&gt; unit" Usage="sortedList.RemoveAt index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">移除項目之以零為起始的索引。</param>
        <summary>移除 <see cref="T:System.Collections.SortedList" /> 物件中指定索引處的元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 索引的順序為基礎的排序順序。 項目新增時，它會插入<xref:System.Collections.SortedList>中正確的排序次序，以及編製索引據此調整。 移除項目時，索引編製也隨之調整。 因此，特定的索引鍵/值組的索引可能會變更加入或移除項目<xref:System.Collections.SortedList>物件。  
  
 在相鄰元素的集合中，例如清單，接在移除的元素之後的元素會向上移動以佔用空出的位置。 如果集合具有索引，則移動之項目的索引也會更新。 集合的項目若在概念上群組成 Bucket (例如雜湊資料表)，則不適用這項行為。  
  
 這個方法是 O (`n`) 運算，其中`n`是<xref:System.Collections.SortedList.Count%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何移除項目從<xref:System.Collections.SortedList>物件。  
  
 [!code-cpp[Classic SortedList.RemoveAt Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.RemoveAt Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.RemoveAt Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 在 <see cref="T:System.Collections.SortedList" /> 物件的有效索引範圍之外。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.SortedList" /> 是唯讀的。  
  
-或- 
<see cref="T:System.Collections.SortedList" /> 具有固定的大小。</exception>
        <altmember cref="M:System.Collections.SortedList.Remove(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="SetByIndex">
      <MemberSignature Language="C#" Value="public virtual void SetByIndex (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetByIndex(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.SetByIndex(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetByIndex (index As Integer, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetByIndex(int index, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member SetByIndex : int * obj -&gt; unit&#xA;override this.SetByIndex : int * obj -&gt; unit" Usage="sortedList.SetByIndex (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">以零起始的索引，即要儲存 <c>value</c> 的位置。</param>
        <param name="value">要儲存到 <see cref="T:System.Object" /> 物件中的 <see cref="T:System.Collections.SortedList" />。 這個值可以是 <see langword="null" />。</param>
        <summary>取代 <see cref="T:System.Collections.SortedList" /> 物件中特定索引處的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 索引的順序為基礎的排序順序。 項目新增時，它會插入<xref:System.Collections.SortedList>中正確的排序次序，以及編製索引據此調整。 移除項目時，索引編製也隨之調整。 因此，特定的索引鍵/值組的索引可能會變更加入或移除項目<xref:System.Collections.SortedList>物件。  
  
 這個方法是 o （1） 作業。  
  
   
  
## Examples  
 下列程式碼範例示範如何將現有項目中的值取代<xref:System.Collections.SortedList>物件。  
  
 [!code-cpp[Classic SortedList.SetByIndex Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.SetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.SetByIndex Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.SetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.SetByIndex Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.SetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 在 <see cref="T:System.Collections.SortedList" /> 物件的有效索引範圍之外。</exception>
        <altmember cref="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfValue(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.Collections.SortedList Synchronized (System.Collections.SortedList list);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.SortedList Synchronized(class System.Collections.SortedList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Synchronized (list As SortedList) As SortedList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::SortedList ^ Synchronized(System::Collections::SortedList ^ list);" />
      <MemberSignature Language="F#" Value="static member Synchronized : System.Collections.SortedList -&gt; System.Collections.SortedList" Usage="System.Collections.SortedList.Synchronized list" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.SortedList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.SortedList" />
      </Parameters>
      <Docs>
        <param name="list">要同步處理的 <see cref="T:System.Collections.SortedList" /> 物件。</param>
        <summary>傳回 <see cref="T:System.Collections.SortedList" /> 物件的同步處理 (安全執行緒) 包裝函式。</summary>
        <returns>
          <see cref="T:System.Collections.SortedList" /> 物件的同步處理 (安全執行緒) 包裝函式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要保證的執行緒安全<xref:System.Collections.SortedList>物件時，必須透過此包裝函式只完成所有作業。  
  
 透過集合進行列舉在本質上並非安全執行緒程序。 即使集合經過同步化，其他的執行緒仍可修改該集合，使列舉值擲回例外狀況。 若要保證列舉過程的執行緒安全，您可以在整個列舉過程中鎖定集合，或攔截由其他執行緒的變更所造成的例外狀況。  
  
   
  
## Examples  
 下列程式碼範例示範如何鎖定集合使用<xref:System.Collections.SortedList.SyncRoot%2A>在整個列舉過程的屬性。  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source2.vb#2)]  
  
 這個方法是 o （1） 作業。  
  
 下列程式碼範例示範如何同步處理<xref:System.Collections.SortedList>物件，決定是否<xref:System.Collections.SortedList>同步處理，並使用 同步處理<xref:System.Collections.SortedList>。  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="list" /> 為 <see langword="null" />。</exception>
        <altmember cref="P:System.Collections.SortedList.IsSynchronized" />
        <altmember cref="P:System.Collections.SortedList.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public virtual object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Collections.SortedList.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得可用來同步存取 <see cref="T:System.Collections.SortedList" /> 物件的物件。</summary>
        <value>可用來同步處理對 <see cref="T:System.Collections.SortedList" /> 物件之存取的物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要建立的同步處理的版本<xref:System.Collections.SortedList>物件，請使用<xref:System.Collections.SortedList.Synchronized%2A>方法。 不過，在衍生的類別可以提供自己的同步處理的版本<xref:System.Collections.SortedList>使用<xref:System.Collections.SortedList.SyncRoot%2A>屬性。 同步處理的程式碼必須執行作業<xref:System.Collections.SortedList.SyncRoot%2A>的<xref:System.Collections.SortedList>中，不要直接依賴<xref:System.Collections.SortedList>。 如此可確保衍生自其他物件的集合可以正常運作， 具體來說，它會維護適當的同步處理的其他執行緒可能同時修改<xref:System.Collections.SortedList>物件。  
  
 透過集合進行列舉在本質上並非安全執行緒程序。 即使集合經過同步化，其他的執行緒仍可修改該集合，使列舉值擲回例外狀況。 若要保證列舉過程的執行緒安全，您可以在整個列舉過程中鎖定集合，或攔截由其他執行緒的變更所造成的例外狀況。  
  
   
  
## Examples  
 下列程式碼範例示範如何鎖定集合使用<xref:System.Collections.SortedList.SyncRoot%2A>在整個列舉過程的屬性。  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source2.vb#2)]  
  
 擷取這個屬性的值是一種 O(1) 運算。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.SortedList.IsSynchronized" />
        <altmember cref="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回透過 <see cref="T:System.Collections.IEnumerator" /> 重複的 <see cref="T:System.Collections.SortedList" />。</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> 的 <see cref="T:System.Collections.SortedList" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic、 C#]  
  
 C# 語言的 `foreach` 陳述式 (在 Visual Basic 中為 `for each`) 會隱藏列舉值的複雜度。  因此，建議您使用 `foreach`，而不要直接使用列舉值。  
  
 列舉程式可以用來讀取集合中的資料，但是無法用來修改基礎集合。  
  
 一開始，列舉程式位在集合中的第一個項目之前。 <xref:System.Collections.IEnumerator.Reset%2A> 也會將列舉值帶回至這個位置。 在這個位置上，呼叫<xref:System.Collections.IEnumerator.Current%2A>會擲回例外狀況。 因此，在讀取 <xref:System.Collections.IEnumerator.MoveNext%2A> 的值之前，必須呼叫 <xref:System.Collections.IEnumerator.Current%2A> 以將列舉值前移至集合的第一個項目。  
  
 <xref:System.Collections.IEnumerator.Current%2A> 會傳回相同的物件直到呼叫 <xref:System.Collections.IEnumerator.MoveNext%2A> 或 <xref:System.Collections.IEnumerator.Reset%2A>。 <xref:System.Collections.IEnumerator.MoveNext%2A> 會將 <xref:System.Collections.IEnumerator.Current%2A> 設定為下一個項目。  
  
 如果<xref:System.Collections.IEnumerator.MoveNext%2A>集合，也就是列舉值的結尾是否位於集合中的最後一個元素之後的階段和<xref:System.Collections.IEnumerator.MoveNext%2A>傳回`false`。 列舉值位於此位置，後續呼叫<xref:System.Collections.IEnumerator.MoveNext%2A>也會傳回`false`。 如果上次呼叫<xref:System.Collections.IEnumerator.MoveNext%2A>傳回`false`，則呼叫<xref:System.Collections.IEnumerator.Current%2A>會擲回例外狀況。 若要再次將 <xref:System.Collections.IEnumerator.Current%2A> 設定為集合的第一個元素，您可以在呼叫 <xref:System.Collections.IEnumerator.Reset%2A> 之後，接著呼叫 <xref:System.Collections.IEnumerator.MoveNext%2A>。  
  
 只要集合維持不變，列舉程式就持續有效。 如果變更集合，例如加入、 修改或刪除元素，列舉值會將永久失效，而且下次呼叫<xref:System.Collections.IEnumerator.MoveNext%2A>或是<xref:System.Collections.IEnumerator.Reset%2A>就會擲回<xref:System.InvalidOperationException>。 如果集合已修改之間<xref:System.Collections.IEnumerator.MoveNext%2A>並<xref:System.Collections.IEnumerator.Current%2A>，<xref:System.Collections.IEnumerator.Current%2A>傳回設定為，項目，即使已經無效列舉值。  
  
 列舉程式沒有集合的獨佔存取權，因此，列舉集合內容本質上並不是安全的執行緒程序。 即使集合經過同步化，其他的執行緒仍可修改該集合，使列舉值擲回例外狀況。 若要保證列舉過程的執行緒安全，您可以在整個列舉過程中鎖定集合，或攔截由其他執行緒的變更所造成的例外狀況。  
  
 這個方法是 o （1） 作業。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="TrimToSize">
      <MemberSignature Language="C#" Value="public virtual void TrimToSize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void TrimToSize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.TrimToSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub TrimToSize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void TrimToSize();" />
      <MemberSignature Language="F#" Value="abstract member TrimToSize : unit -&gt; unit&#xA;override this.TrimToSize : unit -&gt; unit" Usage="sortedList.TrimToSize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將容量設為 <see cref="T:System.Collections.SortedList" /> 物件中的實際元素數目。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法可用記憶體降到最低集合的額外負荷如果沒有新的項目會加入至集合。  
  
 若要重設<xref:System.Collections.SortedList>設為初始狀態，呼叫的物件<xref:System.Collections.SortedList.Clear%2A>方法之前呼叫<xref:System.Collections.SortedList.TrimToSize%2A>。 修剪空白<xref:System.Collections.SortedList>設定的容量<xref:System.Collections.SortedList>預設容量。  
  
 這個方法是 O (`n`) 運算，其中`n`是<xref:System.Collections.SortedList.Count%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何修剪的未使用的部分<xref:System.Collections.SortedList>物件，以及如何清除其值。  
  
 [!code-cpp[Classic SortedList.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.SortedList" /> 物件是唯讀的。  
  
-或- 
<see cref="T:System.Collections.SortedList" /> 具有固定的大小。</exception>
        <altmember cref="M:System.Collections.SortedList.Clear" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <altmember cref="P:System.Collections.SortedList.Count" />
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ICollection Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Values" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Values As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::ICollection ^ Values { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Values : System.Collections.ICollection" Usage="System.Collections.SortedList.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Collections.SortedList" /> 物件中的值。</summary>
        <value>
          <see cref="T:System.Collections.ICollection" /> 物件，其中含有 <see cref="T:System.Collections.SortedList" /> 物件中的值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ICollection>物件是唯讀值的檢視<xref:System.Collections.SortedList>物件。 修改對基礎<xref:System.Collections.SortedList>會立即反映在<xref:System.Collections.ICollection>。  
  
 項目<xref:System.Collections.ICollection>的值為相同的順序排序<xref:System.Collections.SortedList>。  
  
 這個屬性是類似<xref:System.Collections.SortedList.GetValueList%2A>方法，但傳回<xref:System.Collections.ICollection>物件，而不是<xref:System.Collections.IList>物件。  
  
 這個方法是 o （1） 作業。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.SortedList.Keys" />
        <altmember cref="M:System.Collections.SortedList.GetValueList" />
      </Docs>
    </Member>
  </Members>
</Type>