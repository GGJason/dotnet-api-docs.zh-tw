<Type Name="DictionaryBase" FullName="System.Collections.DictionaryBase">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2f2b93f1950d4c01486461510f5ca9d9fccede73" /><Meta Name="ms.sourcegitcommit" Value="3f21796619d6e69ad383c958cc013ce44c0678de" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="02/11/2019" /><Meta Name="ms.locfileid" Value="56054667" /></Metadata><TypeSignature Language="C#" Value="public abstract class DictionaryBase : System.Collections.IDictionary" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit DictionaryBase extends System.Object implements class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.DictionaryBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class DictionaryBase&#xA;Implements IDictionary" />
  <TypeSignature Language="C++ CLI" Value="public ref class DictionaryBase abstract : System::Collections::IDictionary" />
  <TypeSignature Language="F#" Value="type DictionaryBase = class&#xA;    interface IDictionary&#xA;    interface ICollection&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.NonGeneric</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供索引鍵/值組配對強式集合的 <see langword="abstract" /> 基底類別。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks

> [!IMPORTANT]
>  我們不建議您改用`DictionaryBase`開發新的類別。 相反地，我們建議您先使用一般<xref:System.Collections.Generic.Dictionary%602>或<xref:System.Collections.ObjectModel.KeyedCollection%602>類別。 如需詳細資訊，請參閱 <<c0> [ 不應使用非泛型集合](https://github.com/dotnet/platform-compat/blob/master/docs/DE0006.md)GitHub 上。

C# [Foreach](~/docs/csharp/language-reference/keywords/foreach-in.md)陳述式和 Visual Basic[每個](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md)陳述式傳回集合中的項目類型的物件。 因為每個項目的<xref:System.Collections.DictionaryBase>是索引鍵/值組，項目型別不是索引鍵的類型或值的類型。 相反地，項目型別是<xref:System.Collections.DictionaryEntry>。  
  
 `foreach`陳述式是一個包裝函式只允許讀取，不寫入至集合的列舉值。  
  
> [!NOTE]
>  因為可繼承索引鍵，並變更其行為，其絕對唯一性無法保證使用比較<xref:System.Type.Equals%2A>方法。  
  
   
  
## Examples  
 下列程式碼範例會實作<xref:System.Collections.DictionaryBase>類別，並會使用該實作來建立的字典<xref:System.String>索引鍵和值具有<xref:System.String.Length%2A>5 個字元以內。  
  
 [!code-cpp[System.Collections.DictionaryBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/dictionarybase.cpp#1)]
 [!code-csharp[System.Collections.DictionaryBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/dictionarybase.cs#1)]
 [!code-vb[System.Collections.DictionaryBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/dictionarybase.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>公用靜態 (<see langword="Shared" /> Visual Basic 中) 的這種類型的成員都是安全執行緒。 不保證任何執行個體成員是安全執行緒。  
  
此實作不提供的同步處理 （安全執行緒） 包裝函式<see cref="T:System.Collections.DictionaryBase" />，但是在衍生的類別可以建立他們自己的同步處理的版本<see cref="T:System.Collections.DictionaryBase" />使用<see cref="P:System.Collections.ICollection.SyncRoot" />屬性。  
  
透過集合進行列舉在本質上並非安全執行緒程序。 即使集合經過同步化，其他的執行緒仍可修改該集合，使列舉值擲回例外狀況。 若要保證列舉過程的執行緒安全，您可以在整個列舉過程中鎖定集合，或攔截由其他執行緒的變更所造成的例外狀況。</threadsafe>
    <block subset="none" type="overrides"><para>這個基底類別可簡化實作器建立的強類型的自訂集合。 實作者會擴充這個基底類別，而不是建立自己的建議。  
  
這個基底類別的成員會受到保護，旨在透過衍生類別。</para></block>
    <altmember cref="T:System.Collections.Hashtable" />
    <altmember cref="T:System.Collections.IDictionary" />
    <altmember cref="N:System.Collections.Generic" />
    <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations.md">執行不區分文化特性的字串作業</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DictionaryBase ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DictionaryBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Collections.DictionaryBase" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個建構函式是 o （1） 的作業。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="dictionaryBase.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>清除 <see cref="T:System.Collections.DictionaryBase" /> 執行個體的內容。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.DictionaryBase.Count%2A> 是設為零，並且從項目集合中的其他物件的參考也釋出。  
  
 這個方法是 O (`n`) 運算，其中`n`是<xref:System.Collections.DictionaryBase.Count%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int index);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="dictionaryBase.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">一維 <see cref="T:System.Array" />，是從 <see cref="T:System.Collections.DictionaryEntry" /> 執行個體複製過來的 <see cref="T:System.Collections.DictionaryBase" /> 物件之目的端。 <see cref="T:System.Array" /> 必須有以零為起始的索引。</param>
        <param name="index"><paramref name="array" /> 中以零起始的索引，即開始複製的位置。</param>
        <summary>將 <see cref="T:System.Collections.DictionaryBase" /> 元素複製到指定索引的一維 <see cref="T:System.Array" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 將元素複製到<xref:System.Array>所在的列舉值逐一查看的順序相同<xref:System.Collections.DictionaryBase>。  
  
 這個方法是 O (`n`) 運算，其中`n`是<xref:System.Collections.DictionaryBase.Count%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小於零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> 是多維的。  
  
-或- 
來源 <see cref="T:System.Collections.DictionaryBase" /> 中的項目數大於 <paramref name="index" /> 到目的 <paramref name="array" /> 結尾的可用空間。</exception>
        <exception cref="T:System.InvalidCastException">來源 <see cref="T:System.Collections.DictionaryBase" /> 的類型無法自動轉換成目的 <paramref name="array" /> 的類型。</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Collections.DictionaryEntry" />
        <altmember cref="M:System.Collections.DictionaryBase.GetEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.DictionaryBase.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.DictionaryBase.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得包含在 <see cref="T:System.Collections.DictionaryBase" /> 執行個體中的項目數目。</summary>
        <value>包含在 <see cref="T:System.Collections.DictionaryBase" /> 執行個體中的項目數目。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 擷取這個屬性的值是一種 O(1) 運算。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dictionary">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary Dictionary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Dictionary" />
      <MemberSignature Language="DocId" Value="P:System.Collections.DictionaryBase.Dictionary" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Dictionary As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ Dictionary { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Dictionary : System.Collections.IDictionary" Usage="System.Collections.DictionaryBase.Dictionary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得包含於 <see cref="T:System.Collections.DictionaryBase" /> 執行個體中的元素清單。</summary>
        <value><see cref="T:System.Collections.IDictionary" /> 表示 <see cref="T:System.Collections.DictionaryBase" /> 執行個體本身。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 只有在所傳回的執行個體上叫用 On * 方法<xref:System.Collections.DictionaryBase.Dictionary%2A>屬性，但不是能在所傳回的執行個體<xref:System.Collections.DictionaryBase.InnerHashtable%2A>屬性。  
  
 擷取這個屬性的值是一種 O(1) 運算。  
  
   
  
## Examples  
 下列程式碼範例會實作<xref:System.Collections.DictionaryBase>類別，並會使用該實作來建立的字典<xref:System.String>索引鍵和值具有<xref:System.String.Length%2A>5 個字元以內。  
  
 [!code-cpp[System.Collections.DictionaryBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/dictionarybase.cpp#1)]
 [!code-csharp[System.Collections.DictionaryBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/dictionarybase.cs#1)]
 [!code-vb[System.Collections.DictionaryBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/dictionarybase.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionaryEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IDictionaryEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionaryEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator" Usage="dictionaryBase.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回能夠逐一查看 <see cref="T:System.Collections.IDictionaryEnumerator" /> 執行個體的 <see cref="T:System.Collections.DictionaryBase" />。</summary>
        <returns><see cref="T:System.Collections.IDictionaryEnumerator" /> 執行個體的 <see cref="T:System.Collections.DictionaryBase" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 C# 語言的 `foreach` 陳述式 (在 Visual Basic 中為 `for each`) 會隱藏列舉值的複雜度。  因此，建議您使用 `foreach`，而不要直接使用列舉值。  
  
 列舉程式可以用來讀取集合中的資料，但是無法用來修改基礎集合。  
  
 一開始，列舉程式位在集合中的第一個項目之前。 <xref:System.Collections.IEnumerator.Reset%2A> 也會將列舉值帶回至這個位置。  在這個位置上，<xref:System.Collections.IEnumerator.Current%2A> 並未定義。 因此，在讀取 <xref:System.Collections.IEnumerator.MoveNext%2A> 的值之前，必須呼叫 <xref:System.Collections.IEnumerator.Current%2A> 以將列舉值前移至集合的第一個項目。  
  
 <xref:System.Collections.IEnumerator.Current%2A> 會傳回相同的物件直到呼叫 <xref:System.Collections.IEnumerator.MoveNext%2A> 或 <xref:System.Collections.IEnumerator.Reset%2A>。 <xref:System.Collections.IEnumerator.MoveNext%2A> 會將 <xref:System.Collections.IEnumerator.Current%2A> 設定為下一個項目。  
  
 如果<xref:System.Collections.IEnumerator.MoveNext%2A>集合，也就是列舉值的結尾是否位於集合中的最後一個元素之後的階段和<xref:System.Collections.IEnumerator.MoveNext%2A>傳回`false`。 列舉值位於此位置，後續呼叫<xref:System.Collections.IEnumerator.MoveNext%2A>也會傳回`false`。 如果上次呼叫<xref:System.Collections.IEnumerator.MoveNext%2A>傳回`false`，<xref:System.Collections.IEnumerator.Current%2A>是未定義。 若要再次將 <xref:System.Collections.IEnumerator.Current%2A> 設定為集合的第一個元素，您可以在呼叫 <xref:System.Collections.IEnumerator.Reset%2A> 之後，接著呼叫 <xref:System.Collections.IEnumerator.MoveNext%2A>。  
  
 只要集合維持不變，列舉程式就持續有效。 如果對集合進行變更，例如加入、修改或刪除項目，列舉程式會永久失效，且其行為未定義。  
  
 列舉程式沒有集合的獨佔存取權，因此，列舉集合內容本質上並不是安全的執行緒程序。  若要確保列舉期間的執行緒安全性，您可以在整個列舉期間鎖定集合。  若要讓多重執行緒能夠存取集合以便進行讀取和寫入，您必須實作自己的同步處理。  
  
 這個方法是 o （1） 作業。  
  
   
  
## Examples  
 下列程式碼範例會實作<xref:System.Collections.DictionaryBase>類別，並會使用該實作來建立的字典<xref:System.String>索引鍵和值具有<xref:System.String.Length%2A>5 個字元以內。  
  
 [!code-cpp[System.Collections.DictionaryBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/dictionarybase.cpp#1)]
 [!code-csharp[System.Collections.DictionaryBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/dictionarybase.cs#1)]
 [!code-vb[System.Collections.DictionaryBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/dictionarybase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="InnerHashtable">
      <MemberSignature Language="C#" Value="protected System.Collections.Hashtable InnerHashtable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Hashtable InnerHashtable" />
      <MemberSignature Language="DocId" Value="P:System.Collections.DictionaryBase.InnerHashtable" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property InnerHashtable As Hashtable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::Hashtable ^ InnerHashtable { System::Collections::Hashtable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InnerHashtable : System.Collections.Hashtable" Usage="System.Collections.DictionaryBase.InnerHashtable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得包含於 <see cref="T:System.Collections.DictionaryBase" /> 執行個體中的元素清單。</summary>
        <value>表示 <see cref="T:System.Collections.Hashtable" /> 執行個體本身的 <see cref="T:System.Collections.DictionaryBase" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 只有在所傳回的執行個體上叫用 On * 方法<xref:System.Collections.DictionaryBase.Dictionary%2A>屬性，但不是能在所傳回的執行個體<xref:System.Collections.DictionaryBase.InnerHashtable%2A>屬性。  
  
 擷取這個屬性的值是一種 O(1) 運算。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnClear">
      <MemberSignature Language="C#" Value="protected virtual void OnClear ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.OnClear" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClear ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClear();" />
      <MemberSignature Language="F#" Value="abstract member OnClear : unit -&gt; unit&#xA;override this.OnClear : unit -&gt; unit" Usage="dictionaryBase.OnClear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在清除 <see cref="T:System.Collections.DictionaryBase" /> 執行個體的內容前，執行額外的自訂處理序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法的預設實作是由衍生類別中清除集合之前，執行某些動作覆寫。  
  
 只有在所傳回的執行個體上叫用 On * 方法<xref:System.Collections.DictionaryBase.Dictionary%2A>屬性，但不是能在所傳回的執行個體<xref:System.Collections.DictionaryBase.InnerHashtable%2A>屬性。  
  
 這個方法的預設實作是 o （1） 作業。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>這個方法可讓實作器定義必須刪除所有項目從基礎之前執行的處理序<see cref="T:System.Collections.Hashtable" />。 藉由定義這個方法，實作者可以將功能加入繼承的方法而不需要覆寫所有其他方法。  
  
 <see cref="M:System.Collections.DictionaryBase.OnClear" /> 之前叫用標準的清除行為，而<see cref="M:System.Collections.DictionaryBase.OnClearComplete" />標準清除行為之後叫用。  
  
例如，實作者可以免除從全域清除刪除的特定項目。</para></block>
        <altmember cref="M:System.Collections.DictionaryBase.OnClearComplete" />
        <altmember cref="M:System.Collections.DictionaryBase.OnRemove(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OnClearComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnClearComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClearComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.OnClearComplete" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClearComplete ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClearComplete();" />
      <MemberSignature Language="F#" Value="abstract member OnClearComplete : unit -&gt; unit&#xA;override this.OnClearComplete : unit -&gt; unit" Usage="dictionaryBase.OnClearComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在清除 <see cref="T:System.Collections.DictionaryBase" /> 執行個體的內容後，執行額外的自訂處理序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法的預設實作是由執行某些動作之後在清除集合, 的衍生類別覆寫。  
  
 只有在所傳回的執行個體上叫用 On * 方法<xref:System.Collections.DictionaryBase.Dictionary%2A>屬性，但不是能在所傳回的執行個體<xref:System.Collections.DictionaryBase.InnerHashtable%2A>屬性。  
  
 這個方法的預設實作是 o （1） 作業。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>這個方法可讓實作器定義必須刪除所有項目從基礎之後執行的處理序<see cref="T:System.Collections.Hashtable" />。 藉由定義這個方法，實作者可以將功能加入繼承的方法而不需要覆寫所有其他方法。  
  
 <see cref="M:System.Collections.DictionaryBase.OnClear" /> 之前叫用標準的清除行為，而<see cref="M:System.Collections.DictionaryBase.OnClearComplete" />標準清除行為之後叫用。</para></block>
        <altmember cref="M:System.Collections.DictionaryBase.OnClear" />
        <altmember cref="M:System.Collections.DictionaryBase.OnRemoveComplete(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OnGet">
      <MemberSignature Language="C#" Value="protected virtual object OnGet (object key, object currentValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object OnGet(object key, object currentValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.OnGet(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnGet (key As Object, currentValue As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ OnGet(System::Object ^ key, System::Object ^ currentValue);" />
      <MemberSignature Language="F#" Value="abstract member OnGet : obj * obj -&gt; obj&#xA;override this.OnGet : obj * obj -&gt; obj" Usage="dictionaryBase.OnGet (key, currentValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="currentValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">要取得的元素索引鍵。</param>
        <param name="currentValue">與 <paramref name="key" /> 關聯之元素的目前值。</param>
        <summary>取得 <see cref="T:System.Collections.DictionaryBase" /> 執行個體中具有指定索引鍵和值的元素。</summary>
        <returns><see cref="T:System.Object" /> 包含的元素具有指定的索引鍵和值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法的預設實作會傳回`currentValue`。 它被要覆寫由衍生類別中，擷取指定的項目時執行其他動作。  
  
 只有在所傳回的執行個體上叫用 On * 方法<xref:System.Collections.DictionaryBase.Dictionary%2A>屬性，但不是能在所傳回的執行個體<xref:System.Collections.DictionaryBase.InnerHashtable%2A>屬性。  
  
 這個方法的預設實作是 o （1） 作業。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>這個方法可讓實作者定義執行基礎的標準 Get 行為時，必須執行的處理序<see cref="T:System.Collections.Hashtable" />。 藉由定義這個方法，實作者可以將功能加入繼承的方法而不需要覆寫所有其他方法。  
  
 <see cref="M:System.Collections.DictionaryBase.OnGet(System.Object,System.Object)" /> 可用來指定處理程序執行之前傳回的值擷取自基礎<see cref="T:System.Collections.Hashtable" />。 例如，實作者可以將值轉換成其他型別再加以傳回。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnInsert">
      <MemberSignature Language="C#" Value="protected virtual void OnInsert (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInsert(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.OnInsert(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInsert (key As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInsert(System::Object ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member OnInsert : obj * obj -&gt; unit&#xA;override this.OnInsert : obj * obj -&gt; unit" Usage="dictionaryBase.OnInsert (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">要插入的元素索引鍵。</param>
        <param name="value">要插入的元素值。</param>
        <summary>在將新的元素插入至 <see cref="T:System.Collections.DictionaryBase" /> 執行個體前，執行額外的自訂處理序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法的預設實作是由執行某些動作之前插入指定的項目在衍生類別覆寫。  
  
 只有在所傳回的執行個體上叫用 On * 方法<xref:System.Collections.DictionaryBase.Dictionary%2A>屬性，但不是能在所傳回的執行個體<xref:System.Collections.DictionaryBase.InnerHashtable%2A>屬性。  
  
 這個方法的預設實作是 o （1） 作業。  
  
   
  
## Examples  
 下列程式碼範例會實作<xref:System.Collections.DictionaryBase>類別，並會使用該實作來建立的字典<xref:System.String>索引鍵和值具有<xref:System.String.Length%2A>5 個字元以內。  
  
 [!code-cpp[System.Collections.DictionaryBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/dictionarybase.cpp#1)]
 [!code-csharp[System.Collections.DictionaryBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/dictionarybase.cs#1)]
 [!code-vb[System.Collections.DictionaryBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/dictionarybase.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>這個方法可讓實作者定義的基礎時，插入項目之前必須先執行處理序<see cref="T:System.Collections.Hashtable" />。 藉由定義這個方法，實作者可以將功能加入繼承的方法而不需要覆寫所有其他方法。  
  
 <see cref="M:System.Collections.DictionaryBase.OnInsert(System.Object,System.Object)" /> 之前叫用標準的插入行為，而<see cref="M:System.Collections.DictionaryBase.OnInsertComplete(System.Object,System.Object)" />叫用標準的 「 插入 」 行為之後。  
  
例如，實作者可以限制哪些類型的物件可以插入至<see cref="T:System.Collections.Hashtable" />。</para></block>
        <altmember cref="M:System.Collections.DictionaryBase.OnInsertComplete(System.Object,System.Object)" />
        <altmember cref="M:System.Collections.DictionaryBase.OnSet(System.Object,System.Object,System.Object)" />
        <altmember cref="M:System.Collections.DictionaryBase.OnValidate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OnInsertComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnInsertComplete (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInsertComplete(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.OnInsertComplete(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInsertComplete (key As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInsertComplete(System::Object ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member OnInsertComplete : obj * obj -&gt; unit&#xA;override this.OnInsertComplete : obj * obj -&gt; unit" Usage="dictionaryBase.OnInsertComplete (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">要插入的元素索引鍵。</param>
        <param name="value">要插入的元素值。</param>
        <summary>在將新的元素插入至 <see cref="T:System.Collections.DictionaryBase" /> 執行個體後，執行額外的自訂處理序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法的預設實作是由插入指定的項目後，執行某些動作的衍生類別覆寫。  
  
 只有在所傳回的執行個體上叫用 On * 方法<xref:System.Collections.DictionaryBase.Dictionary%2A>屬性，但不是能在所傳回的執行個體<xref:System.Collections.DictionaryBase.InnerHashtable%2A>屬性。  
  
 這個方法的預設實作是 o （1） 作業。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>這個方法可讓實作者定義的元素插入基礎後必須執行的處理序<see cref="T:System.Collections.Hashtable" />。 藉由定義這個方法，實作者可以將功能加入繼承的方法而不需要覆寫所有其他方法。  
  
 <see cref="M:System.Collections.DictionaryBase.OnInsert(System.Object,System.Object)" /> 之前叫用標準的插入行為，而<see cref="M:System.Collections.DictionaryBase.OnInsertComplete(System.Object,System.Object)" />叫用標準的 「 插入 」 行為之後。</para></block>
        <altmember cref="M:System.Collections.DictionaryBase.OnInsert(System.Object,System.Object)" />
        <altmember cref="M:System.Collections.DictionaryBase.OnSetComplete(System.Object,System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OnRemove">
      <MemberSignature Language="C#" Value="protected virtual void OnRemove (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRemove(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.OnRemove(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRemove (key As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRemove(System::Object ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member OnRemove : obj * obj -&gt; unit&#xA;override this.OnRemove : obj * obj -&gt; unit" Usage="dictionaryBase.OnRemove (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">要移除之項目的名稱。</param>
        <param name="value">要移除的元素值。</param>
        <summary>在從 <see cref="T:System.Collections.DictionaryBase" /> 執行個體移除元素前，執行額外的自訂處理序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法的預設實作是由衍生類別中移除指定的項目之前，執行某些動作覆寫。  
  
 只有在所傳回的執行個體上叫用 On * 方法<xref:System.Collections.DictionaryBase.Dictionary%2A>屬性，但不是能在所傳回的執行個體<xref:System.Collections.DictionaryBase.InnerHashtable%2A>屬性。  
  
 這個方法的預設實作是 o （1） 作業。  
  
   
  
## Examples  
 下列程式碼範例會實作<xref:System.Collections.DictionaryBase>類別，並會使用該實作來建立的字典<xref:System.String>索引鍵和值具有<xref:System.String.Length%2A>5 個字元以內。  
  
 [!code-cpp[System.Collections.DictionaryBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/dictionarybase.cpp#1)]
 [!code-csharp[System.Collections.DictionaryBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/dictionarybase.cs#1)]
 [!code-vb[System.Collections.DictionaryBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/dictionarybase.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>這個方法可讓實作者定義的基礎移除項目之前必須先執行的處理序<see cref="T:System.Collections.Hashtable" />。 藉由定義這個方法，實作者可以將功能加入繼承的方法而不需要覆寫所有其他方法。  
  
 <see cref="M:System.Collections.DictionaryBase.OnRemove(System.Object,System.Object)" /> 之前叫用標準的移除行為，而<see cref="M:System.Collections.DictionaryBase.OnRemoveComplete(System.Object,System.Object)" />標準移除行為之後叫用。  
  
例如，實作者可以避免移除的項目中一律擲回例外狀況<see cref="M:System.Collections.DictionaryBase.OnRemove(System.Object,System.Object)" />。</para></block>
        <altmember cref="M:System.Collections.DictionaryBase.OnRemoveComplete(System.Object,System.Object)" />
        <altmember cref="M:System.Collections.DictionaryBase.OnClear" />
      </Docs>
    </Member>
    <Member MemberName="OnRemoveComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnRemoveComplete (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRemoveComplete(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.OnRemoveComplete(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRemoveComplete (key As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRemoveComplete(System::Object ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member OnRemoveComplete : obj * obj -&gt; unit&#xA;override this.OnRemoveComplete : obj * obj -&gt; unit" Usage="dictionaryBase.OnRemoveComplete (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">要移除之項目的名稱。</param>
        <param name="value">要移除的元素值。</param>
        <summary>在從 <see cref="T:System.Collections.DictionaryBase" /> 執行個體移除元素後，執行額外的自訂處理序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法的預設實作是由衍生類別中移除指定的項目後，執行某些動作覆寫。  
  
 只有在所傳回的執行個體上叫用 On * 方法<xref:System.Collections.DictionaryBase.Dictionary%2A>屬性，但不是能在所傳回的執行個體<xref:System.Collections.DictionaryBase.InnerHashtable%2A>屬性。  
  
 這個方法的預設實作是 o （1） 作業。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>這個方法可讓實作者定義移除項目從基礎後必須執行的處理序<see cref="T:System.Collections.Hashtable" />。 藉由定義這個方法，實作者可以將功能加入繼承的方法而不需要覆寫所有其他方法。  
  
 <see cref="M:System.Collections.DictionaryBase.OnRemove(System.Object,System.Object)" /> 之前叫用標準的移除行為，而<see cref="M:System.Collections.DictionaryBase.OnRemoveComplete(System.Object,System.Object)" />標準移除行為之後叫用。</para></block>
        <altmember cref="M:System.Collections.DictionaryBase.OnRemove(System.Object,System.Object)" />
        <altmember cref="M:System.Collections.DictionaryBase.OnClearComplete" />
      </Docs>
    </Member>
    <Member MemberName="OnSet">
      <MemberSignature Language="C#" Value="protected virtual void OnSet (object key, object oldValue, object newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSet(object key, object oldValue, object newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.OnSet(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSet (key As Object, oldValue As Object, newValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSet(System::Object ^ key, System::Object ^ oldValue, System::Object ^ newValue);" />
      <MemberSignature Language="F#" Value="abstract member OnSet : obj * obj * obj -&gt; unit&#xA;override this.OnSet : obj * obj * obj -&gt; unit" Usage="dictionaryBase.OnSet (key, oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="oldValue" Type="System.Object" />
        <Parameter Name="newValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">要尋找的元素索引鍵。</param>
        <param name="oldValue">與 <paramref name="key" /> 關聯之元素的舊值。</param>
        <param name="newValue">與 <paramref name="key" /> 關聯之元素的新值。</param>
        <summary>在 <see cref="T:System.Collections.DictionaryBase" /> 執行個體中設定數值前，執行額外的自訂處理序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法的預設實作是由執行某些動作，就會設定指定的項目在衍生類別覆寫。  
  
 只有在所傳回的執行個體上叫用 On * 方法<xref:System.Collections.DictionaryBase.Dictionary%2A>屬性，但不是能在所傳回的執行個體<xref:System.Collections.DictionaryBase.InnerHashtable%2A>屬性。  
  
 這個方法的預設實作是 o （1） 作業。  
  
   
  
## Examples  
 下列程式碼範例會實作<xref:System.Collections.DictionaryBase>類別，並會使用該實作來建立的字典<xref:System.String>索引鍵和值具有<xref:System.String.Length%2A>5 個字元以內。  
  
 [!code-cpp[System.Collections.DictionaryBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/dictionarybase.cpp#1)]
 [!code-csharp[System.Collections.DictionaryBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/dictionarybase.cs#1)]
 [!code-vb[System.Collections.DictionaryBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/dictionarybase.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>這個方法可讓實作器定義必須在基礎，設定指定的項目之前，先執行的處理序<see cref="T:System.Collections.Hashtable" />。 藉由定義這個方法，實作者可以將功能加入繼承的方法而不需要覆寫所有其他方法。  
  
 <see cref="M:System.Collections.DictionaryBase.OnSet(System.Object,System.Object,System.Object)" /> 之前叫用標準設定的行為，而<see cref="M:System.Collections.DictionaryBase.OnSetComplete(System.Object,System.Object,System.Object)" />叫用後設定的標準行為。  
  
例如，實作者可以限制哪些值將會覆寫執行內檢查<see cref="M:System.Collections.DictionaryBase.OnSet(System.Object,System.Object,System.Object)" />。</para></block>
        <altmember cref="M:System.Collections.DictionaryBase.OnSetComplete(System.Object,System.Object,System.Object)" />
        <altmember cref="M:System.Collections.DictionaryBase.OnInsert(System.Object,System.Object)" />
        <altmember cref="M:System.Collections.DictionaryBase.OnValidate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OnSetComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnSetComplete (object key, object oldValue, object newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSetComplete(object key, object oldValue, object newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.OnSetComplete(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSetComplete (key As Object, oldValue As Object, newValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSetComplete(System::Object ^ key, System::Object ^ oldValue, System::Object ^ newValue);" />
      <MemberSignature Language="F#" Value="abstract member OnSetComplete : obj * obj * obj -&gt; unit&#xA;override this.OnSetComplete : obj * obj * obj -&gt; unit" Usage="dictionaryBase.OnSetComplete (key, oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="oldValue" Type="System.Object" />
        <Parameter Name="newValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">要尋找的元素索引鍵。</param>
        <param name="oldValue">與 <paramref name="key" /> 關聯之元素的舊值。</param>
        <param name="newValue">與 <paramref name="key" /> 關聯之元素的新值。</param>
        <summary>在 <see cref="T:System.Collections.DictionaryBase" /> 執行個體中設定數值後，執行額外的自訂處理序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法的預設實作是由衍生類別設定指定的項目之後，執行某些動作覆寫。  
  
 只有在所傳回的執行個體上叫用 On * 方法<xref:System.Collections.DictionaryBase.Dictionary%2A>屬性，但不是能在所傳回的執行個體<xref:System.Collections.DictionaryBase.InnerHashtable%2A>屬性。  
  
 這個方法的預設實作是 o （1） 作業。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>這個方法可讓實作器定義必須在基礎，設定指定的項目之後執行的處理序<see cref="T:System.Collections.Hashtable" />。 藉由定義這個方法，實作者可以將功能加入繼承的方法而不需要覆寫所有其他方法。  
  
 <see cref="M:System.Collections.DictionaryBase.OnSet(System.Object,System.Object,System.Object)" /> 之前叫用標準設定的行為，而<see cref="M:System.Collections.DictionaryBase.OnSetComplete(System.Object,System.Object,System.Object)" />叫用後設定的標準行為。</para></block>
        <altmember cref="M:System.Collections.DictionaryBase.OnSet(System.Object,System.Object,System.Object)" />
        <altmember cref="M:System.Collections.DictionaryBase.OnInsertComplete(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OnValidate">
      <MemberSignature Language="C#" Value="protected virtual void OnValidate (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnValidate(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.OnValidate(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnValidate (key As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnValidate(System::Object ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member OnValidate : obj * obj -&gt; unit&#xA;override this.OnValidate : obj * obj -&gt; unit" Usage="dictionaryBase.OnValidate (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">要驗證的元素索引鍵。</param>
        <param name="value">要驗證的元素值。</param>
        <summary>在使用指定的索引鍵及值驗證元素時，執行額外的自訂處理序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法的預設實作是由衍生的類別，以執行某些動作，驗證指定的項目時覆寫。  
  
 只有在所傳回的執行個體上叫用 On * 方法<xref:System.Collections.DictionaryBase.Dictionary%2A>屬性，但不是能在所傳回的執行個體<xref:System.Collections.DictionaryBase.InnerHashtable%2A>屬性。  
  
 這個方法的預設實作是 o （1） 作業。  
  
   
  
## Examples  
 下列程式碼範例會實作<xref:System.Collections.DictionaryBase>類別，並會使用該實作來建立的字典<xref:System.String>索引鍵和值具有<xref:System.String.Length%2A>5 個字元以內。  
  
 [!code-cpp[System.Collections.DictionaryBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/dictionarybase.cpp#1)]
 [!code-csharp[System.Collections.DictionaryBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/dictionarybase.cs#1)]
 [!code-vb[System.Collections.DictionaryBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/dictionarybase.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>這個方法可讓實作者定義執行基礎的標準行為時，必須執行的處理序<see cref="T:System.Collections.Hashtable" />。 藉由定義這個方法，實作者可以將功能加入繼承的方法而不需要覆寫所有其他方法。  
  
 <see cref="M:System.Collections.DictionaryBase.OnValidate(System.Object,System.Object)" /> 可用來加諸於接受插入集合的物件類型的限制。 預設實作可防止<see langword="null" />無法加入或移除從基礎<see cref="T:System.Collections.Hashtable" />。</para></block>
        <altmember cref="M:System.Collections.DictionaryBase.OnSet(System.Object,System.Object,System.Object)" />
        <altmember cref="M:System.Collections.DictionaryBase.OnInsert(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.DictionaryBase.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出對 <see cref="T:System.Collections.DictionaryBase" /> 物件的存取是否為同步的 (執行緒安全)。</summary>
        <value>如果是同步 (執行緒安全) 存取 <see cref="T:System.Collections.DictionaryBase" /> 物件則為 <see langword="true" />，否則為 <see langword="false" />。 預設為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Collections.DictionaryBase>物件未同步處理。 在衍生的類別可以提供的同步處理的版本<xref:System.Collections.DictionaryBase>類別使用<xref:System.Collections.ICollection.SyncRoot%2A>屬性。  
  
 透過集合進行列舉在本質上並非安全執行緒程序。 即使集合經過同步化，其他的執行緒仍可修改該集合，使列舉值擲回例外狀況。 若要保證列舉過程的執行緒安全，您可以在整個列舉過程中鎖定集合，或攔截由其他執行緒的變更所造成的例外狀況。  
  
   
  
## Examples  
 下列程式碼範例示範如何鎖定集合使用<xref:System.Collections.ICollection.SyncRoot%2A>在整個列舉過程的屬性。  
  
 [!code-cpp[System.Collections.DictionaryBase#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/source2.cpp#3)]
 [!code-csharp[System.Collections.DictionaryBase#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/source2.cs#3)]
 [!code-vb[System.Collections.DictionaryBase#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/source2.vb#3)]  
  
 擷取這個屬性的值是一種 O(1) 運算。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)" />
        <altmember cref="P:System.Collections.ICollection.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.DictionaryBase.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得可用來同步存取 <see cref="T:System.Collections.DictionaryBase" /> 物件的物件。</summary>
        <value>可用來同步處理對 <see cref="T:System.Collections.DictionaryBase" /> 物件之存取的物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在衍生的類別可以提供自己的同步處理的版本<xref:System.Collections.DictionaryBase>類別使用<xref:System.Collections.ICollection.SyncRoot%2A>屬性。 同步處理的程式碼必須執行作業<xref:System.Collections.ICollection.SyncRoot%2A>的屬性<xref:System.Collections.DictionaryBase>物件，不要直接依賴<xref:System.Collections.DictionaryBase>物件。 如此可確保衍生自其他物件的集合可以正常運作， 具體來說，它會維護適當的同步處理的其他執行緒可能同時修改<xref:System.Collections.DictionaryBase>物件。  
  
 透過集合進行列舉在本質上並非安全執行緒程序。 即使集合經過同步化，其他的執行緒仍可修改該集合，使列舉值擲回例外狀況。 若要保證列舉過程的執行緒安全，您可以在整個列舉過程中鎖定集合，或攔截由其他執行緒的變更所造成的例外狀況。  
  
   
  
## Examples  
 下列程式碼範例示範如何鎖定集合使用<xref:System.Collections.ICollection.SyncRoot%2A>在整個列舉過程的屬性。  
  
 [!code-cpp[System.Collections.DictionaryBase#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/source2.cpp#3)]
 [!code-csharp[System.Collections.DictionaryBase#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/source2.cs#3)]
 [!code-vb[System.Collections.DictionaryBase#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/source2.vb#3)]  
  
 擷取這個屬性的值是一種 O(1) 運算。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.IsSynchronized" />
        <altmember cref="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Add">
      <MemberSignature Language="C#" Value="void IDictionary.Add (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IDictionary.Add(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.System#Collections#IDictionary#Add(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Add (key As Object, value As Object) Implements IDictionary.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IDictionary.Add(System::Object ^ key, System::Object ^ value) = System::Collections::IDictionary::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Add(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">要加入的項目的索引鍵。</param>
        <param name="value">要加入的項目的值。</param>
        <summary>將有指定索引鍵和數值的項目加入 <see cref="T:System.Collections.DictionaryBase" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 具有其狀態和其雜湊碼值之間沒有相互關聯的物件通常不應做為索引鍵。 例如，<xref:System.String>物件都是優於<xref:System.Text.StringBuilder>用於做為索引鍵的物件。  
  
 您也可以使用<xref:System.Collections.IDictionary.Item%2A>屬性來設定索引鍵的值加入新項目不存在於<xref:System.Collections.DictionaryBase>; 例如， `myCollection["myNonexistentKey"] = myValue`。 不過，如果指定的索引鍵已存在於<xref:System.Collections.DictionaryBase>，將<xref:System.Collections.IDictionary.Item%2A>屬性會覆寫舊的值。 相反地，<xref:System.Collections.IDictionary.Add%2A>方法不會修改現有的項目。  
  
 這個方法是 o （1） 作業。  
  
   
  
## Examples  
 下列程式碼範例會實作<xref:System.Collections.DictionaryBase>類別，並會使用該實作來建立的字典<xref:System.String>索引鍵和值具有<xref:System.String.Length%2A>5 個字元以內。  
  
 [!code-cpp[System.Collections.DictionaryBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/dictionarybase.cpp#1)]
 [!code-csharp[System.Collections.DictionaryBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/dictionarybase.cs#1)]
 [!code-vb[System.Collections.DictionaryBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/dictionarybase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><see cref="T:System.Collections.DictionaryBase" /> 中已存在具有相同索引鍵的元素。</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.DictionaryBase" /> 是唯讀的。  
  
-或- 
<see cref="T:System.Collections.DictionaryBase" /> 具有固定的大小。</exception>
        <altmember cref="M:System.Collections.IDictionary.Remove(System.Object)" />
        <altmember cref="P:System.Collections.IDictionary.Item(System.Object)" />
        <altmember cref="M:System.Collections.IDictionary.Add(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Contains">
      <MemberSignature Language="C#" Value="bool IDictionary.Contains (object key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IDictionary.Contains(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.System#Collections#IDictionary#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (key As Object) As Boolean Implements IDictionary.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IDictionary.Contains(System::Object ^ key) = System::Collections::IDictionary::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">要在 <see cref="T:System.Collections.DictionaryBase" /> 中尋找的索引鍵。</param>
        <summary>判斷 <see cref="T:System.Collections.DictionaryBase" /> 是否包含特定索引鍵。</summary>
        <returns>如果 <see langword="true" /> 包含具有指定索引鍵的項目，則為 <see cref="T:System.Collections.DictionaryBase" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法是 o （1） 作業。  
  
 從.NET Framework 2.0 開始，這個方法會使用集合的物件<xref:System.Object.Equals%2A>並<xref:System.IComparable.CompareTo%2A>上的方法`key`來判斷是否`item`存在。 在舊版的.NET Framework 中，藉由進行這項判斷<xref:System.Object.Equals%2A>並<xref:System.IComparable.CompareTo%2A>方法`key`參數集合中的物件。  
  
   
  
## Examples  
 下列程式碼範例會實作<xref:System.Collections.DictionaryBase>類別，並會使用該實作來建立的字典<xref:System.String>索引鍵和值具有<xref:System.String.Length%2A>5 個字元以內。  
  
 [!code-cpp[System.Collections.DictionaryBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/dictionarybase.cpp#1)]
 [!code-csharp[System.Collections.DictionaryBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/dictionarybase.cs#1)]
 [!code-vb[System.Collections.DictionaryBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/dictionarybase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations.md">執行不區分文化特性的字串作業</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IDictionary.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IDictionary.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.DictionaryBase.System#Collections#IDictionary#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IDictionary.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IDictionary::IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Collections.DictionaryBase" /> 物件是否具有固定的大小。</summary>
        <value>如果 <see cref="T:System.Collections.DictionaryBase" /> 物件有固定大小，則為 <see langword="true" />，否則為 <see langword="false" />。 預設為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 具有固定大小的集合不允許新增或移除項目集合會建立，但不允許修改現有的項目之後。  
  
 具有固定大小集合是唯讀的集合只會防止新增和移除項目; 的包裝函式因此，如果變更基礎的集合，包括新增或移除項目，固定大小的集合會反映這些變更。  
  
 擷取這個屬性的值是一種 O(1) 運算。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IDictionary.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IDictionary.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.DictionaryBase.System#Collections#IDictionary#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IDictionary.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IDictionary::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Collections.DictionaryBase" /> 物件是否為唯讀。</summary>
        <value>如果 <see cref="T:System.Collections.DictionaryBase" /> 物件是唯讀，則為 <see langword="true" />，否則為 <see langword="false" />。 預設為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 唯讀的集合不允許在集合建立後增加、移除或修改項目。  
  
 是唯讀的集合是可防止修改集合的包裝函式集合因此，如果基礎集合進行變更，唯讀的集合會反映這些變更。  
  
 擷取這個屬性的值是一種 O(1) 運算。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IDictionary.Item[object key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IDictionary.Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.DictionaryBase.System#Collections#IDictionary#Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(key As Object) As Object Implements IDictionary.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IDictionary::Item[System::Object ^] { System::Object ^ get(System::Object ^ key); void set(System::Object ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Item(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">索引鍵，要讀取或設定其值。</param>
        <summary>取得或設定和指定索引鍵關聯的值。</summary>
        <value>與指定索引鍵關聯的值。 如果找不到指定的索引鍵，嘗試取得將傳回 <see langword="null" />，並且嘗試設定會使用指定的索引鍵建立新的元素。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性可以使用下列語法提供存取集合中特定元素的能力：`myCollection[key]`。  
  
 您也可以使用<xref:System.Collections.IDictionary.Item%2A>屬性來設定索引鍵的值加入新項目不存在於<xref:System.Collections.DictionaryBase>; 例如， `myCollection["myNonexistentKey"] = myValue`。 不過，如果指定的索引鍵已存在於<xref:System.Collections.DictionaryBase>，將<xref:System.Collections.IDictionary.Item%2A>屬性會覆寫舊的值。 相反地，<xref:System.Collections.IDictionary.Add%2A>方法不會修改現有的項目。  
  
 擷取這個屬性的值是 o （1） 的作業;設定屬性，也是 o （1） 作業。  
  
   
  
## Examples  
 下列程式碼範例會實作<xref:System.Collections.DictionaryBase>類別，並會使用該實作來建立的字典<xref:System.String>索引鍵和值具有<xref:System.String.Length%2A>5 個字元以內。  
  
 [!code-cpp[System.Collections.DictionaryBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/dictionarybase.cpp#1)]
 [!code-csharp[System.Collections.DictionaryBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/dictionarybase.cs#1)]
 [!code-vb[System.Collections.DictionaryBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/dictionarybase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">屬性已設定，而且 <see cref="T:System.Collections.DictionaryBase" /> 是唯讀的。  
  
-或- 
屬性已設定，<paramref name="key" /> 不存在於集合中，而且 <see cref="T:System.Collections.DictionaryBase" /> 具有固定大小。</exception>
        <altmember cref="M:System.Collections.IDictionary.Add(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Keys">
      <MemberSignature Language="C#" Value="System.Collections.ICollection System.Collections.IDictionary.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection System.Collections.IDictionary.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.DictionaryBase.System#Collections#IDictionary#Keys" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Keys As ICollection Implements IDictionary.Keys" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::ICollection ^ System::Collections::IDictionary::Keys { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Collections.ICollection" /> 物件，其中包含 <see cref="T:System.Collections.DictionaryBase" /> 物件中的索引鍵。</summary>
        <value><see cref="T:System.Collections.ICollection" /> 物件，其中包含 <see cref="T:System.Collections.DictionaryBase" /> 物件中的索引鍵。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中的索引鍵的順序<xref:System.Collections.ICollection>物件是否未指定，但中相關聯的值時的相同順序<xref:System.Collections.ICollection>所傳回的物件<xref:System.Collections.IDictionary.Values%2A>屬性。  
  
 傳回<xref:System.Collections.ICollection>不是靜態的複本; 相反地，<xref:System.Collections.ICollection>原始中的索引鍵是指回<xref:System.Collections.DictionaryBase>物件。 因此，變更<xref:System.Collections.DictionaryBase>繼續會反映在傳回<xref:System.Collections.ICollection>。  
  
 擷取這個屬性的值是一種 O(1) 運算。  
  
   
  
## Examples  
 下列程式碼範例會實作<xref:System.Collections.DictionaryBase>類別，並會使用該實作來建立的字典<xref:System.String>索引鍵和值具有<xref:System.String.Length%2A>的 5 個字元或更少的屬性。  
  
 [!code-cpp[System.Collections.DictionaryBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/dictionarybase.cpp#1)]
 [!code-csharp[System.Collections.DictionaryBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/dictionarybase.cs#1)]
 [!code-vb[System.Collections.DictionaryBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/dictionarybase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.IDictionary.Values" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Remove">
      <MemberSignature Language="C#" Value="void IDictionary.Remove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IDictionary.Remove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.System#Collections#IDictionary#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (key As Object) Implements IDictionary.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IDictionary.Remove(System::Object ^ key) = System::Collections::IDictionary::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">要移除之項目的名稱。</param>
        <summary>將有指定索引鍵的元素從 <see cref="T:System.Collections.DictionaryBase" /> 移除。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Collections.DictionaryBase>不包含具有指定之索引鍵的項目<xref:System.Collections.DictionaryBase>會維持不變。 不會有例外狀況擲回。  
  
 這個方法是 o （1） 作業。  
  
   
  
## Examples  
 下列程式碼範例會實作<xref:System.Collections.DictionaryBase>類別，並會使用該實作來建立的字典<xref:System.String>索引鍵和值具有<xref:System.String.Length%2A>5 個字元以內。  
  
 [!code-cpp[System.Collections.DictionaryBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/dictionarybase.cpp#1)]
 [!code-csharp[System.Collections.DictionaryBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/dictionarybase.cs#1)]
 [!code-vb[System.Collections.DictionaryBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/dictionarybase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.DictionaryBase" /> 是唯讀的。  
  
-或- 
<see cref="T:System.Collections.DictionaryBase" /> 具有固定的大小。</exception>
        <altmember cref="M:System.Collections.IDictionary.Add(System.Object,System.Object)" />
        <altmember cref="M:System.Collections.IDictionary.Remove(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations.md">執行不區分文化特性的字串作業</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Values">
      <MemberSignature Language="C#" Value="System.Collections.ICollection System.Collections.IDictionary.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection System.Collections.IDictionary.Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.DictionaryBase.System#Collections#IDictionary#Values" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Values As ICollection Implements IDictionary.Values" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::ICollection ^ System::Collections::IDictionary::Values { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Collections.ICollection" /> 物件，其中含有 <see cref="T:System.Collections.DictionaryBase" /> 物件中的值。</summary>
        <value><see cref="T:System.Collections.ICollection" /> 物件，其中含有 <see cref="T:System.Collections.DictionaryBase" /> 物件中的值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中的值順序<xref:System.Collections.ICollection>物件並未指定，但會做為相關聯的索引鍵中的相同順序<xref:System.Collections.ICollection>所傳回的物件<xref:System.Collections.IDictionary.Keys%2A>屬性。  
  
 傳回<xref:System.Collections.ICollection>不是靜態的複本; 相反地，<xref:System.Collections.ICollection>中原始的值是指回<xref:System.Collections.DictionaryBase>物件。 因此，變更<xref:System.Collections.DictionaryBase>繼續會反映在傳回<xref:System.Collections.ICollection>。  
  
 擷取這個屬性的值是一種 O(1) 運算。  
  
   
  
## Examples  
 下列程式碼範例會實作<xref:System.Collections.DictionaryBase>類別，並會使用該實作來建立的字典<xref:System.String>索引鍵和值具有<xref:System.String.Length%2A>的 5 個字元或更少的屬性。  
  
 [!code-cpp[System.Collections.DictionaryBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CPP/dictionarybase.cpp#1)]
 [!code-csharp[System.Collections.DictionaryBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.DictionaryBase/CS/dictionarybase.cs#1)]
 [!code-vb[System.Collections.DictionaryBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.DictionaryBase/VB/dictionarybase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.IDictionary.Keys" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.DictionaryBase.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回透過 <see cref="T:System.Collections.IEnumerator" /> 重複的 <see cref="T:System.Collections.DictionaryBase" />。</summary>
        <returns>
  <see cref="T:System.Collections.IEnumerator" /> 的 <see cref="T:System.Collections.DictionaryBase" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 C# 語言的 `foreach` 陳述式 (在 Visual Basic 中為 `for each`) 會隱藏列舉值的複雜度。 因此，建議您使用 `foreach`，而不要直接使用列舉值。  
  
 列舉程式可以用來讀取集合中的資料，但是無法用來修改基礎集合。  
  
 一開始，列舉程式位在集合中的第一個項目之前。 <xref:System.Collections.IEnumerator.Reset%2A> 也會將列舉值帶回至這個位置。 在這個位置上，呼叫<xref:System.Collections.IEnumerator.Current%2A>會擲回例外狀況。 因此，在讀取 <xref:System.Collections.IEnumerator.MoveNext%2A> 的值之前，必須呼叫 <xref:System.Collections.IEnumerator.Current%2A> 以將列舉值前移至集合的第一個項目。  
  
 <xref:System.Collections.IEnumerator.Current%2A> 會傳回相同的物件直到呼叫 <xref:System.Collections.IEnumerator.MoveNext%2A> 或 <xref:System.Collections.IEnumerator.Reset%2A>。 <xref:System.Collections.IEnumerator.MoveNext%2A> 會將 <xref:System.Collections.IEnumerator.Current%2A> 設定為下一個項目。  
  
 如果<xref:System.Collections.IEnumerator.MoveNext%2A>集合，也就是列舉值的結尾是否位於集合中的最後一個元素之後的階段和<xref:System.Collections.IEnumerator.MoveNext%2A>傳回`false`。 列舉值位於此位置，後續呼叫<xref:System.Collections.IEnumerator.MoveNext%2A>也會傳回`false`。 如果上次呼叫<xref:System.Collections.IEnumerator.MoveNext%2A>傳回`false`，則呼叫<xref:System.Collections.IEnumerator.Current%2A>會擲回例外狀況。 若要再次將 <xref:System.Collections.IEnumerator.Current%2A> 設定為集合的第一個元素，您可以在呼叫 <xref:System.Collections.IEnumerator.Reset%2A> 之後，接著呼叫 <xref:System.Collections.IEnumerator.MoveNext%2A>。  
  
 只要集合維持不變，列舉程式就持續有效。 如果變更集合，例如加入、 修改或刪除元素，列舉值會將永久失效，而且下次呼叫<xref:System.Collections.IEnumerator.MoveNext%2A>或是<xref:System.Collections.IEnumerator.Reset%2A>就會擲回<xref:System.InvalidOperationException>。 如果集合已修改之間<xref:System.Collections.IEnumerator.MoveNext%2A>並<xref:System.Collections.IEnumerator.Current%2A>，<xref:System.Collections.IEnumerator.Current%2A>傳回設定為，項目，即使已經無效列舉值。  
  
 列舉程式沒有集合的獨佔存取權，因此，列舉集合內容本質上並不是安全的執行緒程序。 即使集合經過同步化，其他的執行緒仍可修改該集合，使列舉值擲回例外狀況。 若要保證列舉過程的執行緒安全，您可以在整個列舉過程中鎖定集合，或攔截由其他執行緒的變更所造成的例外狀況。  
  
 這個方法是 o （1） 作業。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
  </Members>
</Type>