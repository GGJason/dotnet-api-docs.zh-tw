<Type Name="AssemblyLoadContext" FullName="System.Runtime.Loader.AssemblyLoadContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="1fe12898361e808786693310aaf210145e2d3f9a" /><Meta Name="ms.sourcegitcommit" Value="9a6da88bd5455e8274257ca7ad259b42f1de114f" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="05/22/2019" /><Meta Name="ms.locfileid" Value="66007901" /></Metadata><TypeSignature Language="C#" Value="public abstract class AssemblyLoadContext" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit AssemblyLoadContext extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Loader.AssemblyLoadContext" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class AssemblyLoadContext" />
  <TypeSignature Language="C++ CLI" Value="public ref class AssemblyLoadContext abstract" />
  <TypeSignature Language="F#" Value="type AssemblyLoadContext = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Loader</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="d26f9-101">代表繫結範圍的執行階段概念。</span><span class="sxs-lookup"><span data-stu-id="d26f9-101">Represents the runtime's concept of a scope for binding.</span></span> <span data-ttu-id="d26f9-102">這個類別是抽象的。</span><span class="sxs-lookup"><span data-stu-id="d26f9-102">This class is abstract.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="d26f9-103"><xref:System.Runtime.Loader.AssemblyLoadContext>表示載入內容。</span><span class="sxs-lookup"><span data-stu-id="d26f9-103">The <xref:System.Runtime.Loader.AssemblyLoadContext> represents a load context.</span></span> <span data-ttu-id="d26f9-104">就概念而言，載入內容會建立和載入、 解決，可能會卸載組件集合的範圍。</span><span class="sxs-lookup"><span data-stu-id="d26f9-104">Conceptually, a load context creates a scope for loading, resolving, and potentially unloading a set of assemblies.</span></span>
 
 <span data-ttu-id="d26f9-105"><xref:System.Runtime.Loader.AssemblyLoadContext>這是抽象類別。</span><span class="sxs-lookup"><span data-stu-id="d26f9-105"><xref:System.Runtime.Loader.AssemblyLoadContext> is an abstract class.</span></span> <span data-ttu-id="d26f9-106"><xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType>需要建立的具象類別實作。</span><span class="sxs-lookup"><span data-stu-id="d26f9-106">The <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType> needs to be implemented to create a concrete class.</span></span>
 
 <span data-ttu-id="d26f9-107"><xref:System.Runtime.Loader.AssemblyLoadContext>存在主要是為了提供組件繫結隔離。</span><span class="sxs-lookup"><span data-stu-id="d26f9-107">The <xref:System.Runtime.Loader.AssemblyLoadContext> exists primarily to provide assembly binding isolation.</span></span> <span data-ttu-id="d26f9-108">它可讓多個要在單一處理序載入相同組件版本。</span><span class="sxs-lookup"><span data-stu-id="d26f9-108">It allows multiple versions of the same assembly to be loaded within a single process.</span></span> <span data-ttu-id="d26f9-109">它會取代多個所提供的隔離機制<xref:System.AppDomain>.NET Framework 中的執行個體。</span><span class="sxs-lookup"><span data-stu-id="d26f9-109">It replaces the isolation mechanisms provided by multiple <xref:System.AppDomain> instances in the .NET Framework.</span></span>
 
 > [!NOTE]
 > <span data-ttu-id="d26f9-110"><xref:System.Runtime.Loader.AssemblyLoadContext> 不提供任何安全性功能。</span><span class="sxs-lookup"><span data-stu-id="d26f9-110"><xref:System.Runtime.Loader.AssemblyLoadContext> does not provide any security features.</span></span> <span data-ttu-id="d26f9-111">所有的程式碼具有完整權限的程序。</span><span class="sxs-lookup"><span data-stu-id="d26f9-111">All code has full permissions of the process.</span></span>

### <a name="usage-in-the-runtime"></a><span data-ttu-id="d26f9-112">在執行階段的使用方式</span><span class="sxs-lookup"><span data-stu-id="d26f9-112">Usage in the runtime</span></span>
 <span data-ttu-id="d26f9-113">執行階段會實作兩個組件載入內容：</span><span class="sxs-lookup"><span data-stu-id="d26f9-113">The runtime implements two assembly load contexts:</span></span>
 * <span data-ttu-id="d26f9-114"><xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> 表示執行階段的預設繫結內容用於應用程式主要組件和其靜態的相依性。</span><span class="sxs-lookup"><span data-stu-id="d26f9-114"><xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> represents the runtime's default binding context which is used for the application main assembly and its static dependencies.</span></span>
 * <span data-ttu-id="d26f9-115"><xref:System.Reflection.Assembly.LoadFile(System.String)?displayProperty=nameWithType>方法會隔離載入具現化最基本的組件<xref:System.Runtime.Loader.AssemblyLoadContext>。</span><span class="sxs-lookup"><span data-stu-id="d26f9-115">The <xref:System.Reflection.Assembly.LoadFile(System.String)?displayProperty=nameWithType> method isolates the assemblies it loads by instantiating the most basic <xref:System.Runtime.Loader.AssemblyLoadContext>.</span></span> <span data-ttu-id="d26f9-116">它會載入在它自己的每個組件簡單的隔離配置<xref:System.Runtime.Loader.AssemblyLoadContext>沒有相依性解析。</span><span class="sxs-lookup"><span data-stu-id="d26f9-116">It has a simplistic isolation scheme which loads each assembly in its own <xref:System.Runtime.Loader.AssemblyLoadContext> with no dependency resolution.</span></span>
 
### <a name="application-usage"></a><span data-ttu-id="d26f9-117">應用程式使用量</span><span class="sxs-lookup"><span data-stu-id="d26f9-117">Application usage</span></span>
 <span data-ttu-id="d26f9-118">應用程式可以建立自己<xref:System.Runtime.Loader.AssemblyLoadContext>來建立進階繫結案例自訂解決方案。</span><span class="sxs-lookup"><span data-stu-id="d26f9-118">An application can create its own <xref:System.Runtime.Loader.AssemblyLoadContext> to create a custom solution for advanced binding scenarios.</span></span> <span data-ttu-id="d26f9-119">自訂著重於定義相依性解析機制。</span><span class="sxs-lookup"><span data-stu-id="d26f9-119">The customization focuses on defining dependency resolution mechanisms.</span></span>
 
 <span data-ttu-id="d26f9-120"><xref:System.Runtime.Loader.AssemblyLoadContext>提供實作的 managed 組件解析的兩個擴充點：</span><span class="sxs-lookup"><span data-stu-id="d26f9-120">The <xref:System.Runtime.Loader.AssemblyLoadContext> provides two extension points to implement managed assembly resolution:</span></span>
 1. <span data-ttu-id="d26f9-121"><xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType>提供的第一個機會<xref:System.Runtime.Loader.AssemblyLoadContext>解析組件，請將其載入，並將它傳回。</span><span class="sxs-lookup"><span data-stu-id="d26f9-121">The <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType> provides the first chance for the <xref:System.Runtime.Loader.AssemblyLoadContext> to resolve the assembly, load it and return it.</span></span> <span data-ttu-id="d26f9-122">如果<xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType>會傳回`null`，則載入器會嘗試將組件載入<xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d26f9-122">If the <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType> returns `null`, the loader will try to load the assembly into the <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>.</span></span>
 2. <span data-ttu-id="d26f9-123">如果<xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>無法解析組件中，原始<xref:System.Runtime.Loader.AssemblyLoadContext>取得解析組件的第二次機會。</span><span class="sxs-lookup"><span data-stu-id="d26f9-123">If the <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> is unable to resolve the assembly, the original <xref:System.Runtime.Loader.AssemblyLoadContext> gets a second chance to resolve the assembly.</span></span> <span data-ttu-id="d26f9-124">執行階段會引發<xref:System.Runtime.Loader.AssemblyLoadContext.Resolving>事件。</span><span class="sxs-lookup"><span data-stu-id="d26f9-124">The runtime raises the <xref:System.Runtime.Loader.AssemblyLoadContext.Resolving> event.</span></span>
 
 <span data-ttu-id="d26f9-125">此外<xref:System.Runtime.Loader.AssemblyLoadContext.LoadUnmanagedDll(System.String)?displayProperty=nameWithType>虛擬方法可讓自訂的預設非受控組件解析。</span><span class="sxs-lookup"><span data-stu-id="d26f9-125">Additionally the <xref:System.Runtime.Loader.AssemblyLoadContext.LoadUnmanagedDll(System.String)?displayProperty=nameWithType> virtual method allows customization of the default unmanaged assembly resolution.</span></span> <span data-ttu-id="d26f9-126">預設實作會傳回`null`，因而導致執行階段搜尋，以使用預設搜尋原則即足以應付大部分的情況。</span><span class="sxs-lookup"><span data-stu-id="d26f9-126">The default implementation returns `null`, which causes the runtime search to use its default search policy which is sufficient for most scenarios.</span></span>

### <a name="technical-challenges"></a><span data-ttu-id="d26f9-127">技術難題</span><span class="sxs-lookup"><span data-stu-id="d26f9-127">Technical challenges</span></span>
 * <span data-ttu-id="d26f9-128">您不可能載入多個單一處理序中的執行階段版本。</span><span class="sxs-lookup"><span data-stu-id="d26f9-128">It is not possible to load multiple versions of the runtime in a single process.</span></span>
     > [!CAUTION]
     > <span data-ttu-id="d26f9-129">載入多個複本或不同版本的 framework 組件可能會導致非預期且很難診斷的行為。</span><span class="sxs-lookup"><span data-stu-id="d26f9-129">Loading multiple copies or different versions of framework assemblies can lead to unexpected and hard to diagnose behavior.</span></span>
     
     > [!TIP]
     > <span data-ttu-id="d26f9-130">使用遠端處理和/或處理序間通訊的處理序界限，若要解決此隔離問題。</span><span class="sxs-lookup"><span data-stu-id="d26f9-130">Use process boundaries with remoting and/or interprocess communication to solve this isolation problem.</span></span>
 
 * <span data-ttu-id="d26f9-131">組件載入的時間可能會使測試和偵錯困難。</span><span class="sxs-lookup"><span data-stu-id="d26f9-131">The timing of assembly loading can make testing and debugging difficult.</span></span> <span data-ttu-id="d26f9-132">組件會載入通常不需立即解決其相依性。</span><span class="sxs-lookup"><span data-stu-id="d26f9-132">Assemblies are typically loaded without their dependencies immediately being resolved.</span></span> <span data-ttu-id="d26f9-133">如有需要會載入相依性：</span><span class="sxs-lookup"><span data-stu-id="d26f9-133">The dependencies are loaded as they are needed:</span></span>
     * <span data-ttu-id="d26f9-134">當程式碼會分支到相依的組件。</span><span class="sxs-lookup"><span data-stu-id="d26f9-134">When code branches into a dependent assembly.</span></span>
     * <span data-ttu-id="d26f9-135">當程式碼會載入資源。</span><span class="sxs-lookup"><span data-stu-id="d26f9-135">When code loads resources.</span></span>
     * <span data-ttu-id="d26f9-136">當程式碼，明確地載入組件。</span><span class="sxs-lookup"><span data-stu-id="d26f9-136">When code explicitly loads assemblies.</span></span>
 
 * <span data-ttu-id="d26f9-137">實作<xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType>可以加入新的相依性，這可能需要被隔離，以允許存在的不同版本。</span><span class="sxs-lookup"><span data-stu-id="d26f9-137">The implementation of <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType> can add new dependencies which may need to be isolated to allow different versions to exist.</span></span> <span data-ttu-id="d26f9-138">在預設內容中，最自然的實作會將這些相依性。</span><span class="sxs-lookup"><span data-stu-id="d26f9-138">The most natural implementation would place these dependencies in the default context.</span></span> <span data-ttu-id="d26f9-139">謹慎設計，可以區隔新的相依性。</span><span class="sxs-lookup"><span data-stu-id="d26f9-139">Careful design can isolate the new dependencies.</span></span>
 
 * <span data-ttu-id="d26f9-140">繫結隔離程序會建立多個類型，具有相同的型別名稱。</span><span class="sxs-lookup"><span data-stu-id="d26f9-140">The binding isolation process creates multiple types with the same type name.</span></span>
     * <span data-ttu-id="d26f9-141">這可能會導致容易產生混淆的錯誤訊息，例如"Foo.Foo 類型無法轉換成輸入 Foo.Foo。 」</span><span class="sxs-lookup"><span data-stu-id="d26f9-141">This can lead to confusing error messages, for example "type Foo.Foo cannot be cast to type Foo.Foo."</span></span>
     * <span data-ttu-id="d26f9-142">跨越隔離界限封送處理是重要的。</span><span class="sxs-lookup"><span data-stu-id="d26f9-142">Marshaling across isolation boundaries is non-trivial.</span></span> <span data-ttu-id="d26f9-143">典型的解決方案是使用只載入預設載入內容之組件中定義的介面。</span><span class="sxs-lookup"><span data-stu-id="d26f9-143">A typical solution would be to use an interface defined in an assembly which is only loaded into the default load context.</span></span>
 
 ]]></format>
    </remarks>
    <related type="Article" href="https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/assemblyloadcontext.md"><span data-ttu-id="d26f9-144">AssemblyLoadContext CoreCLR 的設計文件</span><span class="sxs-lookup"><span data-stu-id="d26f9-144">AssemblyLoadContext CoreCLR design document</span></span></related>
    <related type="Article" href="~/docs/standard/assembly/unloadability-howto.md"><span data-ttu-id="d26f9-145">如何使用及偵錯.NET Core 中的組件 unloadability</span><span class="sxs-lookup"><span data-stu-id="d26f9-145">How to use and debug assembly unloadability in .NET Core</span></span></related>
    <related type="Article" href="https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/unloadability.md"><span data-ttu-id="d26f9-146">AssemblyLoadContext unloadability 設計文件</span><span class="sxs-lookup"><span data-stu-id="d26f9-146">AssemblyLoadContext unloadability design document</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected AssemblyLoadContext ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; AssemblyLoadContext();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d26f9-147">初始化 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="d26f9-147">Initializes a new instance of the <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="d26f9-148">這個建構函式受到保護。</span><span class="sxs-lookup"><span data-stu-id="d26f9-148">This constructor is protected.</span></span> <span data-ttu-id="d26f9-149">它只能從呼叫<xref:System.Runtime.Loader.AssemblyLoadContext>類別或其衍生的類別。</span><span class="sxs-lookup"><span data-stu-id="d26f9-149">It can only be called from the <xref:System.Runtime.Loader.AssemblyLoadContext> class or its derived classes.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected AssemblyLoadContext (bool isCollectible);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(bool isCollectible) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (isCollectible As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; AssemblyLoadContext(bool isCollectible);" />
      <MemberSignature Language="F#" Value="new System.Runtime.Loader.AssemblyLoadContext : bool -&gt; System.Runtime.Loader.AssemblyLoadContext" Usage="new System.Runtime.Loader.AssemblyLoadContext isCollectible" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="isCollectible" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="isCollectible"><span data-ttu-id="d26f9-150"><see langword="true" /> 以啟用記憶體回收；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d26f9-150"><see langword="true" /> to enable garbage collection; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="d26f9-151">使用指出是否已啟用記憶體回收的值來初始化 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="d26f9-151">Initializes a new instance of the <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> class with a value that indicates whether garbage collection is enabled.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AssemblyLoadContext (string name, bool isCollectible = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, bool isCollectible) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, Optional isCollectible As Boolean = false)" />
      <MemberSignature Language="F#" Value="new System.Runtime.Loader.AssemblyLoadContext : string * bool -&gt; System.Runtime.Loader.AssemblyLoadContext" Usage="new System.Runtime.Loader.AssemblyLoadContext (name, isCollectible)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="isCollectible" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="isCollectible">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="All">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Runtime.Loader.AssemblyLoadContext&gt; All { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Collections.Generic.IEnumerable`1&lt;class System.Runtime.Loader.AssemblyLoadContext&gt; All" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Loader.AssemblyLoadContext.All" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property All As IEnumerable(Of AssemblyLoadContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Collections::Generic::IEnumerable&lt;System::Runtime::Loader::AssemblyLoadContext ^&gt; ^ All { System::Collections::Generic::IEnumerable&lt;System::Runtime::Loader::AssemblyLoadContext ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.All : seq&lt;System.Runtime.Loader.AssemblyLoadContext&gt;" Usage="System.Runtime.Loader.AssemblyLoadContext.All" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Runtime.Loader.AssemblyLoadContext&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Assemblies">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt; Assemblies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Assembly&gt; Assemblies" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Loader.AssemblyLoadContext.Assemblies" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Assemblies As IEnumerable(Of Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Reflection::Assembly ^&gt; ^ Assemblies { System::Collections::Generic::IEnumerable&lt;System::Reflection::Assembly ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assemblies : seq&lt;System.Reflection.Assembly&gt;" Usage="System.Runtime.Loader.AssemblyLoadContext.Assemblies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentContextualReflectionContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Loader.AssemblyLoadContext CurrentContextualReflectionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Loader.AssemblyLoadContext CurrentContextualReflectionContext" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Loader.AssemblyLoadContext.CurrentContextualReflectionContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentContextualReflectionContext As AssemblyLoadContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Loader::AssemblyLoadContext ^ CurrentContextualReflectionContext { System::Runtime::Loader::AssemblyLoadContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentContextualReflectionContext : System.Runtime.Loader.AssemblyLoadContext" Usage="System.Runtime.Loader.AssemblyLoadContext.CurrentContextualReflectionContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Loader.AssemblyLoadContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Runtime.Loader.AssemblyLoadContext Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Loader.AssemblyLoadContext Default" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Loader.AssemblyLoadContext.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As AssemblyLoadContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Loader::AssemblyLoadContext ^ Default { System::Runtime::Loader::AssemblyLoadContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Runtime.Loader.AssemblyLoadContext" Usage="System.Runtime.Loader.AssemblyLoadContext.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Loader.AssemblyLoadContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d26f9-152">取得預設 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />。</span><span class="sxs-lookup"><span data-stu-id="d26f9-152">Gets the default <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />.</span></span> <span data-ttu-id="d26f9-153">預設內容包含主應用程式組件及其靜態相依性。</span><span class="sxs-lookup"><span data-stu-id="d26f9-153">The default context contains the main application assembly and its static dependencies.</span></span></summary>
        <value><span data-ttu-id="d26f9-154">預設組件載入內容。</span><span class="sxs-lookup"><span data-stu-id="d26f9-154">The default assembly load context.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnterContextualReflection">
      <MemberSignature Language="C#" Value="public System.Runtime.Loader.AssemblyLoadContext.ContextualReflectionScope EnterContextualReflection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.Loader.AssemblyLoadContext/ContextualReflectionScope EnterContextualReflection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.EnterContextualReflection" />
      <MemberSignature Language="VB.NET" Value="Public Function EnterContextualReflection () As AssemblyLoadContext.ContextualReflectionScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Loader::AssemblyLoadContext::ContextualReflectionScope EnterContextualReflection();" />
      <MemberSignature Language="F#" Value="member this.EnterContextualReflection : unit -&gt; System.Runtime.Loader.AssemblyLoadContext.ContextualReflectionScope" Usage="assemblyLoadContext.EnterContextualReflection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Loader.AssemblyLoadContext+ContextualReflectionScope</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnterContextualReflection">
      <MemberSignature Language="C#" Value="public static System.Runtime.Loader.AssemblyLoadContext.ContextualReflectionScope EnterContextualReflection (System.Reflection.Assembly activating);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Runtime.Loader.AssemblyLoadContext/ContextualReflectionScope EnterContextualReflection(class System.Reflection.Assembly activating) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.EnterContextualReflection(System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnterContextualReflection (activating As Assembly) As AssemblyLoadContext.ContextualReflectionScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Loader::AssemblyLoadContext::ContextualReflectionScope EnterContextualReflection(System::Reflection::Assembly ^ activating);" />
      <MemberSignature Language="F#" Value="static member EnterContextualReflection : System.Reflection.Assembly -&gt; System.Runtime.Loader.AssemblyLoadContext.ContextualReflectionScope" Usage="System.Runtime.Loader.AssemblyLoadContext.EnterContextualReflection activating" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Loader.AssemblyLoadContext+ContextualReflectionScope</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activating" Type="System.Reflection.Assembly" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="activating">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblyName">
      <MemberSignature Language="C#" Value="public static System.Reflection.AssemblyName GetAssemblyName (string assemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.AssemblyName GetAssemblyName(string assemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.GetAssemblyName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAssemblyName (assemblyPath As String) As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::AssemblyName ^ GetAssemblyName(System::String ^ assemblyPath);" />
      <MemberSignature Language="F#" Value="static member GetAssemblyName : string -&gt; System.Reflection.AssemblyName" Usage="System.Runtime.Loader.AssemblyLoadContext.GetAssemblyName assemblyPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyPath"><span data-ttu-id="d26f9-155">組件的路徑。</span><span class="sxs-lookup"><span data-stu-id="d26f9-155">The path to the assembly.</span></span></param>
        <summary><span data-ttu-id="d26f9-156">取得組件路徑的 <see cref="T:System.Reflection.AssemblyName" />。</span><span class="sxs-lookup"><span data-stu-id="d26f9-156">Gets an <see cref="T:System.Reflection.AssemblyName" /> for an assembly path.</span></span></summary>
        <returns><span data-ttu-id="d26f9-157">物件，其包含組件 (位於 <paramref name="assemblyPath" />) 的完整剖析顯示名稱。</span><span class="sxs-lookup"><span data-stu-id="d26f9-157">An object that contains the fully parsed assembly name for the assembly at <paramref name="assemblyPath" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d26f9-158"><paramref name="assemblyPath" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d26f9-158"><paramref name="assemblyPath" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="d26f9-159">找不到組件。</span><span class="sxs-lookup"><span data-stu-id="d26f9-159">The assembly cannot be found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="d26f9-160">此組件不是有效的組件。</span><span class="sxs-lookup"><span data-stu-id="d26f9-160">The assembly is not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetLoadContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Loader.AssemblyLoadContext GetLoadContext (System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Loader.AssemblyLoadContext GetLoadContext(class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.GetLoadContext(System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Loader::AssemblyLoadContext ^ GetLoadContext(System::Reflection::Assembly ^ assembly);" />
      <MemberSignature Language="F#" Value="static member GetLoadContext : System.Reflection.Assembly -&gt; System.Runtime.Loader.AssemblyLoadContext" Usage="System.Runtime.Loader.AssemblyLoadContext.GetLoadContext assembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Loader.AssemblyLoadContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="assembly"><span data-ttu-id="d26f9-161">組件。</span><span class="sxs-lookup"><span data-stu-id="d26f9-161">An assembly.</span></span></param>
        <summary><span data-ttu-id="d26f9-162">取得 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />，其中包含指定的 <see cref="T:System.Reflection.Assembly" />。</span><span class="sxs-lookup"><span data-stu-id="d26f9-162">Gets the <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> containing the specified <see cref="T:System.Reflection.Assembly" />.</span></span></summary>
        <returns><span data-ttu-id="d26f9-163">包含 <paramref name="assembly" /> 的組件載入內容。</span><span class="sxs-lookup"><span data-stu-id="d26f9-163">The assembly load context containing the <paramref name="assembly" />.</span></span> <span data-ttu-id="d26f9-164">如果執行階段未提供 <paramref name="assembly" />，則這個方法會傳回 Null。</span><span class="sxs-lookup"><span data-stu-id="d26f9-164">If the <paramref name="assembly" /> is not provided by the runtime, this method returns null.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d26f9-165"><paramref name="assembly" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d26f9-165"><paramref name="assembly" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsCollectible">
      <MemberSignature Language="C#" Value="public bool IsCollectible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCollectible" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Loader.AssemblyLoadContext.IsCollectible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCollectible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCollectible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCollectible : bool" Usage="System.Runtime.Loader.AssemblyLoadContext.IsCollectible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d26f9-166">取得指出此 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> 是否為可回收的值。</span><span class="sxs-lookup"><span data-stu-id="d26f9-166">Gets a value that indicates whether this <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> is collectible.</span></span></summary>
        <value><span data-ttu-id="d26f9-167"><see langword="true" /> 如果這個<see cref="T:System.Runtime.Loader.AssemblyLoadContext" />可回收; 否則即為<see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d26f9-167"><see langword="true" /> if this <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> is collectible; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="d26f9-168">如果建構函式中未指定值，則值是<see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d26f9-168">If a value is not specified in the constructor, the value is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
<span data-ttu-id="d26f9-169">如需詳細資訊，請參閱 <<c0> [ 如何使用及偵錯.NET Core 中的組件 unloadability](~/docs/standard/assembly/unloadability-howto.md)。</span><span class="sxs-lookup"><span data-stu-id="d26f9-169">For more information, see [How to use and debug assembly unloadability in .NET Core](~/docs/standard/assembly/unloadability-howto.md).</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyName);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.Load assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="d26f9-170">描述要載入之組件的物件。</span><span class="sxs-lookup"><span data-stu-id="d26f9-170">The object that describes the assembly to be loaded.</span></span></param>
        <summary><span data-ttu-id="d26f9-171">在衍生類別中覆寫時，允許組件根據其 <see cref="T:System.Reflection.AssemblyName" /> 解析並載入。</span><span class="sxs-lookup"><span data-stu-id="d26f9-171">When overridden in a derived class, allows an assembly to be resolved and loaded based on its <see cref="T:System.Reflection.AssemblyName" />.</span></span></summary>
        <returns><span data-ttu-id="d26f9-172">載入的組件或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d26f9-172">The loaded assembly, or <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
 
## Remarks
 <span data-ttu-id="d26f9-173">組件解析期間<xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)>方法已載入的組件解析的組件名稱的第一個機會。</span><span class="sxs-lookup"><span data-stu-id="d26f9-173">During assembly resolution, the <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)> method has the first chance to resolve the assembly name to a loaded assembly.</span></span> <span data-ttu-id="d26f9-174">它可以載入組件，或傳回`null`。</span><span class="sxs-lookup"><span data-stu-id="d26f9-174">It can either load an assembly or return `null`.</span></span> <span data-ttu-id="d26f9-175">如果它傳回`null`，解析程序會繼續。</span><span class="sxs-lookup"><span data-stu-id="d26f9-175">If it returns `null`, the resolution process continues.</span></span> <span data-ttu-id="d26f9-176">請參閱<xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName(System.Reflection.AssemblyName)>針對完整的處理序的描述。</span><span class="sxs-lookup"><span data-stu-id="d26f9-176">See <xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName(System.Reflection.AssemblyName)> for the full process description.</span></span>
 
 > [!IMPORTANT]
 > <span data-ttu-id="d26f9-177">若要避免遞迴堆疊溢位，請勿呼叫這個執行個體的<xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName(System.Reflection.AssemblyName)>從這個方法的方法。</span><span class="sxs-lookup"><span data-stu-id="d26f9-177">To prevent recursive stack overflow, do not call this instance's <xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName(System.Reflection.AssemblyName)> method from this method.</span></span>
 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadFromAssemblyName">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromAssemblyName (System.Reflection.AssemblyName assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromAssemblyName(class System.Reflection.AssemblyName assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName(System.Reflection.AssemblyName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromAssemblyName(System::Reflection::AssemblyName ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.LoadFromAssemblyName : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.LoadFromAssemblyName assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="d26f9-178">物件，其描述要載入的組件。</span><span class="sxs-lookup"><span data-stu-id="d26f9-178">The object that describes the assembly to load.</span></span></param>
        <summary><span data-ttu-id="d26f9-179">解析並載入指定為 <see cref="T:System.Reflection.AssemblyName" /> 的組件。</span><span class="sxs-lookup"><span data-stu-id="d26f9-179">Resolves and loads an assembly given its <see cref="T:System.Reflection.AssemblyName" />.</span></span></summary>
        <returns><span data-ttu-id="d26f9-180">載入的組件或 throws。</span><span class="sxs-lookup"><span data-stu-id="d26f9-180">The loaded assembly, or throws.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="d26f9-181"><xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName%2A> 載入組件解析<xref:System.Reflection.AssemblyName>。</span><span class="sxs-lookup"><span data-stu-id="d26f9-181"><xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName%2A> loads an assembly by resolving the <xref:System.Reflection.AssemblyName>.</span></span> <span data-ttu-id="d26f9-182">這會觸發完整的解析度。</span><span class="sxs-lookup"><span data-stu-id="d26f9-182">This triggers a full resolution.</span></span> <span data-ttu-id="d26f9-183">解析後援順序會遵循此程序：1.</span><span class="sxs-lookup"><span data-stu-id="d26f9-183">The resolution fallback sequence follows this process: 1.</span></span> <span data-ttu-id="d26f9-184">方法呼叫<xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)>。</span><span class="sxs-lookup"><span data-stu-id="d26f9-184">The method calls <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)>.</span></span>
         > [!IMPORTANT]
         > <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)> must not call this method to prevent recursive stack overflow.
     2. Unless the assembly is loaded or an exception is thrown, the method attempts to load the assembly in the default <xref:System.Runtime.Loader.AssemblyLoadContext>.
     3. Unless the assembly is loaded or an exception is thrown, the method fires the <xref:System.Runtime.Loader.AssemblyLoadContext.Resolving> event.
     4. Unless the assembly is loaded or an exception is thrown, the method fires the <xref:System.AppDomain.AssemblyResolve> event.
 
 > [!NOTE]
 > <span data-ttu-id="d26f9-185"><xref:System.IO.FileLoadException> 如果擲回`assemblyRef`指定完整的組件名稱，而第一個符合的簡單名稱的組件有不相容的版本或文化特性。</span><span class="sxs-lookup"><span data-stu-id="d26f9-185"><xref:System.IO.FileLoadException> is thrown if `assemblyRef` specifies the full assembly name, and the first assembly that matches the simple name has a incompatible version or culture.</span></span> <span data-ttu-id="d26f9-186">載入器不會繼續探查比對的簡單名稱的其他組件。</span><span class="sxs-lookup"><span data-stu-id="d26f9-186">The loader does not continue probing for other assemblies that match the simple name.</span></span>
 
 <span data-ttu-id="d26f9-187">每個<xref:System.Runtime.Loader.AssemblyLoadContext>可以只載入: \* 單一可執行檔的組件版本。</span><span class="sxs-lookup"><span data-stu-id="d26f9-187">Each <xref:System.Runtime.Loader.AssemblyLoadContext> can load only: \* One version of an executable assembly.</span></span>
<span data-ttu-id="d26f9-188">\* 一個新版每個文化特性的附屬組件的詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="d26f9-188">\* One version of a satellite assembly for each culture.</span></span>
 
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d26f9-189"><paramref name="assemblyName" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d26f9-189"><paramref name="assemblyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="d26f9-190">找不到 <paramref name="assemblyName" />。</span><span class="sxs-lookup"><span data-stu-id="d26f9-190"><paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="d26f9-191"><paramref name="assemblyName" /> 不是有效的組件。</span><span class="sxs-lookup"><span data-stu-id="d26f9-191"><paramref name="assemblyName" /> is not a valid assembly.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="d26f9-192">載入的組件或模組不符合 <paramref name="assemblyName" />。</span><span class="sxs-lookup"><span data-stu-id="d26f9-192">An assembly or module was loaded which did not match the <paramref name="assemblyName" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromAssemblyPath">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromAssemblyPath (string assemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromAssemblyPath(string assemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadFromAssemblyPath (assemblyPath As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromAssemblyPath(System::String ^ assemblyPath);" />
      <MemberSignature Language="F#" Value="member this.LoadFromAssemblyPath : string -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.LoadFromAssemblyPath assemblyPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyPath"><span data-ttu-id="d26f9-193">要載入的完整檔案路徑。</span><span class="sxs-lookup"><span data-stu-id="d26f9-193">The fully qualified path of the file to load.</span></span></param>
        <summary><span data-ttu-id="d26f9-194">載入指定路徑上組件檔案的內容。</span><span class="sxs-lookup"><span data-stu-id="d26f9-194">Loads the contents of an assembly file on the specified path.</span></span></summary>
        <returns><span data-ttu-id="d26f9-195">載入的組件。</span><span class="sxs-lookup"><span data-stu-id="d26f9-195">The loaded assembly.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d26f9-196"><paramref name="assemblyPath" /> 引數不是絕對路徑。</span><span class="sxs-lookup"><span data-stu-id="d26f9-196">The <paramref name="assemblyPath" /> argument is not an absolute path.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d26f9-197"><paramref name="assemblyPath" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d26f9-197">The <paramref name="assemblyPath" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="d26f9-198">無法載入找到的檔案。</span><span class="sxs-lookup"><span data-stu-id="d26f9-198">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="d26f9-199"><paramref name="assemblyPath" /> 參數為空字串 ("") 或不存在。</span><span class="sxs-lookup"><span data-stu-id="d26f9-199">The <paramref name="assemblyPath" /> parameter is an empty string ("") or does not exist.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="d26f9-200"><paramref name="assemblyPath" /> 不是有效的組件。</span><span class="sxs-lookup"><span data-stu-id="d26f9-200"><paramref name="assemblyPath" /> is not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromNativeImagePath">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromNativeImagePath (string nativeImagePath, string assemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromNativeImagePath(string nativeImagePath, string assemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadFromNativeImagePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadFromNativeImagePath (nativeImagePath As String, assemblyPath As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromNativeImagePath(System::String ^ nativeImagePath, System::String ^ assemblyPath);" />
      <MemberSignature Language="F#" Value="member this.LoadFromNativeImagePath : string * string -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.LoadFromNativeImagePath (nativeImagePath, assemblyPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nativeImagePath" Type="System.String" />
        <Parameter Name="assemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="nativeImagePath"><span data-ttu-id="d26f9-201">要載入的完整檔案路徑。</span><span class="sxs-lookup"><span data-stu-id="d26f9-201">The fully qualified path of the file to load.</span></span></param>
        <param name="assemblyPath"><span data-ttu-id="d26f9-202">所要載入檔案之 IL 版本的完整檔案路徑或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d26f9-202">The fully qualified path of the IL version of the file to load, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="d26f9-203">載入指定路徑上受控組件檔案的原生映像內容。</span><span class="sxs-lookup"><span data-stu-id="d26f9-203">Loads the contents of the native image of a managed assembly file on the specified path.</span></span></summary>
        <returns><span data-ttu-id="d26f9-204">載入的組件。</span><span class="sxs-lookup"><span data-stu-id="d26f9-204">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="d26f9-205">Managed 組件的原生映像已預先 jit 編譯最佳化特定平台上執行。</span><span class="sxs-lookup"><span data-stu-id="d26f9-205">The native image of a managed assembly is pre-jitted to optimize running on a specific platform.</span></span>
 
 <span data-ttu-id="d26f9-206">組件路徑是指的 IL 組件的版本路徑。</span><span class="sxs-lookup"><span data-stu-id="d26f9-206">The assembly path refers to the path to the IL version of the assembly.</span></span> <span data-ttu-id="d26f9-207">IL 通常包含在原生映像，它是選擇性引數。</span><span class="sxs-lookup"><span data-stu-id="d26f9-207">It is an optional argument as the IL is typically included in the native image.</span></span> <span data-ttu-id="d26f9-208">它可供執行階段做為後援如果找不到原生映像。</span><span class="sxs-lookup"><span data-stu-id="d26f9-208">It can be used by the runtime as a fallback if the native image is not found.</span></span>
 
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d26f9-209"><paramref name="nativeImagePath" /> 引數不是絕對路徑。</span><span class="sxs-lookup"><span data-stu-id="d26f9-209">The <paramref name="nativeImagePath" /> argument is not an absolute path.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d26f9-210"><paramref name="assemblyPath" /> 引數不是絕對路徑。</span><span class="sxs-lookup"><span data-stu-id="d26f9-210">The <paramref name="assemblyPath" /> argument is not an absolute path.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d26f9-211"><paramref name="nativeImagePath" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d26f9-211">The <paramref name="nativeImagePath" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="d26f9-212">無法載入找到的檔案。</span><span class="sxs-lookup"><span data-stu-id="d26f9-212">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="d26f9-213"><paramref name="nativeImagePath" /> 參數為空字串 ("") 或不存在。</span><span class="sxs-lookup"><span data-stu-id="d26f9-213">The <paramref name="nativeImagePath" /> parameter is an empty string ("") or does not exist.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="d26f9-214"><paramref name="assemblyPath" /> 不是有效的組件。</span><span class="sxs-lookup"><span data-stu-id="d26f9-214"><paramref name="assemblyPath" /> is not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromStream">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromStream (System.IO.Stream assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromStream(class System.IO.Stream assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadFromStream(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromStream(System::IO::Stream ^ assembly);" />
      <MemberSignature Language="F#" Value="member this.LoadFromStream : System.IO.Stream -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.LoadFromStream assembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="assembly"><span data-ttu-id="d26f9-215">位元組陣列，該陣列是包含受控組件的 COFF 影像。</span><span class="sxs-lookup"><span data-stu-id="d26f9-215">A byte array that is a COFF-based image containing a managed assembly.</span></span></param>
        <summary><span data-ttu-id="d26f9-216">載入包含受控組件的通用物件檔案格式 (COFF) 映像組件。</span><span class="sxs-lookup"><span data-stu-id="d26f9-216">Loads the assembly with a common object file format (COFF)-based image containing a managed assembly.</span></span></summary>
        <returns><span data-ttu-id="d26f9-217">載入的組件。</span><span class="sxs-lookup"><span data-stu-id="d26f9-217">The loaded assembly.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d26f9-218"><paramref name="assembly" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d26f9-218"><paramref name="assembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="d26f9-219"><paramref name="assembly" /> 不是有效的組件。</span><span class="sxs-lookup"><span data-stu-id="d26f9-219"><paramref name="assembly" /> is not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromStream">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromStream (System.IO.Stream assembly, System.IO.Stream assemblySymbols);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromStream(class System.IO.Stream assembly, class System.IO.Stream assemblySymbols) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadFromStream(System.IO.Stream,System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromStream(System::IO::Stream ^ assembly, System::IO::Stream ^ assemblySymbols);" />
      <MemberSignature Language="F#" Value="member this.LoadFromStream : System.IO.Stream * System.IO.Stream -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.LoadFromStream (assembly, assemblySymbols)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.IO.Stream" />
        <Parameter Name="assemblySymbols" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="assembly"><span data-ttu-id="d26f9-220">位元組陣列，該陣列是包含受控組件的 COFF 影像。</span><span class="sxs-lookup"><span data-stu-id="d26f9-220">A byte array that is a COFF-based image containing a managed assembly.</span></span></param>
        <param name="assemblySymbols"><span data-ttu-id="d26f9-221">位元組陣列，包含表示組件符號的未經處理位元組。</span><span class="sxs-lookup"><span data-stu-id="d26f9-221">A byte array that contains the raw bytes representing the symbols for the assembly.</span></span></param>
        <summary><span data-ttu-id="d26f9-222">載入包含受控組件的通用物件檔案格式 (COFF) 映像組件，並選擇性地包含組件的符號。</span><span class="sxs-lookup"><span data-stu-id="d26f9-222">Loads the assembly with a common object file format (COFF)-based image containing a managed assembly, optionally including symbols for the assembly.</span></span></summary>
        <returns><span data-ttu-id="d26f9-223">載入的組件。</span><span class="sxs-lookup"><span data-stu-id="d26f9-223">The loaded assembly.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d26f9-224"><paramref name="assembly" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d26f9-224"><paramref name="assembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="d26f9-225"><paramref name="assembly" /> 不是有效的組件。</span><span class="sxs-lookup"><span data-stu-id="d26f9-225"><paramref name="assembly" /> is not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LoadUnmanagedDll">
      <MemberSignature Language="C#" Value="protected virtual IntPtr LoadUnmanagedDll (string unmanagedDllName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance native int LoadUnmanagedDll(string unmanagedDllName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadUnmanagedDll(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LoadUnmanagedDll (unmanagedDllName As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual IntPtr LoadUnmanagedDll(System::String ^ unmanagedDllName);" />
      <MemberSignature Language="F#" Value="abstract member LoadUnmanagedDll : string -&gt; nativeint&#xA;override this.LoadUnmanagedDll : string -&gt; nativeint" Usage="assemblyLoadContext.LoadUnmanagedDll unmanagedDllName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unmanagedDllName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="unmanagedDllName"><span data-ttu-id="d26f9-226">非受控程式庫的名稱。</span><span class="sxs-lookup"><span data-stu-id="d26f9-226">Name of the unmanaged library.</span></span> <span data-ttu-id="d26f9-227">這通常是沒有路徑或副檔名的檔案名稱。</span><span class="sxs-lookup"><span data-stu-id="d26f9-227">Typically this is the filename without its path or extensions.</span></span></param>
        <summary><span data-ttu-id="d26f9-228">允許衍生類別依名稱載入非受控程式庫。</span><span class="sxs-lookup"><span data-stu-id="d26f9-228">Allows derived class to load an unmanaged library by name.</span></span></summary>
        <returns><span data-ttu-id="d26f9-229">所載入程式庫的控制代碼或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d26f9-229">A handle to the loaded library, or <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="d26f9-230">預設實作永遠會傳回`null`。</span><span class="sxs-lookup"><span data-stu-id="d26f9-230">The default implementation always return `null`.</span></span> <span data-ttu-id="d26f9-231">當`null`會傳回執行階段載入的程式庫，其預設原則。</span><span class="sxs-lookup"><span data-stu-id="d26f9-231">When `null` is returned, the runtime loads the library with its default policy.</span></span>
 
 <span data-ttu-id="d26f9-232">可以覆寫此虛擬方法，以自訂的 unmanaged 程式庫搜尋演算法。</span><span class="sxs-lookup"><span data-stu-id="d26f9-232">This virtual method can be overridden to customize the unmanaged library search algorithm.</span></span> <span data-ttu-id="d26f9-233">覆寫時的名稱可以用來識別程式庫。</span><span class="sxs-lookup"><span data-stu-id="d26f9-233">When overridden the name can be used to identify the library.</span></span> <span data-ttu-id="d26f9-234">載入的程式庫不需要符合所要求的名稱，但可以視需要轉換。</span><span class="sxs-lookup"><span data-stu-id="d26f9-234">The loaded library does not need to match the requested name, but can be transformed as needed.</span></span> <span data-ttu-id="d26f9-235">這可能包括調整平台特定命名的名稱。</span><span class="sxs-lookup"><span data-stu-id="d26f9-235">This could include adjusting the name for platform specific naming.</span></span>
 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadUnmanagedDllFromPath">
      <MemberSignature Language="C#" Value="protected IntPtr LoadUnmanagedDllFromPath (string unmanagedDllPath);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance native int LoadUnmanagedDllFromPath(string unmanagedDllPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadUnmanagedDllFromPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Function LoadUnmanagedDllFromPath (unmanagedDllPath As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; IntPtr LoadUnmanagedDllFromPath(System::String ^ unmanagedDllPath);" />
      <MemberSignature Language="F#" Value="member this.LoadUnmanagedDllFromPath : string -&gt; nativeint" Usage="assemblyLoadContext.LoadUnmanagedDllFromPath unmanagedDllPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unmanagedDllPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="unmanagedDllPath"><span data-ttu-id="d26f9-236">非受控程式庫的路徑。</span><span class="sxs-lookup"><span data-stu-id="d26f9-236">The path to the unmanaged library.</span></span></param>
        <summary><span data-ttu-id="d26f9-237">從指定的路徑載入非受控程式庫。</span><span class="sxs-lookup"><span data-stu-id="d26f9-237">Loads an unmanaged library from the specified path.</span></span></summary>
        <returns><span data-ttu-id="d26f9-238">所載入程式庫的控制代碼。</span><span class="sxs-lookup"><span data-stu-id="d26f9-238">A handle to the loaded library.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d26f9-239"><paramref name="unmanagedDllPath" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d26f9-239"><paramref name="unmanagedDllPath" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d26f9-240"><paramref name="unmanagedDllPath" /> 引數不是絕對路徑。</span><span class="sxs-lookup"><span data-stu-id="d26f9-240">The <paramref name="unmanagedDllPath" /> argument is not an absolute path.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="d26f9-241">找不到非受控程式庫。</span><span class="sxs-lookup"><span data-stu-id="d26f9-241">The unmanaged library cannot be found.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Loader.AssemblyLoadContext.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Runtime.Loader.AssemblyLoadContext.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Resolving">
      <MemberSignature Language="C#" Value="public event Func&lt;System.Runtime.Loader.AssemblyLoadContext,System.Reflection.AssemblyName,System.Reflection.Assembly&gt; Resolving;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Func`3&lt;class System.Runtime.Loader.AssemblyLoadContext, class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; Resolving" />
      <MemberSignature Language="DocId" Value="E:System.Runtime.Loader.AssemblyLoadContext.Resolving" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Resolving As Func(Of AssemblyLoadContext, AssemblyName, Assembly) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event Func&lt;System::Runtime::Loader::AssemblyLoadContext ^, System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ Resolving;" />
      <MemberSignature Language="F#" Value="member this.Resolving : Func&lt;System.Runtime.Loader.AssemblyLoadContext, System.Reflection.AssemblyName, System.Reflection.Assembly&gt; " Usage="member this.Resolving : System.Func&lt;System.Runtime.Loader.AssemblyLoadContext, System.Reflection.AssemblyName, System.Reflection.Assembly&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;System.Runtime.Loader.AssemblyLoadContext,System.Reflection.AssemblyName,System.Reflection.Assembly&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d26f9-242">若嘗試載入至這項組件載入內容，解析組件失敗時就會發生這種情況。</span><span class="sxs-lookup"><span data-stu-id="d26f9-242">Occurs when the resolution of an assembly fails when attempting to load into this assembly load context.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="d26f9-243">傳回指定的組件，或是傳回這個事件處理常式負責`null`如果無法辨識的組件。</span><span class="sxs-lookup"><span data-stu-id="d26f9-243">It is the responsibility of the handler for this event to return the assembly that is specified, or to return `null` if the assembly is not recognized.</span></span>
 
 > [!IMPORTANT]
 >  <span data-ttu-id="d26f9-244">如果此事件註冊一個以上的事件處理常式，事件處理常式會依照順序呼叫事件處理常式傳回的值不`null`。</span><span class="sxs-lookup"><span data-stu-id="d26f9-244">If more than one event handler is registered for this event, the event handlers are called in order until an event handler returns a value that isn't `null`.</span></span> <span data-ttu-id="d26f9-245">後續的事件處理常式會被忽略。</span><span class="sxs-lookup"><span data-stu-id="d26f9-245">Subsequent event handlers are ignored.</span></span>
 
 <span data-ttu-id="d26f9-246">如需有關如何處理事件的詳細資訊，請參閱 <<c0> [ 處理和引發事件](~/docs/standard/events/index.md)。</span><span class="sxs-lookup"><span data-stu-id="d26f9-246">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>
 
 <span data-ttu-id="d26f9-247">它是值得您注意處理常式，可以加入任何此事件<xref:System.Runtime.Loader.AssemblyLoadContext>，包括預設的內容。</span><span class="sxs-lookup"><span data-stu-id="d26f9-247">It is noteworthy that a handler can be added for this event on any <xref:System.Runtime.Loader.AssemblyLoadContext>, including the default context.</span></span>
 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResolvingUnmanagedDll">
      <MemberSignature Language="C#" Value="public event Func&lt;System.Reflection.Assembly,string,IntPtr&gt; ResolvingUnmanagedDll;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Func`3&lt;class System.Reflection.Assembly, string, native int&gt; ResolvingUnmanagedDll" />
      <MemberSignature Language="DocId" Value="E:System.Runtime.Loader.AssemblyLoadContext.ResolvingUnmanagedDll" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResolvingUnmanagedDll As Func(Of Assembly, String, IntPtr) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event Func&lt;System::Reflection::Assembly ^, System::String ^, IntPtr&gt; ^ ResolvingUnmanagedDll;" />
      <MemberSignature Language="F#" Value="member this.ResolvingUnmanagedDll : Func&lt;System.Reflection.Assembly, string, nativeint&gt; " Usage="member this.ResolvingUnmanagedDll : System.Func&lt;System.Reflection.Assembly, System.string, System.nativeint&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;System.Reflection.Assembly,System.String,System.IntPtr&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetProfileOptimizationRoot">
      <MemberSignature Language="C#" Value="public void SetProfileOptimizationRoot (string directoryPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetProfileOptimizationRoot(string directoryPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.SetProfileOptimizationRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetProfileOptimizationRoot (directoryPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetProfileOptimizationRoot(System::String ^ directoryPath);" />
      <MemberSignature Language="F#" Value="member this.SetProfileOptimizationRoot : string -&gt; unit" Usage="assemblyLoadContext.SetProfileOptimizationRoot directoryPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directoryPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directoryPath">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartProfileOptimization">
      <MemberSignature Language="C#" Value="public void StartProfileOptimization (string profile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StartProfileOptimization(string profile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.StartProfileOptimization(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub StartProfileOptimization (profile As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StartProfileOptimization(System::String ^ profile);" />
      <MemberSignature Language="F#" Value="member this.StartProfileOptimization : string -&gt; unit" Usage="assemblyLoadContext.StartProfileOptimization profile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="profile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="profile">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public void Unload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Unload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.Unload" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unload ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Unload();" />
      <MemberSignature Language="F#" Value="member this.Unload : unit -&gt; unit" Usage="assemblyLoadContext.Unload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d26f9-248">起始這個 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> 的卸載。</span><span class="sxs-lookup"><span data-stu-id="d26f9-248">Initiates an unload of this <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

+ <span data-ttu-id="d26f9-249">如果是可回收，AssemblyLoadContext 只能卸載。</span><span class="sxs-lookup"><span data-stu-id="d26f9-249">An AssemblyLoadContext can only be unloaded if it is collectible.</span></span>
+ <span data-ttu-id="d26f9-250">卸載會以非同步方式發生。</span><span class="sxs-lookup"><span data-stu-id="d26f9-250">Unloading will occur asynchronously.</span></span>
+ <span data-ttu-id="d26f9-251">卸載不會發生 AssemblyLoadContext 的參考時。</span><span class="sxs-lookup"><span data-stu-id="d26f9-251">Unloading will not occur while there are references to the AssemblyLoadContext.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d26f9-252">不允許卸載。</span><span class="sxs-lookup"><span data-stu-id="d26f9-252">Unloading is not allowed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Unloading">
      <MemberSignature Language="C#" Value="public event Action&lt;System.Runtime.Loader.AssemblyLoadContext&gt; Unloading;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Action`1&lt;class System.Runtime.Loader.AssemblyLoadContext&gt; Unloading" />
      <MemberSignature Language="DocId" Value="E:System.Runtime.Loader.AssemblyLoadContext.Unloading" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloading As Action(Of AssemblyLoadContext) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event Action&lt;System::Runtime::Loader::AssemblyLoadContext ^&gt; ^ Unloading;" />
      <MemberSignature Language="F#" Value="member this.Unloading : Action&lt;System.Runtime.Loader.AssemblyLoadContext&gt; " Usage="member this.Unloading : System.Action&lt;System.Runtime.Loader.AssemblyLoadContext&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Action&lt;System.Runtime.Loader.AssemblyLoadContext&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d26f9-253">發生於卸載 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> 時。</span><span class="sxs-lookup"><span data-stu-id="d26f9-253">Occurs when the <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> is unloaded.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
