<Type Name="AssemblyLoadContext" FullName="System.Runtime.Loader.AssemblyLoadContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6209379b4106b6c91c0c89b2b8a7511fc986490a" /><Meta Name="ms.sourcegitcommit" Value="67e8bb367eab32b26025454e7769040cfb1d71c4" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="03/09/2019" /><Meta Name="ms.locfileid" Value="57701354" /></Metadata><TypeSignature Language="C#" Value="public abstract class AssemblyLoadContext" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit AssemblyLoadContext extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Loader.AssemblyLoadContext" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class AssemblyLoadContext" />
  <TypeSignature Language="C++ CLI" Value="public ref class AssemblyLoadContext abstract" />
  <TypeSignature Language="F#" Value="type AssemblyLoadContext = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Loader</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>代表繫結範圍的執行階段概念。 這個類別是抽象的。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Runtime.Loader.AssemblyLoadContext>表示載入內容。 就概念而言，載入內容會建立和載入、 解決，可能會卸載組件集合的範圍。
 
 <xref:System.Runtime.Loader.AssemblyLoadContext>這是抽象類別。 <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType>需要建立的具象類別實作。
 
 <xref:System.Runtime.Loader.AssemblyLoadContext>存在主要是為了提供組件繫結隔離。 它可讓多個要在單一處理序載入相同組件版本。 它會取代多個所提供的隔離機制<xref:System.AppDomain>.NET Framework 中的執行個體。
 
 > [!NOTE]
 > <xref:System.Runtime.Loader.AssemblyLoadContext> 不提供任何安全性功能。 所有的程式碼具有完整權限的程序。

### <a name="usage-in-the-runtime"></a>在執行階段的使用方式
 執行階段會實作兩個組件載入內容：
 * <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> 表示執行階段的預設繫結內容用於應用程式主要組件和其靜態的相依性。
 * <xref:System.Reflection.Assembly.LoadFile(System.String)?displayProperty=nameWithType>方法會隔離載入具現化最基本的組件<xref:System.Runtime.Loader.AssemblyLoadContext>。 它會載入在它自己的每個組件簡單的隔離配置<xref:System.Runtime.Loader.AssemblyLoadContext>沒有相依性解析。
 
### <a name="application-usage"></a>應用程式使用量
 應用程式可以建立自己<xref:System.Runtime.Loader.AssemblyLoadContext>來建立進階繫結案例自訂解決方案。 自訂著重於定義相依性解析機制。
 
 <xref:System.Runtime.Loader.AssemblyLoadContext>提供實作的 managed 組件解析的兩個擴充點：
 1. <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType>提供的第一個機會<xref:System.Runtime.Loader.AssemblyLoadContext>解析組件，請將其載入，並將它傳回。 如果<xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType>會傳回`null`，則載入器會嘗試將組件載入<xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>。
 2. 如果<xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>無法解析組件中，原始<xref:System.Runtime.Loader.AssemblyLoadContext>取得解析組件的第二次機會。 執行階段會引發<xref:System.Runtime.Loader.AssemblyLoadContext.Resolving>事件。
 
 此外<xref:System.Runtime.Loader.AssemblyLoadContext.LoadUnmanagedDll(System.String)?displayProperty=nameWithType>虛擬方法可讓自訂的預設非受控組件解析。 預設實作會傳回`null`，因而導致執行階段搜尋，以使用預設搜尋原則即足以應付大部分的情況。

### <a name="technical-challenges"></a>技術難題
 * 您不可能載入多個單一處理序中的執行階段版本。
     > [!CAUTION]
     > 載入多個複本或不同版本的 framework 組件可能會導致非預期且很難診斷的行為。
     
     > [!TIP]
     > 使用遠端處理和/或處理序間通訊的處理序界限，若要解決此隔離問題。
 
 * 組件載入的時間可能會使測試和偵錯困難。 組件會載入通常不需立即解決其相依性。 如有需要會載入相依性：
     * 當程式碼會分支到相依的組件。
     * 當程式碼會載入資源。
     * 當程式碼，明確地載入組件。
 
 * 實作<xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType>可以加入新的相依性，這可能需要被隔離，以允許存在的不同版本。 在預設內容中，最自然的實作會將這些相依性。 謹慎設計，可以區隔新的相依性。
 
 * 繫結隔離程序會建立多個類型，具有相同的型別名稱。
     * 這可能會導致容易產生混淆的錯誤訊息，例如"Foo.Foo 類型無法轉換成輸入 Foo.Foo。 」
     * 跨越隔離界限封送處理是重要的。 典型的解決方案是使用只載入預設載入內容之組件中定義的介面。
 
 ]]></format>
    </remarks>
    <related type="Article" href="https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/assemblyloadcontext.md">AssemblyLoadContext CoreCLR 的設計文件</related>
    <related type="Article" href="/en-us/dotnet/standard/assembly/unloadability-howto">如何使用及偵錯.NET Core 中的組件 unloadability</related>.
    <related type="Article" href="https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/unloadability.md">AssemblyLoadContext unloadability 設計文件</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected AssemblyLoadContext ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; AssemblyLoadContext();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

這個建構函式受到保護。 它只能從呼叫<xref:System.Runtime.Loader.AssemblyLoadContext>類別或其衍生的類別。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected AssemblyLoadContext (bool isCollectible);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(bool isCollectible) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (isCollectible As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; AssemblyLoadContext(bool isCollectible);" />
      <MemberSignature Language="F#" Value="new System.Runtime.Loader.AssemblyLoadContext : bool -&gt; System.Runtime.Loader.AssemblyLoadContext" Usage="new System.Runtime.Loader.AssemblyLoadContext isCollectible" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="isCollectible" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="isCollectible"><see langword="true" /> 以啟用記憶體回收；否則為 <see langword="false" />。</param>
        <summary>使用指出是否已啟用記憶體回收的值來初始化 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> 類別的新執行個體。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Runtime.Loader.AssemblyLoadContext Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Loader.AssemblyLoadContext Default" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Loader.AssemblyLoadContext.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As AssemblyLoadContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Loader::AssemblyLoadContext ^ Default { System::Runtime::Loader::AssemblyLoadContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Runtime.Loader.AssemblyLoadContext" Usage="System.Runtime.Loader.AssemblyLoadContext.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Loader.AssemblyLoadContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得預設 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />。 預設內容包含主應用程式組件及其靜態相依性。</summary>
        <value>預設組件載入內容。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblyName">
      <MemberSignature Language="C#" Value="public static System.Reflection.AssemblyName GetAssemblyName (string assemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.AssemblyName GetAssemblyName(string assemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.GetAssemblyName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAssemblyName (assemblyPath As String) As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::AssemblyName ^ GetAssemblyName(System::String ^ assemblyPath);" />
      <MemberSignature Language="F#" Value="static member GetAssemblyName : string -&gt; System.Reflection.AssemblyName" Usage="System.Runtime.Loader.AssemblyLoadContext.GetAssemblyName assemblyPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyPath">組件的路徑。</param>
        <summary>取得組件路徑的 <see cref="T:System.Reflection.AssemblyName" />。</summary>
        <returns>物件，其包含組件 (位於 <paramref name="assemblyPath" />) 的完整剖析顯示名稱。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyPath" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到組件。</exception>
        <exception cref="T:System.BadImageFormatException">此組件不是有效的組件。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetLoadContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Loader.AssemblyLoadContext GetLoadContext (System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Loader.AssemblyLoadContext GetLoadContext(class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.GetLoadContext(System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Loader::AssemblyLoadContext ^ GetLoadContext(System::Reflection::Assembly ^ assembly);" />
      <MemberSignature Language="F#" Value="static member GetLoadContext : System.Reflection.Assembly -&gt; System.Runtime.Loader.AssemblyLoadContext" Usage="System.Runtime.Loader.AssemblyLoadContext.GetLoadContext assembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Loader.AssemblyLoadContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="assembly">組件。</param>
        <summary>取得 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />，其中包含指定的 <see cref="T:System.Reflection.Assembly" />。</summary>
        <returns>包含 <paramref name="assembly" /> 的組件載入內容。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assembly" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsCollectible">
      <MemberSignature Language="C#" Value="public bool IsCollectible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCollectible" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Loader.AssemblyLoadContext.IsCollectible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCollectible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCollectible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCollectible : bool" Usage="System.Runtime.Loader.AssemblyLoadContext.IsCollectible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得指出此 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> 是否為可回收的值。</summary>
        <value><see langword="true" /> 如果這個<see cref="T:System.Runtime.Loader.AssemblyLoadContext" />可回收; 否則即為<see langword="false" />。 如果建構函式中未指定值，則值是<see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 如需詳細資訊，請參閱<see href="/en-us/dotnet/standard/assembly/unloadability-howto">如何使用及偵錯.NET Core 中的組件 unloadability</see>。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyName);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.Load assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyName">描述要載入之組件的物件。</param>
        <summary>在衍生類別中覆寫時，允許組件根據其 <see cref="T:System.Reflection.AssemblyName" /> 解析並載入。</summary>
        <returns>載入的組件或 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
 
## Remarks
 組件解析期間<xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)>方法已載入的組件解析的組件名稱的第一個機會。 它可以載入組件，或傳回`null`。 如果它傳回`null`，解析程序會繼續。 請參閱<xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName(System.Reflection.AssemblyName)>針對完整的處理序的描述。
 
 > [!IMPORTANT]
 > 若要避免遞迴堆疊溢位，請勿呼叫這個執行個體的<xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName(System.Reflection.AssemblyName)>從這個方法的方法。
 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadFromAssemblyName">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromAssemblyName (System.Reflection.AssemblyName assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromAssemblyName(class System.Reflection.AssemblyName assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName(System.Reflection.AssemblyName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromAssemblyName(System::Reflection::AssemblyName ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.LoadFromAssemblyName : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.LoadFromAssemblyName assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyName">物件，其描述要載入的組件。</param>
        <summary>解析並載入指定為 <see cref="T:System.Reflection.AssemblyName" /> 的組件。</summary>
        <returns>載入的組件或 throws。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName%2A> 載入組件解析<xref:System.Reflection.AssemblyName>。 這會觸發完整的解析度。 解析後援順序會遵循此程序：1. 方法呼叫<xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)>。
         > [!IMPORTANT]
         > <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)> must not call this method to prevent recursive stack overflow.
     2. Unless the assembly is loaded or an exception is thrown, the method attempts to load the assembly in the default <xref:System.Runtime.Loader.AssemblyLoadContext>.
     3. Unless the assembly is loaded or an exception is thrown, the method fires the <xref:System.Runtime.Loader.AssemblyLoadContext.Resolving> event.
     4. Unless the assembly is loaded or an exception is thrown, the method fires the <xref:System.AppDomain.AssemblyResolve> event.
 
 > [!NOTE]
 > <xref:System.IO.FileLoadException> 如果擲回`assemblyRef`指定完整的組件名稱，而第一個符合的簡單名稱的組件有不相容的版本或文化特性。 載入器不會繼續探查比對的簡單名稱的其他組件。
 
 每個<xref:System.Runtime.Loader.AssemblyLoadContext>可以只載入: * 單一可執行檔的組件版本。
* 一個新版每個文化特性的附屬組件的詳細資訊。
 
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" /> 不是有效的組件。</exception>
        <exception cref="T:System.IO.FileLoadException">載入的組件或模組不符合 <paramref name="assemblyName" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromAssemblyPath">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromAssemblyPath (string assemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromAssemblyPath(string assemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadFromAssemblyPath (assemblyPath As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromAssemblyPath(System::String ^ assemblyPath);" />
      <MemberSignature Language="F#" Value="member this.LoadFromAssemblyPath : string -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.LoadFromAssemblyPath assemblyPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyPath">要載入的完整檔案路徑。</param>
        <summary>載入指定路徑上組件檔案的內容。</summary>
        <returns>載入的組件。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyPath" /> 引數不是絕對路徑。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyPath" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileLoadException">無法載入找到的檔案。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyPath" /> 參數為空字串 ("") 或不存在。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyPath" /> 不是有效的組件。</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromNativeImagePath">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromNativeImagePath (string nativeImagePath, string assemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromNativeImagePath(string nativeImagePath, string assemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadFromNativeImagePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadFromNativeImagePath (nativeImagePath As String, assemblyPath As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromNativeImagePath(System::String ^ nativeImagePath, System::String ^ assemblyPath);" />
      <MemberSignature Language="F#" Value="member this.LoadFromNativeImagePath : string * string -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.LoadFromNativeImagePath (nativeImagePath, assemblyPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nativeImagePath" Type="System.String" />
        <Parameter Name="assemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="nativeImagePath">要載入的完整檔案路徑。</param>
        <param name="assemblyPath">所要載入檔案之 IL 版本的完整檔案路徑或 <see langword="null" />。</param>
        <summary>載入指定路徑上受控組件檔案的原生映像內容。</summary>
        <returns>載入的組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Managed 組件的原生映像已預先 jit 編譯最佳化特定平台上執行。
 
 組件路徑是指的 IL 組件的版本路徑。 IL 通常包含在原生映像，它是選擇性引數。 它可供執行階段做為後援如果找不到原生映像。
 
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="nativeImagePath" /> 引數不是絕對路徑。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyPath" /> 引數不是絕對路徑。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="nativeImagePath" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileLoadException">無法載入找到的檔案。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="nativeImagePath" /> 參數為空字串 ("") 或不存在。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyPath" /> 不是有效的組件。</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromStream">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromStream (System.IO.Stream assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromStream(class System.IO.Stream assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadFromStream(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromStream(System::IO::Stream ^ assembly);" />
      <MemberSignature Language="F#" Value="member this.LoadFromStream : System.IO.Stream -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.LoadFromStream assembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="assembly">位元組陣列，該陣列是包含受控組件的 COFF 影像。</param>
        <summary>載入包含受控組件的通用物件檔案格式 (COFF) 映像組件。</summary>
        <returns>載入的組件。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assembly" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assembly" /> 不是有效的組件。</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromStream">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromStream (System.IO.Stream assembly, System.IO.Stream assemblySymbols);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromStream(class System.IO.Stream assembly, class System.IO.Stream assemblySymbols) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadFromStream(System.IO.Stream,System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromStream(System::IO::Stream ^ assembly, System::IO::Stream ^ assemblySymbols);" />
      <MemberSignature Language="F#" Value="member this.LoadFromStream : System.IO.Stream * System.IO.Stream -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.LoadFromStream (assembly, assemblySymbols)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.IO.Stream" />
        <Parameter Name="assemblySymbols" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="assembly">位元組陣列，該陣列是包含受控組件的 COFF 影像。</param>
        <param name="assemblySymbols">位元組陣列，包含表示組件符號的未經處理位元組。</param>
        <summary>載入包含受控組件的通用物件檔案格式 (COFF) 映像組件，並選擇性地包含組件的符號。</summary>
        <returns>載入的組件。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assembly" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assembly" /> 不是有效的組件。</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadUnmanagedDll">
      <MemberSignature Language="C#" Value="protected virtual IntPtr LoadUnmanagedDll (string unmanagedDllName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance native int LoadUnmanagedDll(string unmanagedDllName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadUnmanagedDll(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LoadUnmanagedDll (unmanagedDllName As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual IntPtr LoadUnmanagedDll(System::String ^ unmanagedDllName);" />
      <MemberSignature Language="F#" Value="abstract member LoadUnmanagedDll : string -&gt; nativeint&#xA;override this.LoadUnmanagedDll : string -&gt; nativeint" Usage="assemblyLoadContext.LoadUnmanagedDll unmanagedDllName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unmanagedDllName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="unmanagedDllName">非受控程式庫的名稱。 這通常是沒有路徑或副檔名的檔案名稱。</param>
        <summary>允許衍生類別依名稱載入非受控程式庫。</summary>
        <returns>所載入程式庫的控制代碼或 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 預設實作永遠會傳回`null`。 當`null`會傳回執行階段載入的程式庫，其預設原則。
 
 可以覆寫此虛擬方法，以自訂的 unmanaged 程式庫搜尋演算法。 覆寫時的名稱可以用來識別程式庫。 載入的程式庫不需要符合所要求的名稱，但可以視需要轉換。 這可能包括調整平台特定命名的名稱。
 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadUnmanagedDllFromPath">
      <MemberSignature Language="C#" Value="protected IntPtr LoadUnmanagedDllFromPath (string unmanagedDllPath);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance native int LoadUnmanagedDllFromPath(string unmanagedDllPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadUnmanagedDllFromPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Function LoadUnmanagedDllFromPath (unmanagedDllPath As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; IntPtr LoadUnmanagedDllFromPath(System::String ^ unmanagedDllPath);" />
      <MemberSignature Language="F#" Value="member this.LoadUnmanagedDllFromPath : string -&gt; nativeint" Usage="assemblyLoadContext.LoadUnmanagedDllFromPath unmanagedDllPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unmanagedDllPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="unmanagedDllPath">非受控程式庫的路徑。</param>
        <summary>從指定的路徑載入非受控程式庫。</summary>
        <returns>所載入程式庫的控制代碼。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="unmanagedDllPath" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="unmanagedDllPath" /> 引數不是絕對路徑。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到非受控程式庫。</exception>
      </Docs>
    </Member>
    <Member MemberName="Resolving">
      <MemberSignature Language="C#" Value="public event Func&lt;System.Runtime.Loader.AssemblyLoadContext,System.Reflection.AssemblyName,System.Reflection.Assembly&gt; Resolving;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Func`3&lt;class System.Runtime.Loader.AssemblyLoadContext, class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; Resolving" />
      <MemberSignature Language="DocId" Value="E:System.Runtime.Loader.AssemblyLoadContext.Resolving" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Resolving As Func(Of AssemblyLoadContext, AssemblyName, Assembly) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event Func&lt;System::Runtime::Loader::AssemblyLoadContext ^, System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ Resolving;" />
      <MemberSignature Language="F#" Value="member this.Resolving : Func&lt;System.Runtime.Loader.AssemblyLoadContext, System.Reflection.AssemblyName, System.Reflection.Assembly&gt; " Usage="member this.Resolving : System.Func&lt;System.Runtime.Loader.AssemblyLoadContext, System.Reflection.AssemblyName, System.Reflection.Assembly&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;System.Runtime.Loader.AssemblyLoadContext,System.Reflection.AssemblyName,System.Reflection.Assembly&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>若嘗試載入至這項組件載入內容，解析組件失敗時就會發生這種情況。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 傳回指定的組件，或是傳回這個事件處理常式負責`null`如果無法辨識的組件。
 
 > [!IMPORTANT]
 >  如果此事件註冊一個以上的事件處理常式，事件處理常式會依照順序呼叫事件處理常式傳回的值不`null`。 後續的事件處理常式會被忽略。
 
 如需有關如何處理事件的詳細資訊，請參閱 <<c0> [ 處理和引發事件](~/docs/standard/events/index.md)。
 
 它是值得您注意處理常式，可以加入任何此事件<xref:System.Runtime.Loader.AssemblyLoadContext>，包括預設的內容。
 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResolvingUnmanagedDll">
      <MemberSignature Language="C#" Value="public event Func&lt;System.Reflection.Assembly,string,IntPtr&gt; ResolvingUnmanagedDll;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Func`3&lt;class System.Reflection.Assembly, string, native int&gt; ResolvingUnmanagedDll" />
      <MemberSignature Language="DocId" Value="E:System.Runtime.Loader.AssemblyLoadContext.ResolvingUnmanagedDll" />
      <MemberSignature Language="VB.NET" Value="Public Event ResolvingUnmanagedDll As Func(Of Assembly, String, IntPtr) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event Func&lt;System::Reflection::Assembly ^, System::String ^, IntPtr&gt; ^ ResolvingUnmanagedDll;" />
      <MemberSignature Language="F#" Value="member this.ResolvingUnmanagedDll : Func&lt;System.Reflection.Assembly, string, nativeint&gt; " Usage="member this.ResolvingUnmanagedDll : System.Func&lt;System.Reflection.Assembly, System.string, System.nativeint&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;System.Reflection.Assembly,System.String,System.IntPtr&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetProfileOptimizationRoot">
      <MemberSignature Language="C#" Value="public void SetProfileOptimizationRoot (string directoryPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetProfileOptimizationRoot(string directoryPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.SetProfileOptimizationRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetProfileOptimizationRoot (directoryPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetProfileOptimizationRoot(System::String ^ directoryPath);" />
      <MemberSignature Language="F#" Value="member this.SetProfileOptimizationRoot : string -&gt; unit" Usage="assemblyLoadContext.SetProfileOptimizationRoot directoryPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directoryPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directoryPath">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartProfileOptimization">
      <MemberSignature Language="C#" Value="public void StartProfileOptimization (string profile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StartProfileOptimization(string profile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.StartProfileOptimization(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub StartProfileOptimization (profile As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StartProfileOptimization(System::String ^ profile);" />
      <MemberSignature Language="F#" Value="member this.StartProfileOptimization : string -&gt; unit" Usage="assemblyLoadContext.StartProfileOptimization profile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="profile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="profile">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public void Unload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Unload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.Unload" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unload ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Unload();" />
      <MemberSignature Language="F#" Value="member this.Unload : unit -&gt; unit" Usage="assemblyLoadContext.Unload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>起始這個 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> 的卸載。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

+ 如果是可回收，AssemblyLoadContext 只能卸載。
+ 卸載會以非同步方式發生。
+ 卸載不會發生 AssemblyLoadContext 的參考時。

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">不允許卸載。</exception>
      </Docs>
    </Member>
    <Member MemberName="Unloading">
      <MemberSignature Language="C#" Value="public event Action&lt;System.Runtime.Loader.AssemblyLoadContext&gt; Unloading;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Action`1&lt;class System.Runtime.Loader.AssemblyLoadContext&gt; Unloading" />
      <MemberSignature Language="DocId" Value="E:System.Runtime.Loader.AssemblyLoadContext.Unloading" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloading As Action(Of AssemblyLoadContext) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event Action&lt;System::Runtime::Loader::AssemblyLoadContext ^&gt; ^ Unloading;" />
      <MemberSignature Language="F#" Value="member this.Unloading : Action&lt;System.Runtime.Loader.AssemblyLoadContext&gt; " Usage="member this.Unloading : System.Action&lt;System.Runtime.Loader.AssemblyLoadContext&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Action&lt;System.Runtime.Loader.AssemblyLoadContext&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於卸載 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> 時。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
