<Type Name="GrammarBuilder" FullName="System.Speech.Recognition.GrammarBuilder">
  <Metadata><Meta Name="ms.openlocfilehash" Value="445ae1620c692c34154268c06fe2f355387357ff" /><Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="11/20/2018" /><Meta Name="ms.locfileid" Value="52231794" /></Metadata><TypeSignature Language="C#" Value="public class GrammarBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit GrammarBuilder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Speech.Recognition.GrammarBuilder" />
  <TypeSignature Language="VB.NET" Value="Public Class GrammarBuilder" />
  <TypeSignature Language="C++ CLI" Value="public ref class GrammarBuilder" />
  <TypeSignature Language="F#" Value="type GrammarBuilder = class" />
  <AssemblyInfo>
    <AssemblyName>System.Speech</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("{DebugSummary}")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供以程式設計的方式建置語音辨識文法條件約束的機制。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中所定義的 XML 格式通常編寫的語音辨識文法[語音辨識文法規格 (SRGS) Version 1.0](https://go.microsoft.com/fwlink/?LinkId=201761)。 如果您是熟悉 SRGS，但想要以程式設計方式產生的文法項目，您可以使用<xref:System.Speech.Recognition.SrgsGrammar>命名空間，其成員密切對應的項目和 SRGS 所定義的屬性。 如果您不熟悉 SRGS，或您想要的輕量型、 以程式設計方式撰寫，您可以有效率地完成許多常見的案例; 文法方法您可以使用<xref:System.Speech.Recognition.GrammarBuilder>和<xref:System.Speech.Recognition.Choices>類別。  
  
 使用<xref:System.Speech.Recognition.GrammarBuilder>物件來建置階層式樹狀結構所組成<xref:System.Speech.Recognition.Choices>包含替代的片語，穿插前序編碼和後置 amble 片語，每個節點，並傳達意義的語意值與植入的物件回到應用程式。  
  
 若要使用<xref:System.Speech.Recognition.GrammarBuilder>來建立<xref:System.Speech.Recognition.Grammar>物件，請使用下列步驟。  
  
1.  建立 <xref:System.Speech.Recognition.GrammarBuilder> 物件。  
  
2.  附加至的條件約束<xref:System.Speech.Recognition.GrammarBuilder>，這類<xref:System.String>物件， <xref:System.Speech.Recognition.Choices>， <xref:System.Speech.Recognition.SemanticResultKey>， <xref:System.Speech.Recognition.SemanticResultValue>， <xref:System.Speech.Recognition.DictationGrammar>，和其他<xref:System.Speech.Recognition.GrammarBuilder>定義文法的條件約束的物件。  
  
3.  使用其中一種<xref:System.Speech.Recognition.Grammar.%23ctor%2A>建構函式來建立<xref:System.Speech.Recognition.Grammar>物件從已完成<xref:System.Speech.Recognition.GrammarBuilder>文法。  
  
 藉由撰寫<xref:System.Speech.Recognition.GrammarBuilder>最適用於清單或可能是清單的清單，其中包含一個單一規則的文法。 若要以程式設計方式建置具有多個規則，或是需要讓您的內部規則參考的文法、 使用的類別<xref:System.Speech.Recognition.SrgsGrammar>命名空間。  
  
 執行個體<xref:System.Speech.Recognition.GrammarBuilder>也可以取得的某些其他類別隱含地轉換或合併<xref:System.Speech.Recognition.GrammarBuilder>與第二個物件，其中包含文法的條件約束... 如需詳細資訊，請參閱 <<c0> <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> 並<xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A>運算子和<xref:System.Speech.Recognition.GrammarBuilder.Add%2A>方法。  
  
 若要將規則新增至現有<xref:System.Speech.Recognition.GrammarBuilder>，使用<xref:System.Speech.Recognition.GrammarBuilder.Add%2A>， <xref:System.Speech.Recognition.GrammarBuilder.Append%2A>， <xref:System.Speech.Recognition.GrammarBuilder.AppendDictation%2A>， <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A>，和<xref:System.Speech.Recognition.GrammarBuilder.AppendWildcard%2A>方法。  
  
> [!IMPORTANT]
>  語音辨識器在使用語音辨識文法包含相同的索引鍵名稱重複語意的項目或多個語意的項目可以重複修改相同的語意元素的值時，可以擲回例外狀況。 
  
 若要協助偵錯，<xref:System.Speech.Recognition.GrammarBuilder.DebugShowPhrases%2A>屬性會傳回目前的狀態<xref:System.Speech.Recognition.GrammarBuilder>做為字串。  
  
 如需有關建立和使用語音辨識文法的詳細資訊，請參閱 <<c0> [ 語音辨識](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361633(v=office.14))並[建立 GrammarBuilder 文法](https://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae)。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Speech.Recognition.GrammarBuilder>和<xref:System.Speech.Recognition.Choices>物件以建構可辨識的兩個片語，其中的文法"背景*colorChoice*」 或 「 背景設定為*colorChoice*".  
  
 此範例會使用<xref:System.Speech.Recognition.Choices>物件來建立一份可接受的值，如*colorChoice*從一連串<xref:System.String>物件。 A<xref:System.Speech.Recognition.Choices>物件相當於`one-of`SRGS 規格中的項目和包含替代的片語，其中任何一種可辨識時說出的一組。 此範例也會使用<xref:System.Speech.Recognition.Choices>物件來分組的兩個陣列<xref:System.Speech.Recognition.GrammarBuilder>成一對替代片語產生的文法可辨識的物件。 另一個單字或片語是大部分的文法的元件和<xref:System.Speech.Recognition.Choices>物件會提供這項功能的文法建構<xref:System.Speech.Recognition.GrammarBuilder>。  
  
 此範例最後會建立<xref:System.Speech.Recognition.Grammar>物件從<xref:System.Speech.Recognition.GrammarBuilder>建構從<xref:System.Speech.Recognition.Choices>物件。  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  Grammar grammar = new Grammar((GrammarBuilder)bothChoices);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Speech.Recognition.Choices" />
    <altmember cref="T:System.Speech.Recognition.Grammar" />
    <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
    <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Speech.Recognition.GrammarBuilder" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此類別的執行個體也可以取得自其他類別的隱含轉換，或結合<xref:System.Speech.Recognition.GrammarBuilder>物件與第二個物件以從新<xref:System.Speech.Recognition.GrammarBuilder>。 如需詳細資訊，請參閱 <<c0> <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> 和<xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A>方法。  
  
 若要加入至現有的條件約束<xref:System.Speech.Recognition.GrammarBuilder>，使用<xref:System.Speech.Recognition.GrammarBuilder.Add%2A>， <xref:System.Speech.Recognition.GrammarBuilder.Append%2A>， <xref:System.Speech.Recognition.GrammarBuilder.AppendDictation%2A>， <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A>，和<xref:System.Speech.Recognition.GrammarBuilder.AppendWildcard%2A>方法，而<xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A>運算子。  
  
> [!IMPORTANT]
>  語音辨識器在使用語音辨識文法包含相同的索引鍵名稱重複語意的項目或多個語意的項目可以重複修改相同的語意元素的值時，可以擲回例外狀況。
  
 如需有關建立和使用語音辨識文法的詳細資訊，請參閱 <<c0> [ 語音辨識](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361633(v=office.14))並[建立 GrammarBuilder 文法](https://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae)。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Speech.Recognition.GrammarBuilder" /> 類別的新的空執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要將規則新增至現有<xref:System.Speech.Recognition.GrammarBuilder>物件，請使用<xref:System.Speech.Recognition.GrammarBuilder.Add%2A>， <xref:System.Speech.Recognition.GrammarBuilder.Append%2A>， <xref:System.Speech.Recognition.GrammarBuilder.AppendDictation%2A>， <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A>，和<xref:System.Speech.Recognition.GrammarBuilder.AppendWildcard%2A>方法，而<xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A>運算子。  
  
> [!IMPORTANT]
>  語音辨識器在使用語音辨識文法包含相同的索引鍵名稱重複語意的項目或多個語意的項目可以重複修改相同的語意元素的值時，可以擲回例外狀況。
  
   
  
## Examples  
 下列範例會使用<xref:System.Speech.Recognition.GrammarBuilder>和<xref:System.Speech.Recognition.Choices>物件以建構可辨識的兩個片語，其中的文法"背景*colorChoice*」 或 「 背景設定為*colorChoice*".  
  
 此範例會使用<xref:System.Speech.Recognition.Choices>物件來建立一份可接受的值，如*colorChoice*從一連串<xref:System.String>物件。 A<xref:System.Speech.Recognition.Choices>物件相當於`one-of`SRGS 規格中的項目和包含替代的片語，其中任何可辨識時說出的一組。 此範例也會使用<xref:System.Speech.Recognition.Choices>物件來分組的兩個陣列<xref:System.Speech.Recognition.GrammarBuilder>成一對替代片語產生的文法可辨識的物件。 另一個單字或片語是大部分的文法的元件和<xref:System.Speech.Recognition.Choices>物件會提供這項功能的文法建構<xref:System.Speech.Recognition.GrammarBuilder>。  
  
 此範例最後會建立<xref:System.Speech.Recognition.Grammar>物件從<xref:System.Speech.Recognition.GrammarBuilder>建構從<xref:System.Speech.Recognition.Choices>物件。  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the Grammar object from the result.  
  GrammarBuilder bothPhrases = new GrammarBuilder();  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  bothPhrases.Append(bothChoices);  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (System.Speech.Recognition.Choices alternateChoices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.Choices alternateChoices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.Speech.Recognition.Choices)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (alternateChoices As Choices)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::Speech::Recognition::Choices ^ alternateChoices);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : System.Speech.Recognition.Choices -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder alternateChoices" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="alternateChoices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="alternateChoices">替代方式的集合。</param>
        <summary>從一組替代項目初始化 <see cref="T:System.Speech.Recognition.GrammarBuilder" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需有關如何建置包含替代語音辨識文法的詳細資訊，請參閱 <<c0> [ 使用的選項，來建立 GrammarBuilder 文法](https://msdn.microsoft.com/library/5b18db18-a5f6-46a3-aa77-6d3141544efd)。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Speech.Recognition.GrammarBuilder>和<xref:System.Speech.Recognition.Choices>物件以建構可辨識的兩個片語，其中的文法"背景*colorChoice*」 或 「 背景設定為*colorChoice*".  
  
 此範例會使用<xref:System.Speech.Recognition.Choices>物件來建立一份可接受的值，如*colorChoice*從一連串<xref:System.String>物件。 A<xref:System.Speech.Recognition.Choices>物件相當於`one-of`SRGS 規格中的項目和包含替代的片語，其中任何一種可辨識時說出的一組。 此範例也會使用<xref:System.Speech.Recognition.Choices>物件來分組的兩個陣列<xref:System.Speech.Recognition.GrammarBuilder>成一對替代片語產生的文法可辨識的物件。 另一個單字或片語是大部分的文法的元件和<xref:System.Speech.Recognition.Choices>物件會提供這項功能的文法建構<xref:System.Speech.Recognition.GrammarBuilder>。  
  
 此範例最後會建立<xref:System.Speech.Recognition.Grammar>物件從<xref:System.Speech.Recognition.GrammarBuilder>建構從<xref:System.Speech.Recognition.Choices>物件。  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  Grammar grammar = new Grammar((GrammarBuilder)bothChoices);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (System.Speech.Recognition.SemanticResultKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.SemanticResultKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.Speech.Recognition.SemanticResultKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (key As SemanticResultKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::Speech::Recognition::SemanticResultKey ^ key);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : System.Speech.Recognition.SemanticResultKey -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder key" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="key" Type="System.Speech.Recognition.SemanticResultKey" />
      </Parameters>
      <Docs>
        <param name="key">語意索引鍵。</param>
        <summary>從語意索引鍵初始化 <see cref="T:System.Speech.Recognition.GrammarBuilder" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您建立<xref:System.Speech.Recognition.GrammarBuilder>執行個體<xref:System.Speech.Recognition.SemanticResultValue>物件，可辨識結果中傳回的文法中加入語意資訊。 您可以存取在辨識結果中使用的語意資訊<xref:System.Speech.Recognition.RecognizedPhrase.Semantics%2A>的屬性<xref:System.Speech.Recognition.RecognizedPhrase>，這是可用的處理常式中`SpeechRecognized`事件。 如果<xref:System.Speech.Recognition.GrammarBuilder>定義<xref:System.Speech.Recognition.SemanticResultKey>，這可以用來擷取與索引鍵相關聯的辨識結果中語意資訊。 範例，請參閱<xref:System.Speech.Recognition.GrammarBuilder.Append%28System.Speech.Recognition.SemanticResultKey%29>，也會看到<xref:System.Speech.Recognition.SemanticResultValue>和<xref:System.Speech.Recognition.SemanticResultKey>。  
  
> [!IMPORTANT]
>  當您建構<xref:System.Speech.Recognition.GrammarBuilder>包含的物件<xref:System.Speech.Recognition.SemanticResultValue>或是<xref:System.Speech.Recognition.SemanticResultKey>執行個體，請確定您有避免建立重複的語意項目具有相同索引鍵的名稱或多個語意的項目可以重複修改<xref:System.Speech.Recognition.SemanticValue.Value%2A>屬性<xref:System.Speech.Recognition.SemanticValue>物件。 語音辨識器在遇到這些情況下，可以擲回例外狀況。 
  
   
  
## Examples  
 下列範例會建立可辨識的兩個片語，語音辨識文法"背景*colorChoice*"和"設為背景*colorChoice*"，其中*colorChoice*選取從一組色彩。 文法讓使用者能夠說話的任何數個色彩的名稱，並傳回應用程式，可辨識的色彩名稱有關的語意資訊。  
  
 此範例會使用單一<xref:System.Speech.Recognition.SemanticResultKey>您可以擷取與<xref:System.Speech.Recognition.SemanticValue>，都會產生相關的使用者所講出的色彩。 比方說，如果輸入包含片語時，「 設定背景為紅色，」 的辨識結果包含"#FF0000 」，您可以使用的處理常式來擷取這些語意值`SpeechRecognized`事件。  
  
 此範例會使用<xref:System.String>， <xref:System.Speech.Recognition.Choices>， <xref:System.Speech.Recognition.SemanticResultKey>， <xref:System.Speech.Recognition.SemanticResultValue>，並<xref:System.Speech.Recognition.GrammarBuilder>物件來建置的條件約束，全部都在過去<xref:System.Speech.Recognition.GrammarBuilder>物件， `bothPhrases`。 最後，此範例會建構<xref:System.Speech.Recognition.Grammar>從 已完成的物件<xref:System.Speech.Recognition.GrammarBuilder>。  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  // Include semantic information about each of the colors.  
  Choices colorChoice = new Choices();  
  
  GrammarBuilder colorBuilder = new GrammarBuilder("red");  
  SemanticResultValue colorValue =  
    new SemanticResultValue(colorBuilder, "#FF0000");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  colorBuilder = new GrammarBuilder("green");  
  colorValue = new SemanticResultValue(colorBuilder, "#00FF00");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  colorBuilder = new GrammarBuilder("blue");  
  colorValue = new SemanticResultValue(colorBuilder, "#0000FF");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices object for the two alternative phrases.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  // Create the semantic key for referencing the color information.  
  SemanticResultKey colorKey =  
    new SemanticResultKey("ColorCode", bothPhrases);  
  bothPhrases = new GrammarBuilder(colorKey);  
  
  // Construct the Grammar object from the GrammarBuilder.  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (System.Speech.Recognition.SemanticResultValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.SemanticResultValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.Speech.Recognition.SemanticResultValue)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As SemanticResultValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::Speech::Recognition::SemanticResultValue ^ value);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : System.Speech.Recognition.SemanticResultValue -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Speech.Recognition.SemanticResultValue" />
      </Parameters>
      <Docs>
        <param name="value">語意值或名稱/值組。</param>
        <summary>從語意值初始化 <see cref="T:System.Speech.Recognition.GrammarBuilder" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您建立<xref:System.Speech.Recognition.GrammarBuilder>執行個體<xref:System.Speech.Recognition.SemanticResultValue>物件，可辨識結果中傳回的文法中加入語意資訊。 您可以存取在辨識結果中使用的語意資訊<xref:System.Speech.Recognition.RecognizedPhrase.Semantics%2A>的屬性<xref:System.Speech.Recognition.RecognizedPhrase>，這是可用的處理常式中`SpeechRecognized`事件。 如果<xref:System.Speech.Recognition.GrammarBuilder>定義<xref:System.Speech.Recognition.SemanticResultKey>，這可以用來擷取與索引鍵相關聯的辨識結果中語意資訊。 範例，請參閱<xref:System.Speech.Recognition.GrammarBuilder.Append%28System.Speech.Recognition.SemanticResultKey%29>，也會看到<xref:System.Speech.Recognition.SemanticResultValue>和<xref:System.Speech.Recognition.SemanticResultKey>。  
  
> [!IMPORTANT]
>  當您建構<xref:System.Speech.Recognition.GrammarBuilder>包含的物件<xref:System.Speech.Recognition.SemanticResultValue>或是<xref:System.Speech.Recognition.SemanticResultKey>執行個體，請確定您有避免建立重複的語意項目具有相同索引鍵的名稱或多個語意的項目可以重複修改<xref:System.Speech.Recognition.SemanticValue.Value%2A>屬性<xref:System.Speech.Recognition.SemanticValue>物件。 語音辨識器在遇到這些情況下，可以擲回例外狀況。 
  
   
  
## Examples  
 下列範例會建立可辨識的兩個片語，語音辨識文法"背景*colorChoice*"和"設為背景*colorChoice*"，其中*colorChoice*選取從一組色彩。 文法讓使用者能夠說話的任何數個色彩的名稱，並傳回應用程式，可辨識的色彩名稱有關的語意資訊。  
  
 此範例會使用單一<xref:System.Speech.Recognition.SemanticResultKey>您可以擷取與<xref:System.Speech.Recognition.SemanticValue>，都會產生相關的使用者所講出的色彩。 比方說，如果輸入包含片語時，「 設定背景為紅色，」 的辨識結果包含"#FF0000 」，您可以使用的處理常式來擷取這些語意值`SpeechRecognized`事件。  
  
 此範例會使用<xref:System.String>， <xref:System.Speech.Recognition.Choices>， <xref:System.Speech.Recognition.SemanticResultKey>， <xref:System.Speech.Recognition.SemanticResultValue>，並<xref:System.Speech.Recognition.GrammarBuilder>物件來建置的條件約束，全部都在過去<xref:System.Speech.Recognition.GrammarBuilder>物件， `bothPhrases`。 最後，此範例會建構<xref:System.Speech.Recognition.Grammar>從 已完成的物件<xref:System.Speech.Recognition.GrammarBuilder>。  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  // Include semantic information about each of the colors.  
  Choices colorChoice = new Choices();  
  
  GrammarBuilder colorBuilder = new GrammarBuilder("red");  
  SemanticResultValue colorValue =  
    new SemanticResultValue(colorBuilder, "#FF0000");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  colorBuilder = new GrammarBuilder("green");  
  colorValue = new SemanticResultValue(colorBuilder, "#00FF00");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  colorBuilder = new GrammarBuilder("blue");  
  colorValue = new SemanticResultValue(colorBuilder, "#0000FF");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  // Create the semantic key for referencing the color information.  
  SemanticResultKey colorKey =  
    new SemanticResultKey("ColorCode", bothPhrases);  
  bothPhrases = new GrammarBuilder(colorKey);  
  
  // Construct the grammar from the grammar builder.  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (phrase As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : string -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder phrase" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="phrase">單字序列。</param>
        <summary>從單字序列初始化 <see cref="T:System.Speech.Recognition.GrammarBuilder" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 片語代表可辨識語音辨識文法，確切說出的片語。 如需有關如何建立包含字串的語音辨識文法的詳細資訊，請參閱 <<c0> [ 使用的字串，來建立 GrammarBuilder 文法](https://msdn.microsoft.com/library/0d87b445-a342-4369-9b3f-91d07fd7e114)。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Speech.Recognition.GrammarBuilder>和<xref:System.Speech.Recognition.Choices>物件以建構可辨識的兩個片語，其中的文法"背景*colorChoice*」 或 「 背景設定為*colorChoice*".  
  
 建立一份可接受的值之後*colorChoice*使用<xref:System.Speech.Recognition.Choices>物件，此範例會初始化兩個<xref:System.Speech.Recognition.GrammarBuilder>物件`makePhrase`和`setPhrase`，使用做為引數的字串。  
  
 此範例最後會建立<xref:System.Speech.Recognition.Grammar>物件從<xref:System.Speech.Recognition.Choices>物件轉換成<xref:System.Speech.Recognition.GrammarBuilder>物件。  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the Grammar object from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  Grammar grammar = new Grammar((GrammarBuilder)bothChoices);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (string phrase, System.Speech.Recognition.SubsetMatchingMode subsetMatchingCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string phrase, valuetype System.Speech.Recognition.SubsetMatchingMode subsetMatchingCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.String,System.Speech.Recognition.SubsetMatchingMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (phrase As String, subsetMatchingCriteria As SubsetMatchingMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::String ^ phrase, System::Speech::Recognition::SubsetMatchingMode subsetMatchingCriteria);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : string * System.Speech.Recognition.SubsetMatchingMode -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder (phrase, subsetMatchingCriteria)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="subsetMatchingCriteria" Type="System.Speech.Recognition.SubsetMatchingMode" />
      </Parameters>
      <Docs>
        <param name="phrase">單字序列。</param>
        <param name="subsetMatchingCriteria">語音辨識文法用來辨識片語的比對模式。</param>
        <summary>針對單字序列的子集，初始化 <see cref="T:System.Speech.Recognition.GrammarBuilder" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `phrase`參數代表可辨識語音辨識文法的片語。 `subsetMatchingMode`參數會指定可以讀出達成整個片語的成功辨識片語的子集。 您可以使用此工具來建立一份項目具有長名稱，而不需要使用者說話來比對項目完整名稱的文法。  
  
 如需有關比對模式的詳細資訊，請參閱<xref:System.Speech.Recognition.SubsetMatchingMode>。 如需有關如何建立包含字串的語音辨識文法的詳細資訊，請參閱 <<c0> [ 使用的字串，來建立 GrammarBuilder 文法](https://msdn.microsoft.com/library/0d87b445-a342-4369-9b3f-91d07fd7e114)。  
  
   
  
## Examples  
 下列範例會針對每一個建立語音辨識文法<xref:System.Speech.Recognition.SubsetMatchingMode>值和比對的模式文法之間選擇的文法。 如果的值`phrase`是"一個兩個三個四個五個六個七個"，然後子序列文法會辨識輸入"兩個三個四個"，但不是輸入 」 一個三個五個"。 但是，排序子集文法辨認這兩個這些輸入。  
  
```csharp  
  
private static IEnumerable<Grammar>  
  CreateMatchingModeGrammars(string phrase)  
{  
  List<Grammar> grammars = new List<Grammar>(5);  
  
  Choices modeChoice = new Choices();  
  Type enumType = typeof(SubsetMatchingMode);  
  foreach (SubsetMatchingMode mode in Enum.GetValues(enumType))  
  {  
    string modeName = Enum.GetName(enumType, mode);  
    modeName = BreakAtCaps(modeName);  
  
    GrammarBuilder builder = new GrammarBuilder(phrase, mode);  
    Grammar modeGrammar = new Grammar(builder);  
    modeGrammar.Name = modeName;  
    modeGrammar.Enabled = false;  
    grammars.Add(modeGrammar);  
  
    modeChoice.Add(modeName);  
  }  
  
  Grammar choiceGrammar = new Grammar(modeChoice);  
  choiceGrammar.Name = "choice";  
  grammars.Add(choiceGrammar);  
  
  return grammars;  
}  
  
// Insert spaces preceding each uppercase letter in a string.   
private static string BreakAtCaps(string item)  
{  
  if (item == null || item.Length == 0)  
  {  
    return item;  
  }  
  
  StringBuilder sb = new StringBuilder(item[0].ToString());  
  for (int i = 1; i < item.Length; i++)  
  {  
    char c = item[i];  
    if (char.IsUpper(c))  
    {  
      sb.Append(" ");  
    }  
    sb.Append(c);  
  }  
  
  return sb.ToString();  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.SubsetMatchingMode" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (System.Speech.Recognition.GrammarBuilder builder, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.GrammarBuilder builder, int32 minRepeat, int32 maxRepeat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.Speech.Recognition.GrammarBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (builder As GrammarBuilder, minRepeat As Integer, maxRepeat As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::Speech::Recognition::GrammarBuilder ^ builder, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : System.Speech.Recognition.GrammarBuilder * int * int -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder (builder, minRepeat, maxRepeat)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="minRepeat" Type="System.Int32" />
        <Parameter Name="maxRepeat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="builder">重複的項目。</param>
        <param name="minRepeat">為構成相符項目，輸入必須和 <paramref name="builder" /> 所定義的項目比對相符的最少次數。</param>
        <param name="maxRepeat">為構成相符項目，輸入可以和 <paramref name="builder" /> 所定義的項目比對相符的最大次數。</param>
        <summary>從重複的項目初始化 <see cref="T:System.Speech.Recognition.GrammarBuilder" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果值`minRepeat`是 0，則新<xref:System.Speech.Recognition.GrammarBuilder>表示選擇性的項目。  
  
 值`minRepeat`必須是大於或等於 0 且小於或等於值`maxRepeat`。  
  
> [!IMPORTANT]
>  當您指定的重複<xref:System.Speech.Recognition.GrammarBuilder>包含的物件<xref:System.Speech.Recognition.SemanticResultValue>或<xref:System.Speech.Recognition.SemanticResultKey>執行個體，請確定您有避免建立重複的語意項目具有相同索引鍵的名稱或多個語意的項目可以重複修改<xref:System.Speech.Recognition.SemanticValue.Value%2A>屬性<xref:System.Speech.Recognition.SemanticValue>物件。 語音辨識器在遇到這些情況下，可以擲回例外狀況。 
  
   
  
## Examples  
 下列範例會建立訂購比薩的語音辨識文法。 其開頭為選擇性，開啟的片語，後面接著一到四個配料，並關閉 「 披薩 」 這個字。  
  
```csharp  
  
private static Grammar CreatePizzaGrammar()  
{  
  
  // Create a Choices object from a string array of alternative toppings.  
  Choices toppings = new Choices(new string[] {  
    "cheese", "mushroom", "tomato", "onion",  
    "anchovy", "chicken", "pepperoni"});  
  
  // Create a GrammarBuilder and append the Choices object.  
  GrammarBuilder andToppings = new GrammarBuilder("and", 0, 1);  
  andToppings.Append(toppings);  
  
  // Construct the phrase.  
  GrammarBuilder gb = new GrammarBuilder("I would like a", 0, 1);  
  gb.Append(toppings);  
  gb.Append(new GrammarBuilder(andToppings, 0, 3));  
  gb.Append("pizza");  
  
  // Create the Grammar from the GrammarBuilder.  
  Grammar grammar = new Grammar(gb);  
  grammar.Name = "Pizza Order";  
  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (string phrase, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string phrase, int32 minRepeat, int32 maxRepeat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (phrase As String, minRepeat As Integer, maxRepeat As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::String ^ phrase, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : string * int * int -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder (phrase, minRepeat, maxRepeat)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="minRepeat" Type="System.Int32" />
        <Parameter Name="maxRepeat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="phrase">單字的重複序列。</param>
        <param name="minRepeat">為構成相符項目，輸入必須和片語比對相符的最少次數。</param>
        <param name="maxRepeat">為構成相符項目，輸入可以和片語比對相符的最大次數。</param>
        <summary>從 <see cref="T:System.Speech.Recognition.GrammarBuilder" /> 中的單字序列，初始化 <see cref="T:System.String" /> 類別的新執行個體，並指定 <see cref="T:System.String" /> 可重複次數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果值`minRepeat`是 0，則新<xref:System.Speech.Recognition.GrammarBuilder>表示選擇性的項目。  
  
 值`minRepeat`必須是大於或等於 0 且小於或等於值`maxRepeat`。 如需有關如何建立包含字串的語音辨識文法的詳細資訊，請參閱 <<c0> [ 使用的字串，來建立 GrammarBuilder 文法](https://msdn.microsoft.com/library/0d87b445-a342-4369-9b3f-91d07fd7e114)。  
  
   
  
## Examples  
 下列範例會建立訂購比薩的語音辨識文法。 其開頭為選擇性，開啟的片語，後面接著一到四個配料，並關閉 「 披薩 」 這個字。  
  
```csharp  
  
private static Grammar CreatePizzaGrammar()  
{  
  
  // Create a Choices object with alternatives for toppings.  
  Choices toppings = new Choices(new string[] {  
    "cheese", "mushroom", "tomato", "onion",  
    "anchovy", "chicken", "pepperoni"});  
  
  // Create a GrammarBuilder and append the Choices object.  
  GrammarBuilder andToppings = new GrammarBuilder("and", 0, 1);  
  andToppings.Append(toppings);  
  
  // Construct the phrase.  
  GrammarBuilder gb = new GrammarBuilder("I would like a", 0, 1);  
  gb.Append(toppings);  
  gb.Append(new GrammarBuilder(andToppings, 0, 3));  
  gb.Append("pizza");  
  
  // Create the Grammar from the GrammarBuilder.  
  Grammar grammar = new Grammar(gb);  
  grammar.Name = "Pizza Order";  
  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立新的<see cref="T:System.Speech.Recognition.GrammarBuilder" />，其中包含兩個文法項目的序列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 靜態<xref:System.Speech.Recognition.GrammarBuilder.Add%2A>方法會提供另一種機制，供您可以結合各種類型建立多樣性和文法的彈性建置時<xref:System.Speech.Recognition.GrammarBuilder>。 這些方法會對應至靜態<xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A>方法，也會定義於<xref:System.Speech.Recognition.GrammarBuilder>類別。 參數的順序會決定項目的順序，在新<xref:System.Speech.Recognition.GrammarBuilder>。  
  
 A<xref:System.Speech.Recognition.GrammarBuilder>也可從取得<xref:System.Speech.Recognition.Choices>， <xref:System.Speech.Recognition.SemanticResultKey>， <xref:System.Speech.Recognition.SemanticResultValue>，並[字串](https://go.microsoft.com/fwlink/?LinkId=159733)物件。 如需詳細資訊，請參閱 <<c0> <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> 和<xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A>運算子。  
  
> [!IMPORTANT]
>  語音辨識器在使用語音辨識文法包含相同的索引鍵名稱重複語意的項目或多個語意的項目可以重複修改相同的語意元素的值時，可以擲回例外狀況。 
  
 如需有關建立和使用語音辨識文法的詳細資訊，請參閱 <<c0> [ 語音辨識](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361633(v=office.14))並[建立 GrammarBuilder 文法](https://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (System.Speech.Recognition.Choices choices, System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(class System.Speech.Recognition.Choices choices, class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::Speech::Recognition::Choices ^ choices, System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="static member Add : System.Speech.Recognition.Choices * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (choices, builder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="choices">第一個文法項目，代表一組替代項目。</param>
        <param name="builder">第二個文法項目。</param>
        <summary>建立新的 <see cref="T:System.Speech.Recognition.GrammarBuilder" />，其中包含 <see cref="T:System.Speech.Recognition.Choices" /> 物件，後面緊接著 <see cref="T:System.Speech.Recognition.GrammarBuilder" /> 物件。</summary>
        <returns><see cref="T:System.Speech.Recognition.GrammarBuilder" />，適用於 <paramref name="choices" /> 項目後面緊接著 <paramref name="builder" /> 項目的序列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> 支援從下列類別的隱含轉換：  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 這個方法會接受如上面所列的物件`builder`參數。  
  
 如需詳細資訊，請參閱 <<c0> <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> 和<xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A>運算子。  
  
> [!IMPORTANT]
>  當您合併<xref:System.Speech.Recognition.Choices>並<xref:System.Speech.Recognition.GrammarBuilder>包含物件<xref:System.Speech.Recognition.SemanticResultValue>或<xref:System.Speech.Recognition.SemanticResultKey>執行個體，請確定您有避免建立重複的語意項目具有相同索引鍵的名稱或多個語意的項目可以重複修改<xref:System.Speech.Recognition.SemanticValue.Value%2A>屬性<xref:System.Speech.Recognition.SemanticValue>物件。 語音辨識器在遇到這些情況下，可以擲回例外狀況。 如需有關如何建置包含語意資訊的語音辨識文法的詳細資訊，請參閱[新增至 GrammarBuilder 文法的語意](https://msdn.microsoft.com/library/hh361581.aspx)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (System.Speech.Recognition.GrammarBuilder builder, System.Speech.Recognition.Choices choices);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(class System.Speech.Recognition.GrammarBuilder builder, class System.Speech.Recognition.Choices choices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.GrammarBuilder,System.Speech.Recognition.Choices)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::Speech::Recognition::GrammarBuilder ^ builder, System::Speech::Recognition::Choices ^ choices);" />
      <MemberSignature Language="F#" Value="static member Add : System.Speech.Recognition.GrammarBuilder * System.Speech.Recognition.Choices -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (builder, choices)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="builder">第一個文法項目。</param>
        <param name="choices">第二個文法項目，這表示一組替代項目。</param>
        <summary>建立新的 <see cref="T:System.Speech.Recognition.GrammarBuilder" />，其中包含 <see cref="T:System.Speech.Recognition.GrammarBuilder" /> 物件，後面緊接著 <see cref="T:System.Speech.Recognition.Choices" /> 物件。</summary>
        <returns><see cref="T:System.Speech.Recognition.GrammarBuilder" />，適用於 <paramref name="builder" /> 項目後面緊接著 <paramref name="choices" /> 項目的序列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> 支援從下列類別的隱含轉換：  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 這個方法會接受如上面所列的物件`builder`參數。  
  
 如需詳細資訊，請參閱 <<c0> <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> 和<xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A>運算子。  
  
> [!IMPORTANT]
>  當您合併<xref:System.Speech.Recognition.Choices>並<xref:System.Speech.Recognition.GrammarBuilder>包含物件<xref:System.Speech.Recognition.SemanticResultValue>或<xref:System.Speech.Recognition.SemanticResultKey>執行個體與其他的文法項目，請確定您有避免建立重複的語意項目具有相同索引鍵的名稱或多個語意的項目可以重複修改<xref:System.Speech.Recognition.SemanticValue.Value%2A>屬性<xref:System.Speech.Recognition.SemanticValue>物件。 語音辨識器在遇到這些情況下，可以擲回例外狀況。 
  
   
  
## Examples  
 下列範例會建立可辨識的兩個片語，語音辨識文法"背景*色彩*"和"設為背景*色彩*"，其中*色彩*選取從一組色彩。 各種類型用來建置最終的文法，例如[字串](https://go.microsoft.com/fwlink/?LinkId=159733)， <xref:System.Speech.Recognition.Choices>，和<xref:System.Speech.Recognition.GrammarBuilder>物件。 明確轉換運算子，在呼叫<xref:System.Speech.Recognition.GrammarBuilder.Add%2A>是選擇性的方法。  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    GrammarBuilder.Add((GrammarBuilder)"Make background", colorChoice);  
  GrammarBuilder setPhrase =  
    GrammarBuilder.Add("Set background to", (GrammarBuilder)colorChoice);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (System.Speech.Recognition.GrammarBuilder builder1, System.Speech.Recognition.GrammarBuilder builder2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(class System.Speech.Recognition.GrammarBuilder builder1, class System.Speech.Recognition.GrammarBuilder builder2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.GrammarBuilder,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (builder1 As GrammarBuilder, builder2 As GrammarBuilder) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::Speech::Recognition::GrammarBuilder ^ builder1, System::Speech::Recognition::GrammarBuilder ^ builder2);" />
      <MemberSignature Language="F#" Value="static member Add : System.Speech.Recognition.GrammarBuilder * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (builder1, builder2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder1" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="builder2" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="builder1">第一個文法項目。</param>
        <param name="builder2">第二個文法項目。</param>
        <summary>建立新的<see cref="T:System.Speech.Recognition.GrammarBuilder" />，其中包含兩個 <see cref="T:System.Speech.Recognition.GrammarBuilder" />物件的序列。</summary>
        <returns><see cref="T:System.Speech.Recognition.GrammarBuilder" />，適用於 <paramref name="builder1" /> 項目後面緊接著 <paramref name="builder2" /> 項目的序列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> 支援從下列類別的隱含轉換：  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 這個方法會接受如上面所列的物件`builder1`或`builder2`參數。  
  
 如需詳細資訊，請參閱 <<c0> <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> 和<xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A>運算子。  
  
> [!IMPORTANT]
>  當您合併<xref:System.Speech.Recognition.Choices>並<xref:System.Speech.Recognition.GrammarBuilder>包含物件<xref:System.Speech.Recognition.SemanticResultValue>或<xref:System.Speech.Recognition.SemanticResultKey>執行個體與其他的文法項目，請確定您有避免建立重複的語意項目具有相同索引鍵的名稱或多個語意的項目可以重複修改<xref:System.Speech.Recognition.SemanticValue.Value%2A>屬性<xref:System.Speech.Recognition.SemanticValue>物件。 語音辨識器在遇到這些情況下，可以擲回例外狀況。 
  
   
  
## Examples  
 下列範例會建立可辨識的兩個片語，語音辨識文法"背景*色彩*"和"設為背景*色彩*"，其中*色彩*選取從一組色彩。 各種類型用來建置最終的文法，例如[字串](https://go.microsoft.com/fwlink/?LinkId=159733)， <xref:System.Speech.Recognition.Choices>，和<xref:System.Speech.Recognition.GrammarBuilder>物件。 明確轉換運算子，在呼叫<xref:System.Speech.Recognition.GrammarBuilder.Add%2A>是選擇性的方法。  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    GrammarBuilder.Add((GrammarBuilder)"Make background", colorChoice);  
  GrammarBuilder setPhrase =  
    GrammarBuilder.Add("Set background to", (GrammarBuilder)colorChoice);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (System.Speech.Recognition.GrammarBuilder builder, string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(class System.Speech.Recognition.GrammarBuilder builder, string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.GrammarBuilder,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (builder As GrammarBuilder, phrase As String) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::Speech::Recognition::GrammarBuilder ^ builder, System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="static member Add : System.Speech.Recognition.GrammarBuilder * string -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (builder, phrase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="builder">第一個文法項目。</param>
        <param name="phrase">第二個文法項目，這表示文字的序列。</param>
        <summary>建立新的 <see cref="T:System.Speech.Recognition.GrammarBuilder" />，其中包含後面接著片語的 <see cref="T:System.Speech.Recognition.GrammarBuilder" /> 物件。</summary>
        <returns><see cref="T:System.Speech.Recognition.GrammarBuilder" />，適用於 <paramref name="builder" /> 項目後面緊接著 <paramref name="phrase" /> 項目的序列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> 支援從下列類別的隱含轉換：  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 這個方法會接受如上面所列的物件`builder`參數。  
  
 如需詳細資訊，請參閱 <<c0> <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> 和<xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A>運算子。  
  
   
  
## Examples  
 下列範例會建立可辨識的兩個片語，語音辨識文法"背景*色彩*"和"設為背景*色彩*"，其中*色彩*選取從一組色彩。 各種類型用來建置最終的文法，例如[字串](https://go.microsoft.com/fwlink/?LinkId=159733)， <xref:System.Speech.Recognition.Choices>，和<xref:System.Speech.Recognition.GrammarBuilder>物件。 明確轉換運算子，在呼叫<xref:System.Speech.Recognition.GrammarBuilder.Add%2A>是選擇性的方法。  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    GrammarBuilder.Add((GrammarBuilder)"Make background", colorChoice);  
  GrammarBuilder setPhrase =  
    GrammarBuilder.Add("Set background to", (GrammarBuilder)colorChoice);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (string phrase, System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(string phrase, class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.String,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (phrase As String, builder As GrammarBuilder) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::String ^ phrase, System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="static member Add : string * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (phrase, builder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="phrase">第一個文法項目，這表示文字的序列。</param>
        <param name="builder">第二個文法項目。</param>
        <summary>建立新的 <see cref="T:System.Speech.Recognition.GrammarBuilder" />，其中包含後面接著 <see cref="T:System.Speech.Recognition.GrammarBuilder" /> 物件的片語。</summary>
        <returns><see cref="T:System.Speech.Recognition.GrammarBuilder" />，適用於 <paramref name="phrase" /> 項目後面緊接著 <paramref name="builder" /> 項目的序列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> 支援從下列類別的隱含轉換：  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 這個方法會接受如上面所列的物件`builder`參數。  
  
 如需詳細資訊，請參閱 <<c0> <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> 和<xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A>運算子。  
  
   
  
## Examples  
 下列範例會建立可辨識的兩個片語，語音辨識文法"背景*色彩*"和"設為背景*色彩*"，其中*色彩*選取從一組色彩。 各種類型用來建置最終的文法，例如[字串](https://go.microsoft.com/fwlink/?LinkId=159733)， <xref:System.Speech.Recognition.Choices>，和<xref:System.Speech.Recognition.GrammarBuilder>物件。 明確轉換運算子，在呼叫<xref:System.Speech.Recognition.GrammarBuilder.Add%2A>是選擇性的方法。  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    GrammarBuilder.Add((GrammarBuilder)"Make background", colorChoice);  
  GrammarBuilder setPhrase =  
    GrammarBuilder.Add("Set background to", (GrammarBuilder)colorChoice);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將文法項目附加至目前的文法項目序列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這些方法來附加至現有的文法項目<xref:System.Speech.Recognition.GrammarBuilder>。 當您建立文法項目時，您可以將它們附加至現有的產生器，以漸進方式開發 語音辨識文法的條件約束。 每個項目會加入至目前的項目序列的結尾。  
  
 此方法有附加的多載<xref:System.Speech.Recognition.GrammarBuilder>， <xref:System.String>， <xref:System.Speech.Recognition.Choices>， <xref:System.Speech.Recognition.SemanticResultKey>，和<xref:System.Speech.Recognition.SemanticResultValue>物件。  
  
> [!IMPORTANT]
>  語音辨識器在使用語音辨識文法包含相同的索引鍵名稱重複語意的項目或多個語意的項目可以重複修改相同的語意元素的值時，可以擲回例外狀況。 
  
 如需有關建立和使用語音辨識文法的詳細資訊，請參閱 <<c0> [ 語音辨識](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361633(v=office.14))並[建立 GrammarBuilder 文法](https://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.Choices alternateChoices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.Choices alternateChoices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (alternateChoices As Choices)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::Choices ^ alternateChoices);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.Choices -&gt; unit" Usage="grammarBuilder.Append alternateChoices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="alternateChoices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="alternateChoices">要附加的一組替代項目。</param>
        <summary>將一組替代項目附加至目前的文法項目序列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `alternateChoices` 會加入至目前的項目序列的結尾。  
  
> [!IMPORTANT]
>  當您附加<xref:System.Speech.Recognition.Choices>包含的物件<xref:System.Speech.Recognition.SemanticResultValue>或是<xref:System.Speech.Recognition.SemanticResultKey>執行個體<xref:System.Speech.Recognition.GrammarBuilder>物件，請確定您有避免建立重複的語意項目具有相同索引鍵的名稱或多個在語意，可以重複的項目修改<xref:System.Speech.Recognition.SemanticValue.Value%2A>屬性<xref:System.Speech.Recognition.SemanticValue>物件。 語音辨識器在遇到這些情況下，可以擲回例外狀況。
  
   
  
## Examples  
 下列範例會建立其中 「 電話 」 這個字是選擇性片語，例如"At work 的呼叫 James"和"呼叫 Anne 在她的行動電話上，「 語音辨識文法。 此範例強調使用<xref:System.Speech.Recognition.GrammarBuilder.Append%2A>方法。  
  
```csharp  
  
public static Grammar CreatePhonePhrase()  
{  
  // Create alternatives for person names, locations, devices, and pronouns.  
  Choices personChoice = new Choices(new string[] {"Anne", "James", "Mary", "Sam"});  
  Choices locationChoice = new Choices(new string[] {"home", "work"});  
  Choices deviceChoice = new Choices(new string[] {"home", "work", "cell"});  
  Choices pronounChoice = new Choices(new string[] {"his", "her"});  
  
  // Create a phrase for the receiving device, which optionally contains the word "phone".  
  GrammarBuilder devicePhrase = new GrammarBuilder(pronounChoice);  
  devicePhrase.Append(deviceChoice);  
  devicePhrase.Append("phone", 0, 1);  
  
  // Create alternatives for phrases specifying a device or a location.  
  GrammarBuilder atLocation = new GrammarBuilder("at");  
  atLocation.Append(locationChoice);  
  
  GrammarBuilder onDevice = new GrammarBuilder("on");  
  onDevice.Append(devicePhrase);  
  
  Choices howChoice = new Choices(new GrammarBuilder[] {atLocation, onDevice});  
  
  // Build the final phrase.  
  GrammarBuilder callWho = new GrammarBuilder("Call");  
  callWho.Append(personChoice);  
  callWho.Append(howChoice);  
  
  // Create the Grammar object.  
  Grammar callGrammar = new Grammar(callWho);  
  callGrammar.Name = "Call Grammar";  
  
  return callGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (builder As GrammarBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.GrammarBuilder -&gt; unit" Usage="grammarBuilder.Append builder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="builder">要附加的文法項目。</param>
        <summary>將文法項目附加至目前的文法項目序列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `builder` 會加入至目前的文法項目序列的結尾。  
  
> [!NOTE]
>  當您附加<xref:System.Speech.Recognition.GrammarBuilder>包含的物件<xref:System.Speech.Recognition.SemanticResultValue>或是<xref:System.Speech.Recognition.SemanticResultKey>執行個體<xref:System.Speech.Recognition.GrammarBuilder>物件，請確定您有避免建立重複的語意項目具有相同索引鍵的名稱或多個在語意，可以重複的項目修改<xref:System.Speech.Recognition.SemanticValue.Value%2A>屬性<xref:System.Speech.Recognition.SemanticValue>物件。 語音辨識器在遇到這些情況下，可以擲回例外狀況。 
  
   
  
## Examples  
 下列範例會建立其中 「 電話 」 這個字是選擇性片語，例如"At work 的呼叫 James"和"呼叫 Anne 在她的行動電話上，「 語音辨識文法。 <xref:System.Speech.Recognition.GrammarBuilder> 和<xref:System.Speech.Recognition.Choices>物件用來建構文法。 此範例強調使用<xref:System.Speech.Recognition.GrammarBuilder.Append%2A>方法。  
  
```csharp  
  
public static Grammar CreatePhonePhrase()  
{  
  // Create alternatives for person names, locations, devices, and pronouns.  
  Choices personChoice = new Choices(new string[] {"Anne", "James", "Mary", "Sam"});  
  Choices locationChoice = new Choices(new string[] {"home", "work"});  
  Choices deviceChoice = new Choices(new string[] {"home", "work", "cell"});  
  Choices pronounChoice = new Choices(new string[] {"his", "her"});  
  
  // Create a phrase for the receiving device, which optionally contains the word "phone".  
  GrammarBuilder devicePhrase = new GrammarBuilder(pronounChoice);  
  devicePhrase.Append(deviceChoice);  
  devicePhrase.Append("phone", 0, 1);  
  
  // Create alternatives for phrases specifying a device or a location.  
  GrammarBuilder atLocation = new GrammarBuilder("at");  
  atLocation.Append(locationChoice);  
  
  GrammarBuilder onDevice = new GrammarBuilder("on");  
  onDevice.Append(devicePhrase);  
  
  Choices howChoice = new Choices(new GrammarBuilder[] {atLocation, onDevice});  
  
  // Build the final phrase.  
  GrammarBuilder callWho = new GrammarBuilder("Call");  
  callWho.Append(personChoice);  
  callWho.Append(howChoice);  
  
  // Create the Grammar object.  
  Grammar callGrammar = new Grammar(callWho);  
  callGrammar.Name = "Call Grammar";  
  
  return callGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.SemanticResultKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.SemanticResultKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.SemanticResultKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (key As SemanticResultKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::SemanticResultKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.SemanticResultKey -&gt; unit" Usage="grammarBuilder.Append key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Speech.Recognition.SemanticResultKey" />
      </Parameters>
      <Docs>
        <param name="key">要附加的語意索引鍵。</param>
        <summary>將語意索引鍵附加至目前的文法項目序列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `key` 會加入至目前的項目序列的結尾。  
  
> [!IMPORTANT]
>  當您附加<xref:System.Speech.Recognition.SemanticResultValue>或是<xref:System.Speech.Recognition.SemanticResultKey>執行個體<xref:System.Speech.Recognition.GrammarBuilder>物件，請確定您有避免建立重複的語意項目具有相同索引鍵的名稱或多個語意的項目可以重複修改<xref:System.Speech.Recognition.SemanticValue.Value%2A>屬性<xref:System.Speech.Recognition.SemanticValue>物件。 語音辨識器在遇到這些情況下，可以擲回例外狀況。
  
   
  
## Examples  
 下列範例是主控台應用程式選擇的班機的來源和目的地城市的一部分。 應用程式會辨識片語，例如 「 我想要從邁阿密飛抵芝加哥 」。 處理常式<xref:System.Speech.Recognition.SpeechRecognitionEngine.SpeechRecognized>事件會使用<xref:System.Speech.Recognition.SemanticResultKey>擷取在指定的機場代碼<xref:System.Speech.Recognition.SemanticResultValue>的來源和目的地的城市。  
  
```csharp  
using System;  
using System.Speech.Recognition;  
  
namespace SampleRecognition  
{  
  class Program  
  {  
    static void Main(string[] args)  
  
    // Initialize an in-process speech recognition engine.  
    {  
      using (SpeechRecognitionEngine recognizer =  
         new SpeechRecognitionEngine())  
      {  
  
        // Create a Choices object and add  cities and airport codes  
        // using SemanticResultValue objects.  
        Choices cities = new Choices();  
        cities.Add(new SemanticResultValue("Chicago", "ORD"));  
        cities.Add(new SemanticResultValue("Boston", "BOS"));  
        cities.Add(new SemanticResultValue("Miami", "MIA"));  
        cities.Add(new SemanticResultValue("Dallas", "DFW"));  
  
        // Build the phrase and add SemanticResultKeys.  
        GrammarBuilder chooseCities = new GrammarBuilder();  
        chooseCities.Append("I want to fly from");  
        chooseCities.Append(new SemanticResultKey("origin", cities));  
        chooseCities.Append("to");  
        chooseCities.Append(new SemanticResultKey("destination", cities));  
  
        // Build a Grammar object from the GrammarBuilder.  
        Grammar bookFlight = new Grammar(chooseCities);  
        bookFlight.Name = "Book Flight";  
  
        // Add a handler for the LoadGrammarCompleted event.  
        recognizer.LoadGrammarCompleted +=   
          new EventHandler<LoadGrammarCompletedEventArgs>(recognizer_LoadGrammarCompleted);  
  
        // Add a handler for the SpeechRecognized event.  
        recognizer.SpeechRecognized +=   
          new EventHandler<SpeechRecognizedEventArgs>(recognizer_SpeechRecognized);  
  
        // Configure the input to the recognizer.  
        recognizer.SetInputToDefaultAudioDevice();  
  
        // Load the grammar object and start recognition.  
        recognizer.LoadGrammarAsync(bookFlight);  
        recognizer.RecognizeAsync();  
  
        // Keep the console window open.  
        Console.ReadLine();  
      }  
    }  
  
    // Handle the LoadGrammarCompleted event.  
    static void recognizer_LoadGrammarCompleted(object sender, LoadGrammarCompletedEventArgs e)  
    {  
      Console.WriteLine("Grammar loaded: " + e.Grammar.Name);  
      Console.WriteLine();  
    }  
  
    // Handle the SpeechRecognized event.  
    static void recognizer_SpeechRecognized(object sender, SpeechRecognizedEventArgs e)  
    {  
      Console.WriteLine("Speech recognized:  " + e.Result.Text);  
      Console.WriteLine();  
      Console.WriteLine("Semantic results:");  
      Console.WriteLine("  The flight origin is " + e.Result.Semantics["origin"].Value);  
      Console.WriteLine("  The flight destination is " + e.Result.Semantics["destination"].Value);  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.SemanticResultValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.SemanticResultValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.SemanticResultValue)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (value As SemanticResultValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::SemanticResultValue ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.SemanticResultValue -&gt; unit" Usage="grammarBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Speech.Recognition.SemanticResultValue" />
      </Parameters>
      <Docs>
        <param name="value">要附加的語意值。</param>
        <summary>將語意值附加至目前的文法項目序列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` 會加入至目前的項目序列的結尾。  
  
> [!IMPORTANT]
>  當您附加<xref:System.Speech.Recognition.SemanticResultValue>或是<xref:System.Speech.Recognition.SemanticResultKey>執行個體<xref:System.Speech.Recognition.GrammarBuilder>物件，請確定您有避免建立重複的語意項目具有相同索引鍵的名稱或多個語意的項目可以重複修改<xref:System.Speech.Recognition.SemanticValue.Value%2A>屬性<xref:System.Speech.Recognition.SemanticValue>物件。 語音辨識器在遇到這些情況下，可以擲回例外狀況。
  
   
  
## Examples  
 下列範例是主控台應用程式選擇的班機的來源和目的地城市的一部分。 應用程式會辨識片語，例如 「 我想要從邁阿密飛抵芝加哥 」。 處理常式<xref:System.Speech.Recognition.SpeechRecognitionEngine.SpeechRecognized>事件會使用<xref:System.Speech.Recognition.SemanticResultKey>擷取在指定的機場代碼<xref:System.Speech.Recognition.SemanticResultValue>的來源和目的地的城市。  
  
```csharp  
  
using System;  
using System.Speech.Recognition;  
  
namespace SampleRecognition  
{  
  class Program  
  {  
    static void Main(string[] args)  
  
    // Initialize an in-process speech recognition engine.  
    {  
      using (SpeechRecognitionEngine recognizer =  
         new SpeechRecognitionEngine())  
      {  
  
        // Create GrammarBuilder objects and append SemanticResultValue objects   
        // that contain cities and airport codes.  
  
        GrammarBuilder chicago = new GrammarBuilder();  
        chicago.Append(new SemanticResultValue("Chicago", "ORD"));  
  
        GrammarBuilder boston = new GrammarBuilder();  
        boston.Append(new SemanticResultValue("Boston", "BOS"));  
  
        GrammarBuilder miami = new GrammarBuilder();  
        miami.Append(new SemanticResultValue("Miami", "MIA"));  
  
        GrammarBuilder dallas = new GrammarBuilder();  
        dallas.Append(new SemanticResultValue("Dallas", "DFW"));  
  
        // Create a Choices object and add the cities using implicit conversion from   
        // SemanticResultValue to GrammarBuilder.  
        Choices cities = new Choices();  
        cities.Add(new Choices(new GrammarBuilder[] { chicago, boston, miami, dallas }));  
  
        // Build the phrase and add SemanticResultKeys.  
        GrammarBuilder chooseCities = new GrammarBuilder();  
        chooseCities.Append("I want to fly from");  
        chooseCities.Append(new SemanticResultKey("origin", cities));  
        chooseCities.Append("to");  
        chooseCities.Append(new SemanticResultKey("destination", cities));  
  
        // Build a Grammar object from the GrammarBuilder.  
        Grammar bookFlight = new Grammar(chooseCities);  
        bookFlight.Name = "Book Flight";  
  
        // Add a handler for the LoadGrammarCompleted event.  
        recognizer.LoadGrammarCompleted +=   
          new EventHandler<LoadGrammarCompletedEventArgs>(recognizer_LoadGrammarCompleted);  
  
        // Add a handler for the SpeechRecognized event.  
        recognizer.SpeechRecognized +=   
          new EventHandler<SpeechRecognizedEventArgs>(recognizer_SpeechRecognized);  
  
        // Configure the input to the recognizer.  
        recognizer.SetInputToDefaultAudioDevice();  
  
        // Load the grammar object and start recognition.  
        recognizer.LoadGrammarAsync(bookFlight);  
        recognizer.RecognizeAsync();  
  
        // Keep the console window open.  
        Console.ReadLine();  
      }  
    }  
    // Handle the LoadGrammarCompleted event.  
    static void recognizer_LoadGrammarCompleted(object sender, LoadGrammarCompletedEventArgs e)  
    {  
      Console.WriteLine("Grammar loaded: " + e.Grammar.Name);  
      Console.WriteLine();  
    }  
  
    // Handle the SpeechRecognized event.  
    static void recognizer_SpeechRecognized(object sender, SpeechRecognizedEventArgs e)  
    {  
      Console.WriteLine("Speech recognized:  " + e.Result.Text);  
      Console.WriteLine();  
      Console.WriteLine("Semantic results:");  
      Console.WriteLine("  The flight origin is " + e.Result.Semantics["origin"].Value);  
      Console.WriteLine("  The flight destination is " + e.Result.Semantics["destination"].Value);  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (phrase As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="member this.Append : string -&gt; unit" Usage="grammarBuilder.Append phrase" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="phrase">要附加的單字序列。</param>
        <summary>將片語附加至目前的文法項目序列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `phrase` 會加入至目前的項目序列的結尾。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (string phrase, System.Speech.Recognition.SubsetMatchingMode subsetMatchingCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(string phrase, valuetype System.Speech.Recognition.SubsetMatchingMode subsetMatchingCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.String,System.Speech.Recognition.SubsetMatchingMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (phrase As String, subsetMatchingCriteria As SubsetMatchingMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::String ^ phrase, System::Speech::Recognition::SubsetMatchingMode subsetMatchingCriteria);" />
      <MemberSignature Language="F#" Value="member this.Append : string * System.Speech.Recognition.SubsetMatchingMode -&gt; unit" Usage="grammarBuilder.Append (phrase, subsetMatchingCriteria)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="subsetMatchingCriteria" Type="System.Speech.Recognition.SubsetMatchingMode" />
      </Parameters>
      <Docs>
        <param name="phrase">要附加的單字序列。</param>
        <param name="subsetMatchingCriteria">文法用來辨識片語的比對模式。</param>
        <summary>將片語子集的項目附加至目前的文法項目序列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 部分項目會加入至目前的項目序列的結尾。 如需有關如何建置使用字串的語音辨識文法的詳細資訊，請參閱 <<c0> [ 使用的字串，來建立 GrammarBuilder 文法](https://msdn.microsoft.com/library/0d87b445-a342-4369-9b3f-91d07fd7e114)。  
  
 如需詳細使用子集比對模式的詳細資訊，請參閱<xref:System.Speech.Recognition.SubsetMatchingMode?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下列範例會針對每一個建立語音辨識文法<xref:System.Speech.Recognition.SubsetMatchingMode>值。 比方說，產生的文法`OrderedSubset`辨識片語，"三個四個五個"和"一個三個五個"，及文法`Subsequence`辨識片語 」 三個四個五個"，但不是片語，"一個三個五個"。  
  
```csharp  
  
private Grammar[] CreateSubsetMatchTest()  
{  
  List<Grammar> grammars = new List<Grammar>(4);  
  
  string phrase = "one two three four five six";  
  foreach (SubsetMatchingMode mode in  
    Enum.GetValues(typeof(SubsetMatchingMode)))  
  {  
    GrammarBuilder gb = new GrammarBuilder();  
    gb.Append(phrase, mode);  
  
    Grammar grammar = new Grammar(gb);  
    grammar.Name = mode.ToString();  
    grammars.Add(grammar);  
  }  
  
  return grammars.ToArray();  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.GrammarBuilder builder, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.GrammarBuilder builder, int32 minRepeat, int32 maxRepeat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.GrammarBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (builder As GrammarBuilder, minRepeat As Integer, maxRepeat As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::GrammarBuilder ^ builder, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.GrammarBuilder * int * int -&gt; unit" Usage="grammarBuilder.Append (builder, minRepeat, maxRepeat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="minRepeat" Type="System.Int32" />
        <Parameter Name="maxRepeat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="builder">要附加的重複文法項目。</param>
        <param name="minRepeat">為構成相符項目，輸入必須和 <paramref name="builder" /> 所定義的項目比對相符的最少次數。</param>
        <param name="maxRepeat">為構成相符項目，輸入可以和 <paramref name="builder" /> 所定義的項目比對相符的最大次數。</param>
        <summary>將重複的文法項目附加至目前的文法項目序列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值`minRepeat`必須是大於或等於 0 且小於或等於值`maxRepeat`。  
  
> [!IMPORTANT]
>  當您附加<xref:System.Speech.Recognition.GrammarBuilder>包含的物件<xref:System.Speech.Recognition.SemanticResultValue>或是<xref:System.Speech.Recognition.SemanticResultKey>執行個體<xref:System.Speech.Recognition.GrammarBuilder>物件，請確定您有避免建立重複的語意項目具有相同索引鍵的名稱或多個在語意，可以重複的項目修改<xref:System.Speech.Recognition.SemanticValue.Value%2A>屬性<xref:System.Speech.Recognition.SemanticValue>物件。 語音辨識器在遇到這些情況下，可以擲回例外狀況。
  
   
  
## Examples  
 下列範例會建立其中 「 電話 」 這個字是選擇性片語，例如"At work 的呼叫 James"和"呼叫 Anne 在她的行動電話上，「 語音辨識文法。 <xref:System.Speech.Recognition.GrammarBuilder> 和<xref:System.Speech.Recognition.Choices>物件用來建構文法。 此範例強調使用<xref:System.Speech.Recognition.GrammarBuilder.Append%2A>方法。  
  
```csharp  
  
public static Grammar CreatePhonePhrase()  
{  
  // Create alternatives for person names, locations, devices, and pronouns.  
  Choices personChoice = new Choices(new string[] {"Anne", "James", "Mary", "Sam"});  
  Choices locationChoice = new Choices(new string[] {"home", "work"});  
  Choices deviceChoice = new Choices(new string[] {"home", "work", "cell"});  
  Choices pronounChoice = new Choices(new string[] {"his", "her"});  
  
  // Create a phrase for the receiving device, which optionally contains the word "phone".  
  GrammarBuilder devicePhrase = new GrammarBuilder(pronounChoice);  
  devicePhrase.Append(deviceChoice);  
  devicePhrase.Append("phone", 0, 1);  
  
  // Create alternatives for phrases specifying a device or a location.  
  GrammarBuilder atLocation = new GrammarBuilder("at");  
  atLocation.Append(locationChoice);  
  
  GrammarBuilder onDevice = new GrammarBuilder("on");  
  onDevice.Append(devicePhrase);  
  
  Choices howChoice = new Choices(new GrammarBuilder[] {atLocation, onDevice});  
  
  // Build the final phrase.  
  GrammarBuilder callWho = new GrammarBuilder("Call");  
  callWho.Append(personChoice);  
  callWho.Append(howChoice);  
  
  // Create the Grammar object.  
  Grammar callGrammar = new Grammar(callWho);  
  callGrammar.Name = "Call Grammar";  
  
  return callGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (string phrase, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(string phrase, int32 minRepeat, int32 maxRepeat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (phrase As String, minRepeat As Integer, maxRepeat As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::String ^ phrase, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="F#" Value="member this.Append : string * int * int -&gt; unit" Usage="grammarBuilder.Append (phrase, minRepeat, maxRepeat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="minRepeat" Type="System.Int32" />
        <Parameter Name="maxRepeat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="phrase">要附加的單字重複序列。</param>
        <param name="minRepeat">為構成相符項目，輸入必須和 <paramref name="phrase" /> 比對相符的最少次數。</param>
        <param name="maxRepeat">為構成相符項目，輸入可以和 <paramref name="phrase" /> 比對相符的最大次數。</param>
        <summary>將重複的片語附加至目前的文法項目序列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值`minRepeat`必須是大於或等於 0 且小於或等於值`maxRepeat`。  
  
   
  
## Examples  
 下列範例會建立其中 「 電話 」 這個字是選擇性片語，例如"At work 的呼叫 James"和"呼叫 Anne 在她的行動電話上，「 語音辨識文法。 <xref:System.Speech.Recognition.GrammarBuilder> 和<xref:System.Speech.Recognition.Choices>物件用來建構文法。 此範例強調使用<xref:System.Speech.Recognition.GrammarBuilder.Append%2A>方法。  
  
```csharp  
  
public static Grammar CreatePhonePhrase()  
{  
  // Create alternatives for person names, locations, devices, and pronouns.  
  Choices personChoice = new Choices(new string[] {"Anne", "James", "Mary", "Sam"});  
  Choices locationChoice = new Choices(new string[] {"home", "work"});  
  Choices deviceChoice = new Choices(new string[] {"home", "work", "cell"});  
  Choices pronounChoice = new Choices(new string[] {"his", "her"});  
  
  // Create a phrase for the receiving device, which optionally contains the word "phone".  
  GrammarBuilder devicePhrase = new GrammarBuilder(pronounChoice);  
  devicePhrase.Append(deviceChoice);  
  devicePhrase.Append("phone", 0, 1);  
  
  // Create alternatives for phrases specifying a device or a location.  
  GrammarBuilder atLocation = new GrammarBuilder("at");  
  atLocation.Append(locationChoice);  
  
  GrammarBuilder onDevice = new GrammarBuilder("on");  
  onDevice.Append(devicePhrase);  
  
  Choices howChoice = new Choices(new GrammarBuilder[] {atLocation, onDevice});  
  
  // Build the final phrase.  
  GrammarBuilder callWho = new GrammarBuilder("Call");  
  callWho.Append(personChoice);  
  callWho.Append(howChoice);  
  
  // Create the Grammar object.  
  Grammar callGrammar = new Grammar(callWho);  
  callGrammar.Name = "Call Grammar";  
  
  return callGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendDictation">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將聽寫文法附加至目前的文法項目序列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder.AppendDictation%2A>方法可讓您將聽寫文法附加至規則<xref:System.Speech.Recognition.GrammarBuilder>。  
  
 如需有關聽寫文法的詳細資訊，請參閱<xref:System.Speech.Recognition.DictationGrammar>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendDictation">
      <MemberSignature Language="C#" Value="public void AppendDictation ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendDictation() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendDictation ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendDictation();" />
      <MemberSignature Language="F#" Value="member this.AppendDictation : unit -&gt; unit" Usage="grammarBuilder.AppendDictation " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將預設聽寫文法附加至目前的文法項目序列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需有關聽寫文法的詳細資訊，請參閱<xref:System.Speech.Recognition.DictationGrammar>。  
  
   
  
## Examples  
 下列範例會建立包含語音輸入的語音辨識文法。  
  
```csharp  
  
GrammarBuilder builder = new GrammarBuilder();  
builder.Append("begin");  
builder.AppendDictation();  
builder.Append("end");  
Grammar grammarWithDictation = new Grammar(builder);  
grammarWithDictation.Name = "Grammar with Dictation";  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.DictationGrammar" />
      </Docs>
    </Member>
    <Member MemberName="AppendDictation">
      <MemberSignature Language="C#" Value="public void AppendDictation (string category);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendDictation(string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendDictation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendDictation (category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendDictation(System::String ^ category);" />
      <MemberSignature Language="F#" Value="member this.AppendDictation : string -&gt; unit" Usage="grammarBuilder.AppendDictation category" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="category">要附加之聽寫文法的分類。</param>
        <summary>將指定的聽寫文法附加至目前的文法項目序列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要使用拼字檢查聽寫文法，請設定`category`至`spelling`。  
  
 如需有關聽寫文法的詳細資訊，請參閱<xref:System.Speech.Recognition.DictationGrammar>。  
  
   
  
## Examples  
 下列範例會建立語音辨識文法，其中包含拼字聽寫文法規則。  
  
```csharp  
  
GrammarBuilder builder = new GrammarBuilder();  
builder.Append("begin");  
builder.AppendDictation("spelling");  
builder.Append("end");  
Grammar grammarWithDictation = new Grammar(builder);  
grammarWithDictation.Name = "Grammar with Dictation";  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.DictationGrammar" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendRuleReference">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將文法檔案或文法規則附加至目前的文法項目序列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A>方法可以附加的文法檔案或文法規則從檔案。 這些方法可讓應用程式，使使用預先部署或公開可用的文法規則進行剖析。 應用程式必須具有讀取權限，以指定的文法檔案的位置。  
  
 這些方法可以讀取下列格式的語音辨識文法。  
  
-   符合 W3C XML 格式檔[語音辨識文法規格 (SRGS) 1.0 版](https://go.microsoft.com/fwlink/?LinkId=201761)  
  
-   符合 Microsoft 語音辨識文法二進位格式 （.cfg 副檔名） 的二進位檔  
  
 編譯的 XML 格式 SRGS 文法檔案，以具有.cfg 副檔名的二進位文法檔案可以減少時間供搜尋的相符項目，特別是當文法需要大量的單字和片語辨識。 如需編譯成 CFG 二進位格式的 SRGS 文法的詳細資訊，請參閱<xref:System.Speech.Recognition.SrgsGrammar.SrgsGrammarCompiler>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendRuleReference">
      <MemberSignature Language="C#" Value="public void AppendRuleReference (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendRuleReference(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendRuleReference (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendRuleReference(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.AppendRuleReference : string -&gt; unit" Usage="grammarBuilder.AppendRuleReference path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">檔案的路徑或通用資源識別項 (URI)，這個檔案以支援的格式來描述語音辨識文法。</param>
        <summary>將文法定義檔附加至目前的文法項目序列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 所提供的 URI`path`引數可以是本機或遠端。 應用程式必須具有讀取權限，以指定的文法檔案的位置。  
  
 W3C 語音辨識文法規格 (SRGS) 表示法可以定義根規則。 這個方法會附加文法中，從其根規則，到目前的文法項目序列。 若要將附加特定的文法規則，請使用<xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A>方法。  
  
   
  
## Examples  
 下列 C# 範例會建立名為的規則會使用語音辨識文法`Cities`在本機的 SRGS 檔案中，cities.grxml。 Cities.grxml 檔案的內容會出現下列 C# 程式碼範例。  
  
```csharp  
  
private static Grammar CreateCitiesGrammar1()  
{  
  GrammarBuilder builder = new GrammarBuilder();  
  builder.AppendRuleReference("file://c:/temp/cities.grxml");  
  
  Grammar citiesGrammar = new Grammar(builder);  
  citiesGrammar.Name = "Cities Grammar 1";  
  return citiesGrammar;  
}  
```  
  
```xml  
  
<?xml version="1.0" encoding="UTF-16" ?>  
<grammar version="1.0" xml:lang="en-US"  
         xmlns="http://www.w3.org/2001/06/grammar"  
         tag-format="semantics/1.0" root="Main">  
  
  <!-- cities.grxml:   
    Defines an SRGS grammar for requesting a flight. This grammar includes  
    a Cities rule that lists the cities that can be used for departures  
    and destinations. -->  
  
  <rule id="Main">  
    <item>  
      I would like to fly from <ruleref uri="#Cities"/>  
      to <ruleref uri="#Cities"/>  
    </item>  
  </rule>  
  
  <rule id="Cities" scope="public">  
    <one-of>  
      <item> Seattle </item>  
      <item> Los Angeles </item>  
      <item> New York </item>  
      <item> Miami </item>  
    </one-of>  
  </rule>  
</grammar>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
      </Docs>
    </Member>
    <Member MemberName="AppendRuleReference">
      <MemberSignature Language="C#" Value="public void AppendRuleReference (string path, string rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendRuleReference(string path, string rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendRuleReference (path As String, rule As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendRuleReference(System::String ^ path, System::String ^ rule);" />
      <MemberSignature Language="F#" Value="member this.AppendRuleReference : string * string -&gt; unit" Usage="grammarBuilder.AppendRuleReference (path, rule)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="rule" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">檔案的檔案路徑或通用資源識別項 (URI)，這個檔案以支援的格式來描述語音辨識文法。</param>
        <param name="rule">要附加之規則的識別項，若要附加文法檔案的預設根規則則為 <see langword="null" />。</param>
        <summary>將指定的文法定義檔規則附加至目前的文法項目序列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 所提供的 URI`path`引數可以是本機或遠端。 應用程式必須具有讀取權限，以指定的文法檔案的位置。  
  
 您可以使用使用<xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A>附加以其根規則的文法檔案開頭的方法。  
  
   
  
## Examples  
 下列 C# 範例會建立名為的規則會使用語音辨識文法`Cities`在本機的 SRGS 檔案中，cities.grxml。 Cities.grxml 檔案的內容會出現下列 C# 程式碼範例。  
  
```csharp  
  
private static Grammar CreateCitiesGrammar2()  
{  
  GrammarBuilder builder = new GrammarBuilder();  
  builder.Append("Does");  
  builder.AppendRuleReference(@"c:\temp\cities.grxml", "Cities");  
  builder.Append("have a shuttle");  
  
  Grammar citiesGrammar = new Grammar(builder);  
  citiesGrammar.Name = "Cities Grammar 2";  
  return citiesGrammar;  
}  
```  
  
```xml  
  
<?xml version="1.0" encoding="UTF-8" ?>  
<grammar version="1.0" xml:lang="en-US"  
         xmlns="http://www.w3.org/2001/06/grammar"  
         tag-format="semantics/1.0" root="Main">  
  
  <!-- cities.grxml:   
    Defines an SRGS grammar for requesting a flight. This grammar includes  
    a Cities rule that lists the cities that can be used for departures  
    and destinations. -->  
  
  <rule id="Main">  
    <item>  
      I would like to fly from <ruleref uri="#Cities"/>  
      to <ruleref uri="#Cities"/>  
    </item>  
  </rule>  
  
  <rule id="Cities" scope="public">  
    <one-of>  
      <item> Seattle </item>  
      <item> Los Angeles </item>  
      <item> New York </item>  
      <item> Miami </item>  
    </one-of>  
  </rule>  
</grammar>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
      </Docs>
    </Member>
    <Member MemberName="AppendWildcard">
      <MemberSignature Language="C#" Value="public void AppendWildcard ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendWildcard() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendWildcard ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendWildcard();" />
      <MemberSignature Language="F#" Value="member this.AppendWildcard : unit -&gt; unit" Usage="grammarBuilder.AppendWildcard " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將符合任何輸入的辨識文法項目附加至目前的文法項目序列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 萬用字元元素會加入至目前的項目序列的結尾。  
  
 萬用字元元素比對任何語音的文字。 它不符合背景噪音或無回應。  
  
   
  
## Examples  
 下列範例會建立接受萬用字元的密碼輸入的文法。 此範例會將附加<xref:System.Speech.Recognition.Grammar.SpeechRecognized?displayProperty=nameWithType>事件處理常式來驗證密碼輸入的文法。  
  
```csharp  
private Grammar CreatePasswordGrammar()  
{  
  GrammarBuilder wildcardBuilder = new GrammarBuilder();  
  wildcardBuilder.AppendWildcard();  
  SemanticResultKey passwordKey =  
    new SemanticResultKey("Password", wildcardBuilder);  
  
  GrammarBuilder passwordBuilder =  
    new GrammarBuilder("My Password is");  
  passwordBuilder.Append(passwordKey);  
  
  Grammar passwordGrammar = new Grammar(passwordBuilder);  
  passwordGrammar.Name = "Password input";  
  
  passwordGrammar.SpeechRecognized +=  
    new EventHandler<SpeechRecognizedEventArgs>(  
      PasswordInputHandler);  
  
  return passwordGrammar;  
}  
  
// Handle the SpeechRecognized event for the password grammar.  
private void PasswordInputHandler(object sender, SpeechRecognizedEventArgs e)  
{  
  if (e.Result == null) return;  
  
  RecognitionResult result = e.Result;  
  SemanticValue semantics = e.Result.Semantics;  
  
  if (semantics.ContainsKey("Password"))  
  {  
    RecognizedAudio passwordAudio =  
      result.GetAudioForWordRange(  
        result.Words[3], result.Words[result.Words.Count - 1]);  
  
    if (IsValidPassword(passwordAudio))  
    {  
      Console.WriteLine("Password accepted.");  
  
      // Add code to handle a valid password here.  
    }  
    else  
    {  
      Console.WriteLine("Invalid password.");  
  
      // Add code to handle an invalid password here.  
    }  
  }  
}  
  
// Validate the password input.   
private bool IsValidPassword(RecognizedAudio passwordAudio)  
{  
  Console.WriteLine("Validating password.");  
  
  // Add password validation code here.  
  
  return false;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Culture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Culture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Culture" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.GrammarBuilder.Culture" />
      <MemberSignature Language="VB.NET" Value="Public Property Culture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Culture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Culture : System.Globalization.CultureInfo with get, set" Usage="System.Speech.Recognition.GrammarBuilder.Culture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定語音辨識文法的文化特性。</summary>
        <value><see cref="T:System.Speech.Recognition.GrammarBuilder" /> 的文化特性。 預設為執行中執行緒的 <see cref="P:System.Threading.Thread.CurrentUICulture" /> 屬性。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.Grammar.%23ctor%2A>建構函式建立<xref:System.Speech.Recognition.Grammar>可由對應的文化特性的語音辨識器的物件。 只有<xref:System.Speech.Recognition.GrammarBuilder.Culture%2A>屬性<xref:System.Speech.Recognition.GrammarBuilder>提供 as 文法建構函式的參數用來設定產生的語音辨識文法的文化特性。  
  
 Microsoft Windows 和 System.Speech API 接受所有有效的語言-國家/地區代碼。 若要執行使用中所指定語言的語音辨識`Culture`屬性，支援語言-國家/地區的程式碼必須先安裝的語音辨識引擎。 隨附於 Microsoft Windows 7 的語音辨識引擎會使用下列的語言-國家/地區代碼。  
  
-   en GB。 English (United Kingdom)  
  
-   EN-US。 英文 （美國）  
  
-   de-德國。 德文 （德國）  
  
-   es-ES。 西班牙文 （西班牙）  
  
-   fr-fr。 法文 （法國）  
  
-   若為 JA-JP。 日文 （日本）  
  
-   zh-CN。 中文 （中國）  
  
-   zh-TW。 中文 （台灣）  
  
 兩個字母的語言代碼，例如"en"，"fr"，或也允許"es"。  
  
   
  
## Examples  
 下列範例會建立排序與最多四個配料比薩的語音辨識文法。 它會特別設定<xref:System.Speech.Recognition.GrammarBuilder>物件的文化特性設為 英文 （美國）。  
  
```csharp  
  
private static Grammar CreatePizzaGrammar()  
{  
  
  // Create a Choices object with alternatives for toppings.  
  Choices toppings = new Choices(new string[] {  
    "cheese", "mushroom", "tomato", "onion",  
    "anchovy", "chicken", "pepperoni"});  
  
  // Create a GrammarBuilder and append the Choices object.  
  GrammarBuilder andToppings = new GrammarBuilder("and", 0, 1);  
  andToppings.Append(toppings);  
  
  // Construct the phrase.  
  GrammarBuilder gb = new GrammarBuilder("I would like a", 0, 1);  
  gb.Append(toppings);  
  gb.Append(new GrammarBuilder(andToppings, 0, 3));  
  gb.Append("pizza");  
  
  // Create the Grammar from the GrammarBuilder.  
  Grammar grammar = new Grammar(gb);  
  grammar.Name = "Pizza Order";  
  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.RecognizerInfo" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
      </Docs>
    </Member>
    <Member MemberName="DebugShowPhrases">
      <MemberSignature Language="C#" Value="public string DebugShowPhrases { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DebugShowPhrases" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.GrammarBuilder.DebugShowPhrases" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DebugShowPhrases As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DebugShowPhrases { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DebugShowPhrases : string" Usage="System.Speech.Recognition.GrammarBuilder.DebugShowPhrases" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得顯示 <see cref="T:System.Speech.Recognition.GrammarBuilder" /> 所含文法之內容及結構的字串。</summary>
        <value><see cref="T:System.Speech.Recognition.GrammarBuilder" /> 的目前內容和結構。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會建立排序與最多四個配料比薩的語音辨識文法。 它會將寫入的狀態<xref:System.Speech.Recognition.GrammarBuilder>至主控台，再建立文法。 這個方法會產生下列輸出：  
  
-   `GrammarBuilder status: I would like a [cheese,mushroom,tomato,onion,anchovy,chic ken,pepperoni] and [cheese,mushroom,tomato,onion,anchovy,chicken,pepperoni] pizza`  
  
```csharp  
  
private static Grammar CreatePizzaGrammar()  
{  
  
  // Create a Choices object with alternatives for toppings.  
  Choices toppings = new Choices(new string[] {  
    "cheese", "mushroom", "tomato", "onion",  
    "anchovy", "chicken", "pepperoni"});  
  
  // Create a GrammarBuilder and append the Choices object.  
  GrammarBuilder andToppings = new GrammarBuilder("and", 0, 1);  
  andToppings.Append(toppings);  
  
  // Construct the phrase.  
  GrammarBuilder gb = new GrammarBuilder("I would like a", 0, 1);  
  gb.Append(toppings);  
  gb.Append(new GrammarBuilder(andToppings, 0, 3));  
  gb.Append("pizza");  
  
  // Write the contents and structure of the GrammarBuilder to the console.  
  Console.WriteLine("Grammar content and structure: {0}", gb.DebugShowPhrases);  
  
  // Create the Grammar from the GrammarBuilder.  
  Grammar grammar = new Grammar(gb);  
  grammar.Name = "Pizza Order";  
  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361640(v%3doffice.14)">建立使用 GrammarBuilder 文法</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Addition">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立新的<see cref="T:System.Speech.Recognition.GrammarBuilder" />，其對應至兩個文法項目的序列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 運算元的順序決定項目的順序，在新<xref:System.Speech.Recognition.GrammarBuilder>。  
  
> [!IMPORTANT]
>  注意： 建議您在合併時<xref:System.Speech.Recognition.Choices>或是<xref:System.Speech.Recognition.GrammarBuilder>包含的物件<xref:System.Speech.Recognition.SemanticResultValue>或<xref:System.Speech.Recognition.SemanticResultKey>與其他的文法項目執行個體。 語音辨識器在使用語音辨識文法包含相同的索引鍵名稱重複語意的項目或多個語意的項目可以重複修改相同的語意元素的值時，可以擲回例外狀況。 
  
 如需有關建立和使用語音辨識文法的詳細資訊，請參閱 <<c0> [ 語音辨識](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361633(v=office.14))並[建立 GrammarBuilder 文法](https://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (System.Speech.Recognition.Choices choices, System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(class System.Speech.Recognition.Choices choices, class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::Speech::Recognition::Choices ^ choices, System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Speech.Recognition.Choices * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="choices + builder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="choices">第一個文法項目，代表一組替代項目。</param>
        <param name="builder">第二個文法項目。</param>
        <summary>建立新的 <see cref="T:System.Speech.Recognition.GrammarBuilder" />，其中包含 <see cref="T:System.Speech.Recognition.Choices" /> 物件，後面緊接著 <see cref="T:System.Speech.Recognition.GrammarBuilder" /> 物件。</summary>
        <returns>傳回 <paramref name="choices" /> 參數序列的 <see cref="T:System.Speech.Recognition.GrammarBuilder" />，後面接著 <paramref name="builder" /> 參數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> 支援從下列類別的轉換。  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 這個方法會接受如上面所列的物件`builder`參數。 如需詳細資訊，請參閱<xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A>運算子。  
  
> [!IMPORTANT]
>  當您合併<xref:System.Speech.Recognition.Choices>並<xref:System.Speech.Recognition.GrammarBuilder>包含物件<xref:System.Speech.Recognition.SemanticResultValue>或<xref:System.Speech.Recognition.SemanticResultKey>執行個體，請確定您有避免建立重複的語意項目具有相同索引鍵的名稱或多個語意的項目可以重複修改<xref:System.Speech.Recognition.SemanticValue.Value%2A>屬性<xref:System.Speech.Recognition.SemanticValue>物件。 語音辨識器在遇到這些情況下，可以擲回例外狀況。
  
 這個運算子的對等方法是 <xref:System.Speech.Recognition.GrammarBuilder.Add%28System.Speech.Recognition.Choices%2CSystem.Speech.Recognition.GrammarBuilder%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (System.Speech.Recognition.GrammarBuilder builder, System.Speech.Recognition.Choices choices);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(class System.Speech.Recognition.GrammarBuilder builder, class System.Speech.Recognition.Choices choices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.GrammarBuilder,System.Speech.Recognition.Choices)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::Speech::Recognition::GrammarBuilder ^ builder, System::Speech::Recognition::Choices ^ choices);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Speech.Recognition.GrammarBuilder * System.Speech.Recognition.Choices -&gt; System.Speech.Recognition.GrammarBuilder" Usage="builder + choices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="builder">第一個文法項目。</param>
        <param name="choices">第二個文法項目，這表示一組替代項目。</param>
        <summary>建立新的 <see cref="T:System.Speech.Recognition.GrammarBuilder" />，其中包含後面接著 <see cref="T:System.Speech.Recognition.GrammarBuilder" /> 的 <see cref="T:System.Speech.Recognition.Choices" />。</summary>
        <returns>傳回 <paramref name="builder" /> 參數序列的 <see cref="T:System.Speech.Recognition.GrammarBuilder" />，後面接著 <paramref name="choices" /> 參數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> 支援從下列類別的轉換：  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 這個方法會接受如上面所列的物件`builder`參數。 如需詳細資訊，請參閱<xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A>運算子。  
  
> [!IMPORTANT]
>  當您合併<xref:System.Speech.Recognition.Choices>並<xref:System.Speech.Recognition.GrammarBuilder>包含物件<xref:System.Speech.Recognition.SemanticResultValue>或<xref:System.Speech.Recognition.SemanticResultKey>執行個體，請確定您有避免建立重複的語意項目具有相同索引鍵的名稱或多個語意的項目可以重複修改<xref:System.Speech.Recognition.SemanticValue.Value%2A>屬性<xref:System.Speech.Recognition.SemanticValue>物件。 語音辨識器在遇到這些情況下，可以擲回例外狀況。
  
 這個運算子的對等方法是 <xref:System.Speech.Recognition.GrammarBuilder.Add%28System.Speech.Recognition.GrammarBuilder%2CSystem.Speech.Recognition.Choices%29?displayProperty=nameWithType>  
  
## Examples  
 下列範例會建立可辨識的兩個片語，語音辨識文法"背景*色彩*"和"設為背景*色彩*"，其中*色彩*選取從一組色彩。 各種類型用來建置最終的文法，例如[字串](https://go.microsoft.com/fwlink/?LinkId=159733)， <xref:System.Speech.Recognition.Choices>，和<xref:System.Speech.Recognition.GrammarBuilder>物件。  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] { "red", "green", "blue" });  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    (GrammarBuilder)"Make background" + colorChoice;  
  GrammarBuilder setPhrase =  
    "Set background to" + (GrammarBuilder)colorChoice;  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] { makePhrase, setPhrase });  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (System.Speech.Recognition.GrammarBuilder builder1, System.Speech.Recognition.GrammarBuilder builder2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(class System.Speech.Recognition.GrammarBuilder builder1, class System.Speech.Recognition.GrammarBuilder builder2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.GrammarBuilder,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (builder1 As GrammarBuilder, builder2 As GrammarBuilder) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::Speech::Recognition::GrammarBuilder ^ builder1, System::Speech::Recognition::GrammarBuilder ^ builder2);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Speech.Recognition.GrammarBuilder * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="builder1 + builder2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder1" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="builder2" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="builder1">第一個文法項目。</param>
        <param name="builder2">第二個文法項目。</param>
        <summary>建立新的<see cref="T:System.Speech.Recognition.GrammarBuilder" />，其中包含兩個 <see cref="T:System.Speech.Recognition.GrammarBuilder" />物件的序列。</summary>
        <returns>傳回 <paramref name="builder1" /> 參數序列的 <see cref="T:System.Speech.Recognition.GrammarBuilder" />，後面接著 <paramref name="builder2" /> 參數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> 支援從下列類別的轉換。  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 這個方法會接受如上面所列的物件`builder1`和`builder2`參數。 如需詳細資訊，請參閱<xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A>運算子。  
  
> [!IMPORTANT]
>  當您合併<xref:System.Speech.Recognition.GrammarBuilder>包含的物件<xref:System.Speech.Recognition.SemanticResultValue>或是<xref:System.Speech.Recognition.SemanticResultKey>執行個體，請確定您有避免建立重複的語意項目具有相同索引鍵的名稱或多個語意的項目可以重複修改<xref:System.Speech.Recognition.SemanticValue.Value%2A>屬性<xref:System.Speech.Recognition.SemanticValue>物件。 語音辨識器在遇到這些情況下，可以擲回例外狀況。
  
 這個運算子的對等方法是 <xref:System.Speech.Recognition.GrammarBuilder.Add%28System.Speech.Recognition.GrammarBuilder%2CSystem.Speech.Recognition.GrammarBuilder%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (System.Speech.Recognition.GrammarBuilder builder, string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(class System.Speech.Recognition.GrammarBuilder builder, string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.GrammarBuilder,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (builder As GrammarBuilder, phrase As String) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::Speech::Recognition::GrammarBuilder ^ builder, System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Speech.Recognition.GrammarBuilder * string -&gt; System.Speech.Recognition.GrammarBuilder" Usage="builder + phrase" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="builder">第一個文法項目。</param>
        <param name="phrase">第二個文法項目，這表示文字的序列。</param>
        <summary>建立新的 <see cref="T:System.Speech.Recognition.GrammarBuilder" />，其中包含後面接著片語的 <see cref="T:System.Speech.Recognition.GrammarBuilder" />。</summary>
        <returns>傳回 <paramref name="builder" /> 參數序列的 <see cref="T:System.Speech.Recognition.GrammarBuilder" />，後面接著 <paramref name="phrase" /> 參數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> 支援從下列類別的轉換。  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 這個方法會接受如上面所列的物件`builder`參數。 如需詳細資訊，請參閱<xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A>運算子。  
  
 這個運算子的對等方法是 <xref:System.Speech.Recognition.GrammarBuilder.Add%28System.Speech.Recognition.GrammarBuilder%2CSystem.String%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (string phrase, System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(string phrase, class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.String,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (phrase As String, builder As GrammarBuilder) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::String ^ phrase, System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="static member ( + ) : string * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="phrase + builder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="phrase">第一個文法項目，這表示文字的序列。</param>
        <param name="builder">第二個文法項目。</param>
        <summary>建立新的 <see cref="T:System.Speech.Recognition.GrammarBuilder" />，其中包含後面接著 <see cref="T:System.Speech.Recognition.GrammarBuilder" /> 的片語。</summary>
        <returns>傳回 <paramref name="phrase" /> 參數序列的 <see cref="T:System.Speech.Recognition.GrammarBuilder" />，後面接著 <paramref name="builder" /> 參數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> 支援從下列類別的轉換。  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 這個方法會接受如上面所列的物件`builder`參數。 如需詳細資訊，請參閱<xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A>運算子。  
  
 這個運算子的對等方法是 <xref:System.Speech.Recognition.GrammarBuilder.Add%28System.String%2CSystem.Speech.Recognition.GrammarBuilder%29?displayProperty=nameWithType>  
  
## Examples  
 下列範例會建立可辨識的兩個片語，語音辨識文法"背景*色彩*"和"設為背景*色彩*"，其中*色彩*選取從一組色彩。 各種類型用來建置最終的文法，例如[字串](https://go.microsoft.com/fwlink/?LinkId=159733)， <xref:System.Speech.Recognition.Choices>，和<xref:System.Speech.Recognition.GrammarBuilder>物件。  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] { "red", "green", "blue" });  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    (GrammarBuilder)"Make background" + colorChoice;  
  GrammarBuilder setPhrase =  
    "Set background to" + (GrammarBuilder)colorChoice;  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the Grammar object from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] { makePhrase, setPhrase });  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將其他型別轉換成 <see cref="T:System.Speech.Recognition.GrammarBuilder" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 隱含轉換會建立的新執行個體<xref:System.Speech.Recognition.GrammarBuilder>。 您可以將每個下列類別來轉換<xref:System.Speech.Recognition.GrammarBuilder>。  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 每個隱含轉型就相當於呼叫建構函式。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Speech.Recognition.GrammarBuilder (System.Speech.Recognition.Choices choices);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Implicit(class System.Speech.Recognition.Choices choices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Speech::Recognition::GrammarBuilder ^(System::Speech::Recognition::Choices ^ choices);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : System.Speech.Recognition.Choices -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.op_Implicit choices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="choices">要轉換的一組替代項目。</param>
        <summary>將 <see cref="T:System.Speech.Recognition.Choices" /> 物件轉換成 <see cref="T:System.Speech.Recognition.GrammarBuilder" /> 物件。</summary>
        <returns>轉換的 <see cref="T:System.Speech.Recognition.Choices" /> 物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 隱含轉換會建立的新執行個體<xref:System.Speech.Recognition.GrammarBuilder>。此轉換運算子就相當於呼叫<xref:System.Speech.Recognition.GrammarBuilder.%23ctor%2A>並指定`choices`如`alternateChoices`。  
  
 這個運算子的對等方法是 <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%28System.Speech.Recognition.Choices%29?displayProperty=nameWithType>  
  
## Examples  
 下列範例會建立語音辨識文法可辨識的回應"yes"或"no"的問題。 隱含轉換運算子會在建構<xref:System.Speech.Recognition.SemanticResultValue>物件從<xref:System.Speech.Recognition.Choices>物件，在建構<xref:System.Speech.Recognition.Choices>來自兩個物件<xref:System.Speech.Recognition.SemanticResultValue>物件，並在建構<xref:System.Speech.Recognition.Grammar>物件<xref:System.Speech.Recognition.SemanticResultKey>物件。  
  
```csharp  
Choices yesChoices = new Choices(new string[] {"yes", "yup", "yah"});  
SemanticResultValue yesValue =  
  new SemanticResultValue(yesChoices, true);  
  
Choices noChoices = new Choices(new string[] { "no", "nope", "nah" });  
SemanticResultValue noValue =  
  new SemanticResultValue(noChoices, false);  
  
SemanticResultKey yesnoKey =  
  new SemanticResultKey("yesno", new Choices(new GrammarBuilder[] { yesValue, noValue }));  
  
Grammar yesnoGrammar = new Grammar(yesnoKey);  
yesnoGrammar.Name = "yesno";  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Speech.Recognition.GrammarBuilder (System.Speech.Recognition.SemanticResultKey semanticKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Implicit(class System.Speech.Recognition.SemanticResultKey semanticKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.SemanticResultKey)~System.Speech.Recognition.GrammarBuilder" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (semanticKey As SemanticResultKey) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Speech::Recognition::GrammarBuilder ^(System::Speech::Recognition::SemanticResultKey ^ semanticKey);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : System.Speech.Recognition.SemanticResultKey -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.op_Implicit semanticKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticKey" Type="System.Speech.Recognition.SemanticResultKey" />
      </Parameters>
      <Docs>
        <param name="semanticKey">要轉換的語意索引鍵。</param>
        <summary>將 <see cref="T:System.Speech.Recognition.SemanticResultKey" /> 物件轉換成 <see cref="T:System.Speech.Recognition.GrammarBuilder" /> 物件。</summary>
        <returns>轉換的 <see cref="T:System.Speech.Recognition.SemanticResultKey" /> 物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 隱含轉換會建立的新執行個體<xref:System.Speech.Recognition.GrammarBuilder>。 此轉換運算子就相當於呼叫<xref:System.Speech.Recognition.GrammarBuilder.%23ctor%2A>並指定`semanticKey`如`key`。  
  
 這個運算子的對等方法是 <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%28System.Speech.Recognition.SemanticResultKey%29?displayProperty=nameWithType>  
  
## Examples  
 下列範例會建立語音辨識文法可辨識的回應"yes"或"no"的問題。 隱含轉換運算子會在建構<xref:System.Speech.Recognition.SemanticResultValue>物件從<xref:System.Speech.Recognition.Choices>物件，在建構<xref:System.Speech.Recognition.Choices>來自兩個物件<xref:System.Speech.Recognition.SemanticResultValue>物件，並在建構<xref:System.Speech.Recognition.Grammar>物件<xref:System.Speech.Recognition.SemanticResultKey>物件。  
  
```csharp  
Choices yesChoices = new Choices(new string[] {"yes", "yup", "yah"});  
SemanticResultValue yesValue =  
  new SemanticResultValue(yesChoices, true);  
  
Choices noChoices = new Choices(new string[] { "no", "nope", "nah" });  
SemanticResultValue noValue =  
  new SemanticResultValue(noChoices, false);  
  
SemanticResultKey yesnoKey =  
  new SemanticResultKey("yesno", new Choices(new GrammarBuilder[] { yesValue, noValue }));  
  
Grammar yesnoGrammar = new Grammar(yesnoKey);  
yesnoGrammar.Name = "yesno";  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Speech.Recognition.GrammarBuilder (System.Speech.Recognition.SemanticResultValue semanticValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Implicit(class System.Speech.Recognition.SemanticResultValue semanticValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.SemanticResultValue)~System.Speech.Recognition.GrammarBuilder" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (semanticValue As SemanticResultValue) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Speech::Recognition::GrammarBuilder ^(System::Speech::Recognition::SemanticResultValue ^ semanticValue);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : System.Speech.Recognition.SemanticResultValue -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.op_Implicit semanticValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticValue" Type="System.Speech.Recognition.SemanticResultValue" />
      </Parameters>
      <Docs>
        <param name="semanticValue">要進行轉換的 <see cref="T:System.Speech.Recognition.SemanticResultValue" /> 物件。</param>
        <summary>將 <see cref="T:System.Speech.Recognition.SemanticResultValue" /> 物件轉換成 <see cref="T:System.Speech.Recognition.GrammarBuilder" /> 物件。</summary>
        <returns>轉換的 <see cref="T:System.Speech.Recognition.SemanticResultValue" /> 物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 隱含轉換會建立的新執行個體<xref:System.Speech.Recognition.GrammarBuilder>。 此轉換運算子就相當於呼叫<xref:System.Speech.Recognition.GrammarBuilder.%23ctor%2A>並指定`semanticValue`如`value`。  
  
 這個運算子的對等方法是 <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%28System.Speech.Recognition.SemanticResultValue%29?displayProperty=nameWithType>  
  
## Examples  
 下列範例會建立語音辨識文法可辨識的回應"yes"或"no"的問題。 隱含轉換運算子會在建構<xref:System.Speech.Recognition.SemanticResultValue>物件從<xref:System.Speech.Recognition.Choices>物件，在建構<xref:System.Speech.Recognition.Choices>來自兩個物件<xref:System.Speech.Recognition.SemanticResultValue>物件，並在建構<xref:System.Speech.Recognition.Grammar>物件<xref:System.Speech.Recognition.SemanticResultKey>物件。  
  
```csharp  
Choices yesChoices = new Choices(new string[] {"yes", "yup", "yah"});  
SemanticResultValue yesValue =  
  new SemanticResultValue(yesChoices, true);  
  
Choices noChoices = new Choices(new string[] { "no", "nope", "nah" });  
SemanticResultValue noValue =  
  new SemanticResultValue(noChoices, false);  
  
SemanticResultKey yesnoKey =  
  new SemanticResultKey("yesno", new Choices(new GrammarBuilder[] { yesValue, noValue }));  
  
Grammar yesnoGrammar = new Grammar(yesnoKey);  
yesnoGrammar.Name = "yesno";  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Speech.Recognition.GrammarBuilder (string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Implicit(string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.String)~System.Speech.Recognition.GrammarBuilder" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (phrase As String) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Speech::Recognition::GrammarBuilder ^(System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : string -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.op_Implicit phrase" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="phrase">要轉換的字串。</param>
        <summary>將字串轉換成 <see cref="T:System.Speech.Recognition.GrammarBuilder" /> 物件。</summary>
        <returns>轉換的字串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 隱含轉換會建立的新執行個體<xref:System.Speech.Recognition.GrammarBuilder>。 此轉換運算子就相當於呼叫<xref:System.Speech.Recognition.GrammarBuilder.%23ctor%2A>並指定相同`phrase`。  
  
 這個運算子的對等方法是 <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%28System.String%29?displayProperty=nameWithType>  
  
## Examples  
 下列範例會使用<xref:System.Speech.Recognition.GrammarBuilder>和<xref:System.Speech.Recognition.Choices>物件以建構可辨識的兩個片語，其中的文法"背景*colorChoice*」 或 「 背景設定為*colorChoice*".  
  
 建立一份可接受的值之後*colorChoice*使用<xref:System.Speech.Recognition.Choices>物件，此範例會初始化兩個<xref:System.Speech.Recognition.GrammarBuilder>物件`makePhrase`和`setPhrase`，使用從字串的隱含轉換物件。  
  
 此範例最後會建立<xref:System.Speech.Recognition.Grammar>物件從<xref:System.Speech.Recognition.Choices>物件轉換成<xref:System.Speech.Recognition.GrammarBuilder>物件。  
  
```csharp  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the Grammar object from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  Grammar grammar = new Grammar((GrammarBuilder)bothChoices);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </Member>
  </Members>
</Type>