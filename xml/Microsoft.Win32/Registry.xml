<Type Name="Registry" FullName="Microsoft.Win32.Registry">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b0374cee2ad12d253ad5ccca07e17fd0740a95ad" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39868081" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Registry" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Registry extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Win32.Registry" />
  <TypeSignature Language="VB.NET" Value="Public Class Registry" />
  <TypeSignature Language="C++ CLI" Value="public ref class Registry abstract sealed" />
  <TypeSignature Language="F#" Value="type Registry = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供用於表示 Windows 登錄中根目錄機碼的 <see cref="T:Microsoft.Win32.RegistryKey" /> 物件，以及用於存取機碼/值組的 <see langword="static" /> 方法。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個類別會提供標準的根目錄機碼在執行 Windows 的電腦上登錄中找到的集合。 登錄是儲存體設備，如需有關應用程式、 使用者和預設系統設定資訊。 比方說，應用程式可以使用登錄來儲存後關閉應用程式時，要保留所需的資訊，並重新載入應用程式時，存取相同的資訊。 比方說，您可以儲存色彩喜好設定、 螢幕位置或視窗的大小。 您可以將資訊儲存在登錄中的不同位置，來控制每一位使用者的這項資料。  
  
 基底或根<xref:Microsoft.Win32.RegistryKey>所公開的執行個體`Registry`類別描述子機碼和登錄中的值的基本儲存體機制。 所有索引鍵是唯讀的因為登錄取決於它們的存在。 所公開的索引鍵`Registry`是：  
  
 <xref:Microsoft.Win32.Registry.CurrentUser>  
 儲存使用者喜好設定相關資訊。  
  
 <xref:Microsoft.Win32.Registry.LocalMachine>  
 會儲存在本機電腦的組態資訊。  
  
 <xref:Microsoft.Win32.Registry.ClassesRoot>  
 儲存類型 （和類別） 的相關資訊和其屬性。  
  
 <xref:Microsoft.Win32.Registry.Users>  
 儲存預設使用者設定的相關資訊。  
  
 <xref:Microsoft.Win32.Registry.PerformanceData>  
 儲存軟體元件的效能資訊。  
  
 <xref:Microsoft.Win32.Registry.CurrentConfig>  
 儲存非使用者特定的硬體資訊。  
  
 <xref:Microsoft.Win32.Registry.DynData>  
 儲存動態資料。  
  
 一旦您已識別您想要儲存/擷取資訊從登錄所在的根目錄機碼，您可以使用<xref:Microsoft.Win32.RegistryKey>類別來新增或移除子機碼，並操作指定的索引鍵的值。  
  
 硬體裝置可以將資訊放在登錄中自動使用隨插即用介面。 安裝裝置驅動程式軟體可以將資訊放在登錄中，藉由將寫入標準的 Api。  
  
## <a name="static-methods-for-getting-and-setting-values"></a>取得和設定值的靜態方法  
 在.NET Framework 2.0 版中，<xref:Microsoft.Win32.Registry>類別也包含`static`<xref:Microsoft.Win32.Registry.GetValue%2A>和<xref:Microsoft.Win32.Registry.SetValue%2A>方法來設定和擷取登錄機碼的值。 這些方法都會開啟和關閉的登錄機碼每個使用，因此不會執行的時間，以及類似的方法，在<xref:Microsoft.Win32.RegistryKey>類別，當您存取大量的值。  
  
 <xref:Microsoft.Win32.RegistryKey>類別也會提供方法，可讓您設定 Windows 登錄機碼，然後才能擷取它，測試值的資料類型，以及刪除金鑰的存取控制安全性。  
  
   
  
## Examples  
 本節包含兩個程式碼範例。 第一個範例示範根目錄機碼，以及第二個範例示範`static`<xref:Microsoft.Win32.Registry.GetValue%2A>和<xref:Microsoft.Win32.Registry.SetValue%2A>方法。  
  
 範例 1  
  
 下列程式碼範例示範如何擷取的子機碼 HKEY_USERS 機碼，並列印其名稱到螢幕。 使用<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>方法用來建立感興趣的特定子機碼的執行個體。 然後，您可以使用中的其他作業`RegistryKey`操作該索引鍵。  
  
 [!code-cpp[Classic Registry.Users Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.Users Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.Users Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.Users Example/VB/source.vb#1)]  
  
 範例 2  
  
 下列程式碼範例會將數個資料類型的值儲存在範例機碼，建立金鑰，因為它在這麼做，然後擷取並顯示的值。 此範例示範如何儲存和擷取的預設值 （無名） 的名稱/值組，以及使用`defaultValue`名稱/值組不存在的時。  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.Win32.RegistryHive" />
    <altmember cref="T:Microsoft.Win32.RegistryKey" />
  </Docs>
  <Members>
    <Member MemberName="ClassesRoot">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey ClassesRoot;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey ClassesRoot" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.ClassesRoot" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ClassesRoot As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ ClassesRoot;" />
      <MemberSignature Language="F#" Value=" staticval mutable ClassesRoot : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.ClassesRoot" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>定義文件的型別 (或類別) 以及與型別相關聯的屬性。 這個欄位會讀取 Windows 登錄主要機碼 HKEY_CLASSES_ROOT。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳統的應用程式和 OLE 應用程式使用此機碼下儲存的資料。 此機碼也會提供回溯相容性 Windows 3.1 註冊資料庫儲存 DDE 和 OLE 支援資訊。 檔案檢視器和使用者介面擴充功能的 OLE 類別識別碼則會在此機碼，儲存和處理伺服器都登錄在此機碼。  
  
   
  
## Examples  
 下列範例示範如何擷取此機碼中的子機碼，並列印其名稱到螢幕。 使用<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>方法用來建立感興趣的特定子機碼的執行個體。 然後，您可以使用中的其他作業<xref:Microsoft.Win32.RegistryKey>操作該索引鍵。  
  
 [!code-cpp[Classic Registry.ClassesRoot Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.ClassesRoot Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.ClassesRoot Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentConfig">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey CurrentConfig;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey CurrentConfig" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.CurrentConfig" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CurrentConfig As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ CurrentConfig;" />
      <MemberSignature Language="F#" Value=" staticval mutable CurrentConfig : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.CurrentConfig" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>包含非針對特定使用者的硬體相關組態資訊。 這個欄位會讀取 Windows 登錄主要機碼 HKEY_CURRENT_CONFIG。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員會對應到內的子機碼<xref:Microsoft.Win32.Registry.LocalMachine>。  
  
 使用這個成員的範例是儲存不同的伺服器名稱，其資料，根據系統是否連接到網路的應用程式。  
  
   
  
## Examples  
 下列範例示範如何擷取此機碼中的子機碼，並列印其名稱到螢幕。 使用<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>方法用來建立感興趣的特定子機碼的執行個體。 然後，您可以使用中的其他作業<xref:Microsoft.Win32.RegistryKey>操作該索引鍵。  
  
 [!code-cpp[Classic Registry.CurrentConfig Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.CurrentConfig Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.CurrentConfig Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUser">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey CurrentUser;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey CurrentUser" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.CurrentUser" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CurrentUser As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ CurrentUser;" />
      <MemberSignature Language="F#" Value=" staticval mutable CurrentUser : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.CurrentUser" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>包含有關目前使用者喜好設定的資訊。 這個欄位會讀取 Windows 登錄主要機碼 HKEY_CURRENT_USER。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此機碼中儲存的資訊包括環境變數和程式群組、 色彩、 印表機、 網路連線和應用程式喜好設定的相關資料的設定。 此金鑰可讓您更輕鬆地建立目前使用者的設定。 在此機碼中，軟體廠商會儲存在其應用程式要使用的目前使用者特定喜好設定。 比方說，Microsoft，就會建立其應用程式以搭配每個應用程式，建立自己的子機碼，Microsoft 機碼下 HKEY_CURRENT_USER\Software\Microsoft 機碼。  
  
   
  
## Examples  
 下列範例示範如何擷取此機碼中的子機碼，並列印其名稱到螢幕。 使用<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>方法用來建立感興趣的特定子機碼的執行個體。 然後，您可以使用中的其他作業<xref:Microsoft.Win32.RegistryKey>操作該索引鍵。  
  
 [!code-cpp[Classic Registry.CurrentUser Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.CurrentUser Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.CurrentUser Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynData">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey DynData;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey DynData" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.DynData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DynData As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ DynData;" />
      <MemberSignature Language="F#" Value=" staticval mutable DynData : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.DynData" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PerformanceData instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("The DynData registry key only works on Win9x, which is no longer supported by the CLR.  On NT-based operating systems, use the PerformanceData registry key instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>包含動態登錄資料。 這個欄位會讀取 Windows 登錄主要機碼 HKEY_DYN_DATA。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows 98/Windows Me 登錄支援靜態資料 （也就儲存在登錄中的磁碟上） 和動態的資料 （但經常變更，例如效能統計資料）。 這個動態的資料區域是從遠端同時在本機執行的 Win32 應用程式可讓虛擬裝置驅動程式 (Vxd)，以提供即時資料的機制。 它也可讓系統監視器 」 來提供 Windows 98/Windows 我在遠端系統上的效能統計資料。  
  
 Vxd 不限於效能資料。 它們可以提供他們想要傳遞從 Ring 0 至 Ring 3 有效率而不獨佔 CPU 的任何資料。 登錄會儲存傳回值 （或許多值） 的函式的指標，以支援動態資料。 當查詢值的登錄呼叫動態索引鍵相關聯，呼叫函式可傳回的所需的值。  
  
> [!NOTE]
>  有了動態金鑰是導入在 Microsoft Windows 95 中處理動態登錄資料。 它們只是在 Windows 98/Windows me 中支援  
  
   
  
## Examples  
 下列範例示範如何擷取此機碼中的子機碼，並列印其名稱到螢幕。 使用<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>方法用來建立感興趣的特定子機碼的執行個體。 然後，您可以使用中的其他作業<xref:Microsoft.Win32.RegistryKey>操作該索引鍵。 請注意，此範例可以傳回任何結果，因為有可能不是動態的資料可用，或者您可能不在執行 Windows 98 / 分享。 使用此金鑰，可能會在其他系統上造成錯誤。  
  
 [!code-cpp[Classic Registry.DynData Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.DynData Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.DynData Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.DynData Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.DynData Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.DynData Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">作業系統不支援動態資料；也就是說，它不是 Windows 98、Windows 98 Second Edition 或 Windows Millennium Edition (Windows Me)。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public static object GetValue (string keyName, string valueName, object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetValue(string keyName, string valueName, object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.GetValue(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetValue (keyName As String, valueName As String, defaultValue As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="static member GetValue : string * string * obj -&gt; obj" Usage="Microsoft.Win32.Registry.GetValue (keyName, valueName, defaultValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" />
        <Parameter Name="valueName" Type="System.String" />
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="keyName">機碼的完整登錄路徑，以有效登錄根目錄開頭 (例如 "HKEY_CURRENT_USER")。</param>
        <param name="valueName">名稱/值組的名稱。</param>
        <param name="defaultValue">
          <c>valueName</c> 不存在時所傳回的值。</param>
        <summary>在指定的登錄機碼中，擷取與所指定名稱關聯的值。 如果在指定的機碼中找不到該名稱，則會傳回提供的預設值；如果指定的機碼不存在，則傳回 <see langword="null" />。</summary>
        <returns>如果 <paramref name="keyName" /> 指定的子機碼不存在，則為 <see langword="null" />，否則為與 <paramref name="valueName" /> 關聯的值；如果找不到 <paramref name="defaultValue" />，則為 <paramref name="valueName" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 字串`valueName`不區分大小寫。  
  
> [!NOTE]
>  登錄機碼可以包含一個不是任何名稱相關聯的值。 當這個未命名的值顯示在登錄編輯程式中時，字串 「 （預設） 」 會出現而不是名稱。 若要擷取這個未命名的值，指定`null`或空字串 ("") 的`valuName`。  
  
 有效的根名稱是 HKEY_CURRENT_USER 中，HKEY_LOCAL_MACHINE、 HKEY_CLASSES_ROOT、 HKEY_USERS、 HKEY_PERFORMANCE_DATA、 機碼 HKEY_CURRENT_CONFIG 和機碼 HKEY_DYN_DATA。 比方說，在 Visual Basic 中的字串"HKEY_CURRENT_USER\MyTestKey 「 存取子機碼"MyTestKey 」 在 HKEY_CURRENT_USER 根目錄中的索引鍵/值組。  
  
 當<xref:Microsoft.Win32.RegistryKey.GetValue%2A>方法會擷取可展開的字串值 (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>)，它會展開環境字串使用本機的環境中的資料。 如果已儲存為字串的值，包含可展開環境變數參考 (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>)，而不是可擴充的字串 (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>)，<xref:Microsoft.Win32.RegistryKey.GetValue%2A>不會展開。 已擷取透過呼叫之後，您可以展開此類字串<xref:System.Environment.ExpandEnvironmentVariables%2A?displayProperty=nameWithType>方法。  
  
> [!NOTE]
>  從 HKEY_PERFORMANCE_DATA 擷取資料的建議的方式是使用<xref:System.Diagnostics.PerformanceCounter>類別而非<xref:Microsoft.Win32.RegistryKey.GetValue%2A?displayProperty=nameWithType>方法。  
  
 <xref:Microsoft.Win32.Registry.GetValue%2A>並<xref:Microsoft.Win32.Registry.SetValue%2A>方法都會開啟和關閉的登錄機碼每次使用，因此不會執行，以及方法<xref:Microsoft.Win32.RegistryKey>類別，如果您在存取大量的值。  
  
 <xref:Microsoft.Win32.RegistryKey> 也提供方法，可讓您將存取控制清單 (ACL) 新增至登錄機碼，然後才能擷取它，測試值的資料類型，並刪除索引鍵。  
  
   
  
## Examples  
 下列程式碼範例會將數個資料類型的值儲存在範例機碼，建立金鑰，因為它在這麼做，然後擷取並顯示的值。 此範例示範如何儲存和擷取的預設值 （無名） 的名稱/值組，以及使用`defaultValue`名稱/值組不存在的時。  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">使用者沒有讀取登錄機碼所需的使用權限。</exception>
        <exception cref="T:System.IO.IOException">包含指定值的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已標記為刪除。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keyName" /> 不是以有效的登錄根目錄開頭。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">若要從登錄讀取。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">讀取REG_EXPAND_SZ類型的註冊表項。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LocalMachine">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey LocalMachine;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey LocalMachine" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.LocalMachine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LocalMachine As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ LocalMachine;" />
      <MemberSignature Language="F#" Value=" staticval mutable LocalMachine : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.LocalMachine" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>包含本機電腦的組態資料。 這個欄位會讀取 Windows 登錄主要機碼 HKEY_LOCAL_MACHINE。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `LocalMachine` 包含五個索引鍵：  
  
 硬體  
 描述在 [電腦] 的實體硬體裝置驅動程式會使用該硬體，並對應和連結以使用者模式程式碼的核心模式驅動程式的相關的資料的方式。 此機碼中的所有資料會重新都建立每次啟動系統時。 在描述子機碼描述實際的電腦硬體。 DeviceMap 子機碼包含格式特定類別的驅動程式特有的其他資料。 ResourceMap 子機碼告訴您哪些裝置驅動程式宣告的硬體資源。 Windows NT 診斷程式 (Winmsdp.exe) 可以報告其內容以容易閱讀的格式。  
  
 SAM  
 目錄服務資料庫的使用者和群組帳戶，以及 Windows 2000 Server 中的定義域的安全性資訊 （SAM 是安全性帳戶管理員，稱為 「 目錄服務 」 資料庫）。  
  
 安全性  
 包含的本機安全性原則，例如特定的使用者權限。 Windows 2000 安全性子系統只會使用此金鑰。  
  
 軟體  
 每部電腦軟體的資料庫。 此金鑰包含在本機電腦，以及其他組態資料的各種項目上安裝軟體的相關資料。  
  
 系統  
 控制系統啟動、 裝置驅動程式的載入、 Windows 2000 服務和作業系統的行為。  
  
 依照慣例，如果下的類似資料存在<xref:Microsoft.Win32.Registry.CurrentUser>歲<xref:Microsoft.Win32.Registry.LocalMachine>中的資料<xref:Microsoft.Win32.Registry.CurrentUser>會優先使用。 不過，在此機碼的值可以也延伸 （而非取代） Registry.LocalMachine 中的資料。 此外，某些項目 （例如裝置驅動程式載入的項目） 是如果它們發生 Registry.LocalMachine 之外，沒有任何意義。  
  
   
  
## Examples  
 下列範例示範如何擷取此機碼中的子機碼，並列印其名稱到螢幕。 使用<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>方法用來建立感興趣的特定子機碼的執行個體。 然後，您可以使用中的其他作業<xref:Microsoft.Win32.RegistryKey>操作該索引鍵。  
  
 [!code-cpp[Classic Registry.LocalMachine Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.LocalMachine Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.LocalMachine Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformanceData">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey PerformanceData;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey PerformanceData" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.PerformanceData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PerformanceData As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ PerformanceData;" />
      <MemberSignature Language="F#" Value=" staticval mutable PerformanceData : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.PerformanceData" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>包含軟體元件的效能資訊。 這個欄位會讀取 Windows 登錄主要機碼 HKEY_PERFORMANCE_DATA。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每個軟體元件會建立它的物件、 計數器時它會安裝，而且當它執行時，寫入計數器資料的索引鍵。 您可以存取此資料，因為您會存取任何其他登錄的資料，使用<xref:Microsoft.Win32.RegistryKey>函式。  
  
 雖然您可以使用登錄來收集效能資料，資料不會儲存在登錄資料庫中。 相反地，使用此金鑰存取登錄會使系統收集適當的系統物件管理員中的資料。  
  
 若要從本機系統取得效能資料，請使用<xref:Microsoft.Win32.RegistryKey.GetValue%2A>方法，具有 Registry.PerformanceData 索引鍵。 第一次呼叫會開啟索引鍵 （您不需要明確地開啟索引鍵第一次）。 不過，請務必使用<xref:Microsoft.Win32.RegistryKey.Close%2A>方法以關閉的機碼的控制代碼，當您完成取得效能資料。 使用者無法安裝或移除軟體元件，其效能資料時使用。  
  
 若要從遠端系統取得效能資料，您必須使用<xref:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey%2A>方法，在遠端系統及 Registry.PerformanceData 金鑰的電腦名稱。 此呼叫會擷取索引鍵代表的遠端系統的效能資料。 若要擷取的資料，請呼叫<xref:Microsoft.Win32.RegistryKey.GetValue%2A>使用這個金鑰，而不是 Registry.PerformanceData 索引鍵。  
  
> [!NOTE]
>  Windows Server 2003，使用者必須至少屬於 Performance Monitor Users 群組才能存取此基底的索引鍵的子機碼。  
  
   
  
## Examples  
 下列範例示範如何擷取此機碼中的子機碼，並列印其名稱到螢幕。 使用<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>方法用來建立感興趣的特定子機碼的執行個體。 然後，您可以使用中的其他作業<xref:Microsoft.Win32.RegistryKey>操作該索引鍵。 請注意，此範例可以通常會傳回任何結果，因為可能會不有任何效能資料。  
  
 [!code-cpp[Classic Registry.PerformanceData Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.PerformanceData Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.PerformanceData Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>設定登錄機碼中名稱/值組的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例會將數個資料類型的值儲存在範例機碼，建立金鑰，因為它在這麼做，然後擷取並顯示的值。 此範例示範如何儲存和擷取的預設值 （無名） 的名稱/值組，以及使用`defaultValue`名稱/值組不存在的時。  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public static void SetValue (string keyName, string valueName, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetValue(string keyName, string valueName, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetValue (keyName As String, valueName As String, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member SetValue : string * string * obj -&gt; unit" Usage="Microsoft.Win32.Registry.SetValue (keyName, valueName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" />
        <Parameter Name="valueName" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="keyName">機碼的完整登錄路徑，以有效登錄根目錄開頭 (例如 "HKEY_CURRENT_USER")。</param>
        <param name="valueName">名稱/值組的名稱。</param>
        <param name="value">要儲存的值。</param>
        <summary>在指定的登錄機碼上設定指定的名稱/值組。 如果指定的機碼不存在，則會建立它。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，則`valueName`參數已不再限制為最多 255 個字元; 不過，`keyName`參數會繼續有 255 個字元限制。  
  
 因為許多值可以儲存在登錄中的每個索引鍵中，您必須使用`valueName`參數來指定您想要設定的特定值。  
  
> [!NOTE]
>  登錄機碼可以包含一個不是任何名稱相關聯的值。 當這個未命名的值顯示在登錄編輯程式中時，字串 「 （預設） 」 會出現而不是名稱。 若要設定這個未命名的值，指定`null`或空字串 ("") 的`valueName`。  
  
 如果`valueName`不存在的機碼中建立和相關聯的值設定為`value`。  
  
 如果`keyName`指定子機碼不存在，在指定的根目錄中建立子機碼。 比方說，在 Visual Basic 中的字串"HKEY_CURRENT_USER\MyTestKey 」 建立在 HKEY_CURRENT_USER 根目錄中的子機碼"MyTestKey 」。 字串"HKEY_CURRENT_USER\MyTestKey\Key2\Key3 」 會建立 「 MyTestKey"、"MyTestKey\Key2 」 和 「 MyTestKey\Key2\Key3"的巢狀子機碼。  
  
 有效的根名稱包含 HKEY_CURRENT_USER，HKEY_LOCAL_MACHINE，HKEY_CLASSES_ROOT、 HKEY_USERS、 HKEY_PERFORMANCE_DATA、 機碼 HKEY_CURRENT_CONFIG 和機碼 HKEY_DYN_DATA。  
  
> [!NOTE]
>  <xref:Microsoft.Win32.Registry.SetValue%2A>方法，可開啟登錄機碼、 設定值，並在關閉機碼每次呼叫時。 如果您需要修改大量數值，<xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=nameWithType>方法可能會提供更佳的效能。 <xref:Microsoft.Win32.RegistryKey>類別也會提供方法，可讓您將存取控制清單 (ACL) 新增至登錄機碼，然後才能擷取它，測試值的資料類型，並刪除索引鍵。  
  
 這個多載<xref:Microsoft.Win32.Registry.SetValue%2A>儲存為字串的 64 位元整數 (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>)。 若要儲存為 64 位元數字<xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType>值，會使用<xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29>方法多載。  
  
 這個多載<xref:Microsoft.Win32.Registry.SetValue%2A>會儲存所有的字串值視為<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>物件，即使它們包含可展開環境變數參考。 若要儲存字串值為可展開的字串 (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>)，使用<xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29>方法多載。  
  
 這個多載就相當於呼叫<xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29>方法多載<xref:Microsoft.Win32.RegistryValueKind.Unknown?displayProperty=nameWithType>。  
  
> [!NOTE]
>  在 Windows 98 和 Windows Millennium Edition (Windows Me 檔案)，登錄不是 Unicode，而且並非所有的 Unicode 字元則是適用於所有字碼頁。 可用最佳的配對會取代目前的字碼頁而言是無效的 Unicode 字元。 不會有例外狀況擲回。  
  
   
  
## Examples  
 下列程式碼範例會將數個資料類型的值儲存在範例機碼，建立金鑰，因為它在這麼做，然後擷取並顯示的值。 此範例示範如何儲存和擷取的預設值 （無名） 的名稱/值組，以及使用`defaultValue`名稱/值組不存在的時。  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keyName" /> 不是以有效的登錄根目錄開頭。  
  
-或- 
 <paramref name="keyName" /> 超過允許的最大長度 (255 個字元)。</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> 為唯讀，因此無法寫入 (例如，它是根層次節點)。</exception>
        <exception cref="T:System.Security.SecurityException">使用者沒有建立或修改登錄機碼所需的使用權限。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">若要修改指定的登錄機碼，如果存在，或不存在時建立登錄機碼。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />， <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public static void SetValue (string keyName, string valueName, object value, Microsoft.Win32.RegistryValueKind valueKind);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetValue(string keyName, string valueName, object value, valuetype Microsoft.Win32.RegistryValueKind valueKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object,Microsoft.Win32.RegistryValueKind)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetValue (keyName As String, valueName As String, value As Object, valueKind As RegistryValueKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ value, Microsoft::Win32::RegistryValueKind valueKind);" />
      <MemberSignature Language="F#" Value="static member SetValue : string * string * obj * Microsoft.Win32.RegistryValueKind -&gt; unit" Usage="Microsoft.Win32.Registry.SetValue (keyName, valueName, value, valueKind)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" />
        <Parameter Name="valueName" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="valueKind" Type="Microsoft.Win32.RegistryValueKind" />
      </Parameters>
      <Docs>
        <param name="keyName">機碼的完整登錄路徑，以有效登錄根目錄開頭 (例如 "HKEY_CURRENT_USER")。</param>
        <param name="valueName">名稱/值組的名稱。</param>
        <param name="value">要儲存的值。</param>
        <param name="valueKind">儲存資料時要使用的登錄資料類型。</param>
        <summary>使用指定的登錄資料型別，在指定的登錄機碼上設定名稱/值組。 如果指定的機碼不存在，則會建立它。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，則`valueName`參數已不再限制為最多 255 個字元; 不過，`keyName`參數可讓您繼續有 255 個字元限制。  
  
 因為許多值可以儲存在登錄中的每個索引鍵中，您必須使用`valueName`參數來指定您想要設定的特定值。  
  
> [!NOTE]
>  登錄機碼可以包含一個不是任何名稱相關聯的值。 當這個未命名的值顯示在登錄編輯程式中時，字串 「 （預設） 」 會出現而不是名稱。 若要設定這個未命名的值，指定`null`或空字串 ("") 的`valueName`。  
  
 如果`valueName`不存在的機碼中建立和相關聯的值設定為`value`。  
  
 如果`keyName`指定子機碼不存在，在指定的根目錄中建立子機碼。 比方說，在 Visual Basic 中的字串"HKEY_CURRENT_USER\MyTestKey 」 建立在 HKEY_CURRENT_USER 根目錄中的子機碼"MyTestKey 」。 字串"HKEY_CURRENT_USER\MyTestKey\Key2\Key3 」 會建立 「 MyTestKey"、"MyTestKey\Key2 」 和 「 MyTestKey\Key2\Key3"的巢狀子機碼。  
  
 有效的根名稱包含 HKEY_CURRENT_USER，HKEY_LOCAL_MACHINE，HKEY_CLASSES_ROOT、 HKEY_USERS、 HKEY_PERFORMANCE_DATA、 機碼 HKEY_CURRENT_CONFIG 和機碼 HKEY_DYN_DATA。  
  
> [!NOTE]
>  <xref:Microsoft.Win32.Registry.SetValue%2A>方法，可開啟登錄機碼、 設定值，並在關閉機碼每次呼叫時。 如果您需要修改大量數值，<xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=nameWithType>方法可能會提供更佳的效能。 <xref:Microsoft.Win32.RegistryKey>類別也會提供方法，可讓您將存取控制清單 (ACL) 新增至登錄機碼，然後才能擷取它，測試值的資料類型，並刪除索引鍵。  
  
 如果指定的型別`value`不符合指定`valueKind`，而且不能是資料轉換，<xref:System.ArgumentException>就會擲回。 例如，您可以在其中儲存<xref:System.Int64?displayProperty=nameWithType>作為<xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType>，但其值小於最大值時，只有<xref:System.Int32?displayProperty=nameWithType>。 您無法儲存單一字串值做為<xref:Microsoft.Win32.RegistryValueKind.MultiString?displayProperty=nameWithType>。  
  
> [!NOTE]
>  如果經過 boxing 處理的值會傳遞給<xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType>或<xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType>，表示轉換已完成使用文化特性而異。  
  
> [!NOTE]
>  在 Windows 98 和 Windows Millennium Edition (Windows Me 檔案)，登錄不是 Unicode，而且並非所有的 Unicode 字元則是適用於所有字碼頁。 可用最佳的配對會取代目前的字碼頁而言是無效的 Unicode 字元。 不會有例外狀況擲回。  
  
   
  
## Examples  
 下列程式碼範例會將數個資料類型的值儲存在範例機碼，建立金鑰，因為它在這麼做，然後擷取並顯示的值。 此範例示範如何儲存和擷取的預設值 （無名） 的名稱/值組，以及使用`defaultValue`名稱/值組不存在的時。  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keyName" /> 不是以有效的登錄根目錄開頭。  
  
-或- 
 <paramref name="keyName" /> 超過允許的最大長度 (255 個字元)。  
  
-或- 
<paramref name="value" /> 的型別與 <paramref name="valueKind" /> 所指定的登錄資料型別不符，因此，無法正確轉換資料。</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> 為唯讀，因此無法寫入 (例如，它是根層次節點，或未以寫入權限來開啟該機碼)。</exception>
        <exception cref="T:System.Security.SecurityException">使用者沒有建立或修改登錄機碼所需的使用權限。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">若要修改指定的登錄機碼，如果存在，或不存在時建立登錄機碼。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />， <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Users">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey Users;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey Users" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.Users" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Users As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ Users;" />
      <MemberSignature Language="F#" Value=" staticval mutable Users : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.Users" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>包含有關預設使用者組態的資訊。 這個欄位會讀取 Windows 登錄主要機碼 HKEY_USERS。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此金鑰包含電腦的每個使用者的分支。 如果使用者未變更喜好設定，在本機電腦上的新使用者及預設的目前使用者被提供的預設組態。 因為 Windows 98 / 我也支援 Registry.Users，應用程式可以存取相同的方式，就在 Windows 2000 的使用者特定資訊。 每個使用者的資訊會儲存在不同的檔案，可以儲存在本機或網路伺服器上。 Windows 98 / 我可以將此檔案複製到使用者的目前的系統，以便設定從一部電腦之間移動與使用者。  
  
   
  
## Examples  
 下列範例示範如何擷取此機碼中的子機碼，並列印其名稱到螢幕。 使用<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>方法用來建立感興趣的特定子機碼的執行個體。 然後，您可以使用中的其他作業<xref:Microsoft.Win32.RegistryKey>操作該索引鍵。  
  
 [!code-cpp[Classic Registry.Users Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.Users Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.Users Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.Users Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>