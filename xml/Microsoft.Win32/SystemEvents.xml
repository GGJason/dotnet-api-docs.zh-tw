<Type Name="SystemEvents" FullName="Microsoft.Win32.SystemEvents">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="cb2c4cfb922bea0a86778098daf936793ce02011" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39972110" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class SystemEvents" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit SystemEvents extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Win32.SystemEvents" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SystemEvents" />
  <TypeSignature Language="C++ CLI" Value="public ref class SystemEvents sealed" />
  <TypeSignature Language="F#" Value="type SystemEvents = class" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>提供存取系統事件告知的功能。 這個類別無法被繼承。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:Microsoft.Win32.SystemEvents>類別提供特定類型的系統事件回應的能力。  
  
 系統事件引發時，使用系統事件的執行緒，可監視稱為任何附加至事件的委派。 因此，您應該要從您事件處理常式安全執行緒的任何呼叫。 如果您需要呼叫不會公開這個類別的成員身分的系統事件，您可以使用<xref:Microsoft.Win32.SystemEvents.InvokeOnEventsThread%2A>方法。  
  
> [!CAUTION]
>  不會引發的系統事件處理常式，因為它可能會讓其他應用程式無法正常運作的執行緒上會執行耗時的處理。  
  
> [!NOTE]
>  某些系統事件可能不會引發在[!INCLUDE[windowsver](~/includes/windowsver-md.md)]。 請務必確認您的應用程式運作如預期般在[!INCLUDE[windowsver](~/includes/windowsver-md.md)]。  
  
   
  
## Examples  
 本節包含兩個範例。 第一個範例示範如何使用一般的應用程式中的系統事件，第二個範例示範如何使用 Windows 服務中的系統事件。  
  
 **範例 1**  
  
 下列程式碼範例會註冊在某些系統事件的感興趣，然後等候這些事件發生的任何。 如果使用者變更顯示器解析度，就會發生所顯示的輸出。  
  
 [!code-cpp[SystemEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#1)]
 [!code-csharp[SystemEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#1)]
 [!code-vb[SystemEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#1)]  
  
 **範例 2**  
  
 下列程式碼範例示範非常簡單的 Windows 服務，可處理<xref:Microsoft.Win32.SystemEvents.TimeChanged>和<xref:Microsoft.Win32.SystemEvents.UserPreferenceChanged>事件。 此範例也包含名為的服務`SimpleService`，表單名為`HiddenForm`，和安裝程式。 此表單會提供所需的系統事件的訊息迴圈。  
  
> [!NOTE]
>  服務沒有訊息迴圈，除非它們可與桌面互動。 如果訊息迴圈未提供所隱藏的表單，如同此範例中，服務必須是本機系統帳戶執行，並手動介入的情況下，才可啟用與桌面互動。 也就是系統管理員必須手動檢查**允許服務與桌面互動** 核取方塊**登入**服務的 內容 對話方塊索引標籤。 在此情況下，會自動提供的訊息迴圈。 只有在本機系統帳戶下執行服務時，才使用此選項。 無法以程式設計方式啟用與桌面互動。  
  
 此範例中的服務會啟動執行執行個體的執行緒`HiddenForm`。 連接事件，並且在表單中的處理。 事件必須在 load 事件中的表單，以確定表單是完全載入第一次; 連接否則將不會引發事件。  
  
> [!NOTE]
>  這個範例將提供所有必要的程式碼，包括通常是由 Visual Studio 設計工具產生的表單初始化程式碼。 如果您正在開發您的服務，在 Visual Studio 中，您可以省略第二個部分類別，並使用**屬性**視窗設定為零，要的框線樣式，隱藏表單的寬度與高度<xref:System.Windows.Forms.FormBorderStyle.None?displayProperty=nameWithType>，和要的視窗狀態<xref:System.Windows.Forms.FormWindowState.Minimized?displayProperty=nameWithType>.  
  
 若要執行範例：  
  
1.  從命令列程式碼編譯。 您使用的原始程式檔的名稱並不重要。  
  
2.  安裝服務，從命令列使用[Installutil.exe （安裝程式工具）](~/docs/framework/tools/installutil-exe-installer-tool.md)公用程式。 例如，`InstallUtil example.exe`原始程式檔名稱是否`example.cs`或`example.vb`。 您必須是系統管理員才能安裝此服務。  
  
3.  您可以使用 [服務] 主控台來啟動服務。  
  
4.  變更系統時間，或變更使用者的喜好設定，例如滑鼠屬性。  
  
5.  檢視中的訊息**應用程式**事件檢視器類別。  
  
6.  您可以使用 [服務] 主控台來停止服務。  
  
7.  從命令列解除安裝服務，使用`/u`選項。 例如，`InstallUtil /u example.exe`。  
  
 [!code-csharp[ManagedWindowsService#1](~/samples/snippets/csharp/VS_Snippets_CLR/ManagedWindowsService/cs/source.cs#1)]
 [!code-vb[ManagedWindowsService#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ManagedWindowsService/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.NamedPermissionSet">取得的完整存取系統資源。 要求的值： <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />。 相關聯的狀態：</permission>
    <altmember cref="T:Microsoft.Win32.PowerModeChangedEventHandler" />
    <altmember cref="T:Microsoft.Win32.SessionEndedEventHandler" />
    <altmember cref="T:Microsoft.Win32.SessionEndingEventHandler" />
    <altmember cref="T:Microsoft.Win32.SessionSwitchEventHandler" />
    <altmember cref="T:Microsoft.Win32.TimerElapsedEventHandler" />
    <altmember cref="T:Microsoft.Win32.UserPreferenceChangedEventHandler" />
    <altmember cref="T:Microsoft.Win32.UserPreferenceChangingEventHandler" />
  </Docs>
  <Members>
    <Member MemberName="CreateTimer">
      <MemberSignature Language="C#" Value="public static IntPtr CreateTimer (int interval);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CreateTimer(int32 interval) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.SystemEvents.CreateTimer(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateTimer (interval As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr CreateTimer(int interval);" />
      <MemberSignature Language="F#" Value="static member CreateTimer : int -&gt; nativeint" Usage="Microsoft.Win32.SystemEvents.CreateTimer interval" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interval" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="interval">指定計時器告知的間隔時間 (以毫秒為單位)。</param>
        <summary>建立與系統事件視窗關聯的新視窗計時器。</summary>
        <returns>新計時器的 ID。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">間隔是小於或等於零。</exception>
        <exception cref="T:System.InvalidOperationException">目前內容不支援系統事件告知。 例如，伺服器處理序可能就不支援全域系統事件告知。</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">建立系統事件視窗執行緒的動作失敗，或建立計時器的動作失敗。</exception>
      </Docs>
    </Member>
    <Member MemberName="DisplaySettingsChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler DisplaySettingsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DisplaySettingsChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event DisplaySettingsChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ DisplaySettingsChanged;" />
      <MemberSignature Language="F#" Value="member this.DisplaySettingsChanged : EventHandler " Usage="member this.DisplaySettingsChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當使用者變更顯示設定時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  因為這是靜態事件，您必須在您的應用程式已處置，或會造成記憶體流失時中斷連結事件處理常式。  
  
   
  
## Examples  
 下列程式碼範例示範如何監視<xref:Microsoft.Win32.SystemEvents.DisplaySettingsChanged>事件。 此程式碼範例是針對提供之較大範例的一部分<xref:Microsoft.Win32.SystemEvents>類別。  
  
 [!code-cpp[SystemEvents#2](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#2)]
 [!code-csharp[SystemEvents#2](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#2)]
 [!code-vb[SystemEvents#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">目前內容不支援系統事件告知。 例如，伺服器處理序可能就不支援全域系統事件告知。</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">建立系統事件視窗執行緒的嘗試未成功。</exception>
        <altmember cref="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanging" />
      </Docs>
    </Member>
    <Member MemberName="DisplaySettingsChanging">
      <MemberSignature Language="C#" Value="public static event EventHandler DisplaySettingsChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DisplaySettingsChanging" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanging" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event DisplaySettingsChanging As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ DisplaySettingsChanging;" />
      <MemberSignature Language="F#" Value="member this.DisplaySettingsChanging : EventHandler " Usage="member this.DisplaySettingsChanging : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當顯示設定變更時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  因為這是靜態事件，您必須在您的應用程式已處置，或會造成記憶體流失時中斷連結事件處理常式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">目前內容不支援系統事件告知。 例如，伺服器處理序可能就不支援全域系統事件告知。</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">建立系統事件視窗執行緒的嘗試未成功。</exception>
        <altmember cref="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanged" />
      </Docs>
    </Member>
    <Member MemberName="EventsThreadShutdown">
      <MemberSignature Language="C#" Value="public static event EventHandler EventsThreadShutdown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EventsThreadShutdown" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.EventsThreadShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event EventsThreadShutdown As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ EventsThreadShutdown;" />
      <MemberSignature Language="F#" Value="member this.EventsThreadShutdown : EventHandler " Usage="member this.EventsThreadShutdown : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在聆聽系統事件的執行緒終止前發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 因為接聽系統事件的執行緒即將終止時，會引發這個事件。 系統事件的委派，會使用接聽系統事件的執行緒叫用的。  
  
> [!CAUTION]
>  因為這是靜態事件，您必須在您的應用程式已處置，或會造成記憶體流失時中斷連結事件處理常式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">目前內容不支援系統事件告知。 例如，伺服器處理序可能就不支援全域系統事件告知。</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">建立系統事件視窗執行緒的嘗試未成功。</exception>
      </Docs>
    </Member>
    <Member MemberName="InstalledFontsChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler InstalledFontsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler InstalledFontsChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.InstalledFontsChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event InstalledFontsChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ InstalledFontsChanged;" />
      <MemberSignature Language="F#" Value="member this.InstalledFontsChanged : EventHandler " Usage="member this.InstalledFontsChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當使用者將字型加入系統或從系統移除字型時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  因為這是靜態事件，您必須在您的應用程式已處置，或會造成記憶體流失時中斷連結事件處理常式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">目前內容不支援系統事件告知。 例如，伺服器處理序可能就不支援全域系統事件告知。</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">建立系統事件視窗執行緒的嘗試未成功。</exception>
      </Docs>
    </Member>
    <Member MemberName="InvokeOnEventsThread">
      <MemberSignature Language="C#" Value="public static void InvokeOnEventsThread (Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void InvokeOnEventsThread(class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.SystemEvents.InvokeOnEventsThread(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub InvokeOnEventsThread (method As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void InvokeOnEventsThread(Delegate ^ method);" />
      <MemberSignature Language="F#" Value="static member InvokeOnEventsThread : Delegate -&gt; unit" Usage="Microsoft.Win32.SystemEvents.InvokeOnEventsThread method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="method">要用接聽系統事件的執行緒叫用的委派。</param>
        <summary>利用接聽系統事件的執行緒叫用指定的委派。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用這個方法時，您需要處理系統事件不會公開否則<xref:Microsoft.Win32.SystemEvents>類別。  
  
 當您呼叫這個方法時，您的應用程式用來處理系統事件的執行緒就會叫用指定的委派。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">目前內容不支援系統事件告知。 例如，伺服器處理序可能就不支援全域系統事件告知。</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">建立系統事件視窗執行緒的嘗試未成功。</exception>
      </Docs>
    </Member>
    <Member MemberName="KillTimer">
      <MemberSignature Language="C#" Value="public static void KillTimer (IntPtr timerId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void KillTimer(native int timerId) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.SystemEvents.KillTimer(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub KillTimer (timerId As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void KillTimer(IntPtr timerId);" />
      <MemberSignature Language="F#" Value="static member KillTimer : nativeint -&gt; unit" Usage="Microsoft.Win32.SystemEvents.KillTimer timerId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timerId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="timerId">要結束之計時器的 ID。</param>
        <summary>終止指定 ID 代表的計時器。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">目前內容不支援系統事件告知。 例如，伺服器處理序可能就不支援全域系統事件告知。</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">建立系統事件視窗執行緒的動作失敗，或結束計時器的動作失敗。</exception>
      </Docs>
    </Member>
    <Member MemberName="LowMemory">
      <MemberSignature Language="C#" Value="public static event EventHandler LowMemory;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LowMemory" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.LowMemory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event LowMemory As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ LowMemory;" />
      <MemberSignature Language="F#" Value="member this.LowMemory : EventHandler " Usage="member this.LowMemory : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("This event has been deprecated. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當系統可用的 RAM 不足時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件會包裝 WM_COMPACTING 訊息。 此訊息會傳送給所有最上層的視窗中，當系統偵測到超過 12.5%的系統時間，在 30 至 60 秒的間隔內花在壓縮的記憶體。 這表示系統記憶體過低。  
  
> [!NOTE]
>  如果在執行訊息幫浦，只會引發這個事件。 在 Windows 服務中，除非使用隱藏的表單，或手動啟動訊息幫浦，否則將不會引發此事件。 如需示範如何在 Windows 服務中使用隱藏的表單處理系統事件的程式碼範例，請參閱<xref:Microsoft.Win32.SystemEvents>類別。  
  
> [!CAUTION]
>  因為這是靜態事件，您必須在您的應用程式已處置，或會造成記憶體流失時中斷連結事件處理常式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">目前內容不支援系統事件告知。 例如，伺服器處理序可能就不支援全域系統事件告知。</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">建立系統事件視窗執行緒的嘗試未成功。</exception>
        <block subset="none" type="usage">
          <para>此訊息僅為 16 位元 Windows 為基礎的應用程式相容性提供。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="PaletteChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler PaletteChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PaletteChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.PaletteChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event PaletteChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ PaletteChanged;" />
      <MemberSignature Language="F#" Value="member this.PaletteChanged : EventHandler " Usage="member this.PaletteChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當使用者切換至使用不同調色盤的應用程式時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  如果在執行訊息幫浦，只會引發這個事件。 在 Windows 服務中，除非使用隱藏的表單，或手動啟動訊息幫浦，否則將不會引發此事件。 如需示範如何在 Windows 服務中使用隱藏的表單處理系統事件的程式碼範例，請參閱<xref:Microsoft.Win32.SystemEvents>類別。  
  
> [!CAUTION]
>  因為這是靜態事件，您必須在您的應用程式已處置，或會造成記憶體流失時中斷連結事件處理常式。  
  
   
  
## Examples  
 下列程式碼範例示範如何監視<xref:Microsoft.Win32.SystemEvents.PaletteChanged>事件。 此程式碼範例是針對提供之較大範例的一部分<xref:Microsoft.Win32.SystemEvents>類別。  
  
 [!code-cpp[SystemEvents#2](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#2)]
 [!code-csharp[SystemEvents#2](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#2)]
 [!code-vb[SystemEvents#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">目前內容不支援系統事件告知。 例如，伺服器處理序可能就不支援全域系統事件告知。</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">建立系統事件視窗執行緒的嘗試未成功。</exception>
      </Docs>
    </Member>
    <Member MemberName="PowerModeChanged">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.PowerModeChangedEventHandler PowerModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.PowerModeChangedEventHandler PowerModeChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.PowerModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event PowerModeChanged As PowerModeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::PowerModeChangedEventHandler ^ PowerModeChanged;" />
      <MemberSignature Language="F#" Value="member this.PowerModeChanged : Microsoft.Win32.PowerModeChangedEventHandler " Usage="member this.PowerModeChanged : Microsoft.Win32.PowerModeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.PowerModeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當使用者暫停或繼續系統時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  如果在執行訊息幫浦，只會引發這個事件。 在 Windows 服務中，除非使用隱藏的表單，或手動啟動訊息幫浦，否則將不會引發此事件。 如需示範如何在 Windows 服務中使用隱藏的表單處理系統事件的程式碼範例，請參閱<xref:Microsoft.Win32.SystemEvents>類別。  
  
> [!CAUTION]
>  因為這是靜態事件，您必須在您的應用程式已處置，或會造成記憶體流失時中斷連結事件處理常式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">目前內容不支援系統事件告知。 例如，伺服器處理序可能就不支援全域系統事件告知。</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">建立系統事件視窗執行緒的嘗試未成功。</exception>
        <altmember cref="T:Microsoft.Win32.PowerModeChangedEventArgs" />
        <altmember cref="T:Microsoft.Win32.PowerModeChangedEventHandler" />
        <altmember cref="T:Microsoft.Win32.PowerModes" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnded">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.SessionEndedEventHandler SessionEnded;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.SessionEndedEventHandler SessionEnded" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.SessionEnded" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event SessionEnded As SessionEndedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::SessionEndedEventHandler ^ SessionEnded;" />
      <MemberSignature Language="F#" Value="member this.SessionEnded : Microsoft.Win32.SessionEndedEventHandler " Usage="member this.SessionEnded : Microsoft.Win32.SessionEndedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SessionEndedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當使用者正在登出或正在關閉系統時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  如果在執行訊息幫浦，只會引發這個事件。 在 Windows 服務中，除非使用隱藏的表單，或手動啟動訊息幫浦，否則將不會引發此事件。 如需示範如何在 Windows 服務中使用隱藏的表單處理系統事件的程式碼範例，請參閱<xref:Microsoft.Win32.SystemEvents>類別。  
  
> [!CAUTION]
>  因為這是靜態事件，您必須在您的應用程式已處置，或會造成記憶體流失時中斷連結事件處理常式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">目前內容不支援系統事件告知。 例如，伺服器處理序可能就不支援全域系統事件告知。</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">建立系統事件視窗執行緒的嘗試未成功。</exception>
        <altmember cref="T:Microsoft.Win32.SessionEndedEventArgs" />
        <altmember cref="T:Microsoft.Win32.SessionEndedEventHandler" />
        <altmember cref="T:Microsoft.Win32.SessionEndReasons" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnding">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.SessionEndingEventHandler SessionEnding;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.SessionEndingEventHandler SessionEnding" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.SessionEnding" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event SessionEnding As SessionEndingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::SessionEndingEventHandler ^ SessionEnding;" />
      <MemberSignature Language="F#" Value="member this.SessionEnding : Microsoft.Win32.SessionEndingEventHandler " Usage="member this.SessionEnding : Microsoft.Win32.SessionEndingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SessionEndingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當使用者正在嘗試登出或關閉系統時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是可取消的事件。 設定<xref:Microsoft.Win32.SessionEndingEventArgs.Cancel%2A>屬性設`true`會要求工作階段會繼續執行。 它提供不會結束工作階段無法保證。  
  
 如果您使用<xref:Microsoft.Win32.SystemEvents.SessionEnding>Windows 表單來偵測系統登出或重新開機時，沒有任何決定性的方式，來決定是否<xref:System.Windows.Forms.Form.Closing>事件就會引發此事件之前。  
  
 如果您想要執行某些特殊的工作，再<xref:System.Windows.Forms.Form.Closing>會引發，您必須確保<xref:Microsoft.Win32.SystemEvents.SessionEnding>之前，就會引發<xref:System.Windows.Forms.Form.Closing>。 若要這樣做，您需要設陷`WM_QUERYENDSESSION`藉由覆寫格式`WndProc`函式。  此範例示範如何執行這項操作。  
  
```vb  
Private Shared WM_QUERYENDSESSION As Integer = &H11  
 Private Shared systemShutdown As Boolean = False  
 Protected Overrides Sub WndProc(ByRef m As System.Windows.Forms.Message)  
     If m.Msg = WM_QUERYENDSESSION Then  
         MessageBox.Show("queryendsession: this is a logoff, shutdown, or reboot")  
         systemShutdown = True  
     End If  
     ' If this is WM_QUERYENDSESSION, the closing event should be raised in the base WndProc.  
     MyBase.WndProc(m)  
 End Sub 'WndProc   
 Private Sub Form1_Closing(ByVal sender As System.Object, ByVal e As System.ComponentModel.CancelEventArgs) Handles MyBase.Closing  
     If (systemShutdown) Then  
     ' Reset the variable because the user might cancel the shutdown.  
         systemShutdown = False  
         If (System.Windows.Forms.DialogResult.Yes = _  
                 MessageBox.Show("My application", "Do you want to save your work before logging off?", MessageBoxButtons.YesNo)) Then  
                 e.Cancel = True  
         Else  
                 e.Cancel = False  
         End If  
     End If  
 End Sub  
  
```  
  
```csharp  
private static int WM_QUERYENDSESSION = 0x11;  
private static bool systemShutdown = false;  
protected override void WndProc(ref System.Windows.Forms.Message m)  
{  
    if (m.Msg==WM_QUERYENDSESSION)  
    {  
        MessageBox.Show("queryendsession: this is a logoff, shutdown, or reboot");  
        systemShutdown = true;  
    }  
  
    // If this is WM_QUERYENDSESSION, the closing event should be  
    // raised in the base WndProc.  
    base.WndProc(ref m);  
  
} //WndProc   
  
private void Form1_Closing(  
    System.Object sender,   
    System.ComponentModel.CancelEventArgs e)  
{  
    if (systemShutdown)  
        // Reset the variable because the user might cancel the   
        // shutdown.  
    {  
        systemShutdown = false;  
        if (DialogResult.Yes==MessageBox.Show("My application",   
            "Do you want to save your work before logging off?",   
            MessageBoxButtons.YesNo))  
        {  
            e.Cancel = true;  
        }  
        else  
        {  
            e.Cancel = false;  
        }  
    }  
}  
```  
  
> [!IMPORTANT]
>  主控台應用程式不會引發<xref:Microsoft.Win32.SystemEvents.SessionEnding>事件。  
  
> [!NOTE]
>  如果在執行訊息幫浦，只會引發這個事件。 在 Windows 服務中，除非使用隱藏的表單，或手動啟動訊息幫浦，否則將不會引發此事件。 如需示範如何在 Windows 服務中使用隱藏的表單處理系統事件的程式碼範例，請參閱<xref:Microsoft.Win32.SystemEvents>類別。  
  
> [!CAUTION]
>  因為這是靜態事件，您必須在您的應用程式已處置，或會造成記憶體流失時中斷連結事件處理常式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">目前內容不支援系統事件告知。 例如，伺服器處理序可能就不支援全域系統事件告知。</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">建立系統事件視窗執行緒的嘗試未成功。</exception>
        <altmember cref="T:Microsoft.Win32.SessionEndingEventArgs" />
        <altmember cref="T:Microsoft.Win32.SessionEndingEventHandler" />
        <altmember cref="T:Microsoft.Win32.SessionEndReasons" />
      </Docs>
    </Member>
    <Member MemberName="SessionSwitch">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.SessionSwitchEventHandler SessionSwitch;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.SessionSwitchEventHandler SessionSwitch" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.SessionSwitch" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event SessionSwitch As SessionSwitchEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::SessionSwitchEventHandler ^ SessionSwitch;" />
      <MemberSignature Language="F#" Value="member this.SessionSwitch : Microsoft.Win32.SessionSwitchEventHandler " Usage="member this.SessionSwitch : Microsoft.Win32.SessionSwitchEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SessionSwitchEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當目前登入的使用者變更時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  如果在執行訊息幫浦，只會引發這個事件。 在 Windows 服務中，除非使用隱藏的表單，或手動啟動訊息幫浦，否則將不會引發此事件。 如需示範如何在 Windows 服務中使用隱藏的表單處理系統事件的程式碼範例，請參閱<xref:Microsoft.Win32.SystemEvents>類別。  
  
> [!CAUTION]
>  因為這是靜態事件，您必須在您的應用程式已處置，或會造成記憶體流失時中斷連結事件處理常式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">目前內容不支援系統事件告知。 例如，伺服器處理序可能就不支援全域系統事件告知。</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">建立系統事件視窗執行緒的嘗試未成功。</exception>
        <altmember cref="T:Microsoft.Win32.SessionSwitchEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="TimeChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler TimeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TimeChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.TimeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event TimeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ TimeChanged;" />
      <MemberSignature Language="F#" Value="member this.TimeChanged : EventHandler " Usage="member this.TimeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當使用者變更系統時鐘上的時間時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  如果在執行訊息幫浦，只會引發這個事件。 在 Windows 服務中，除非使用隱藏的表單，或手動啟動訊息幫浦，否則將不會引發此事件。 如需示範如何在 Windows 服務中使用隱藏的表單處理系統事件的程式碼範例，請參閱<xref:Microsoft.Win32.SystemEvents>類別。  
  
> [!CAUTION]
>  因為這是靜態事件，您必須在您的應用程式已處置，或會造成記憶體流失時中斷連結事件處理常式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">目前內容不支援系統事件告知。 例如，伺服器處理序可能就不支援全域系統事件告知。</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">建立系統事件視窗執行緒的嘗試未成功。</exception>
        <altmember cref="P:System.DateTime.Now" />
      </Docs>
    </Member>
    <Member MemberName="TimerElapsed">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.TimerElapsedEventHandler TimerElapsed;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.TimerElapsedEventHandler TimerElapsed" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.TimerElapsed" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event TimerElapsed As TimerElapsedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::TimerElapsedEventHandler ^ TimerElapsed;" />
      <MemberSignature Language="F#" Value="member this.TimerElapsed : Microsoft.Win32.TimerElapsedEventHandler " Usage="member this.TimerElapsed : Microsoft.Win32.TimerElapsedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.TimerElapsedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當視窗計時器間隔已經過期時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  如果在執行訊息幫浦，只會引發這個事件。 在 Windows 服務中，除非使用隱藏的表單，或手動啟動訊息幫浦，否則將不會引發此事件。 如需示範如何在 Windows 服務中使用隱藏的表單處理系統事件的程式碼範例，請參閱<xref:Microsoft.Win32.SystemEvents>類別。  
  
> [!CAUTION]
>  因為這是靜態事件，您必須在您的應用程式已處置，或會造成記憶體流失時中斷連結事件處理常式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">目前內容不支援系統事件告知。 例如，伺服器處理序可能就不支援全域系統事件告知。</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">建立系統事件視窗執行緒的嘗試未成功。</exception>
        <altmember cref="T:Microsoft.Win32.TimerElapsedEventArgs" />
        <altmember cref="T:Microsoft.Win32.TimerElapsedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="UserPreferenceChanged">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.UserPreferenceChangedEventHandler UserPreferenceChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.UserPreferenceChangedEventHandler UserPreferenceChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.UserPreferenceChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UserPreferenceChanged As UserPreferenceChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::UserPreferenceChangedEventHandler ^ UserPreferenceChanged;" />
      <MemberSignature Language="F#" Value="member this.UserPreferenceChanged : Microsoft.Win32.UserPreferenceChangedEventHandler " Usage="member this.UserPreferenceChanged : Microsoft.Win32.UserPreferenceChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.UserPreferenceChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當使用者喜好設定已變更時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  如果在執行訊息幫浦，只會引發這個事件。 在 Windows 服務中，除非使用隱藏的表單，或手動啟動訊息幫浦，否則將不會引發此事件。 如需示範如何在 Windows 服務中使用隱藏的表單處理系統事件的程式碼範例，請參閱<xref:Microsoft.Win32.SystemEvents>類別。  
  
> [!CAUTION]
>  因為這是靜態事件，您必須在您的應用程式已處置，或會造成記憶體流失時中斷連結事件處理常式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">目前內容不支援系統事件告知。 例如，伺服器處理序可能就不支援全域系統事件告知。</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">建立系統事件視窗執行緒的嘗試未成功。</exception>
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangedEventArgs" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangedEventHandler" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceCategory" />
      </Docs>
    </Member>
    <Member MemberName="UserPreferenceChanging">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.UserPreferenceChangingEventHandler UserPreferenceChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.UserPreferenceChangingEventHandler UserPreferenceChanging" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.UserPreferenceChanging" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UserPreferenceChanging As UserPreferenceChangingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::UserPreferenceChangingEventHandler ^ UserPreferenceChanging;" />
      <MemberSignature Language="F#" Value="member this.UserPreferenceChanging : Microsoft.Win32.UserPreferenceChangingEventHandler " Usage="member this.UserPreferenceChanging : Microsoft.Win32.UserPreferenceChangingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.UserPreferenceChangingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當使用者喜好設定正在變更時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  如果在執行訊息幫浦，只會引發這個事件。 在 Windows 服務中，除非使用隱藏的表單，或手動啟動訊息幫浦，否則將不會引發此事件。 如需示範如何在 Windows 服務中使用隱藏的表單處理系統事件的程式碼範例，請參閱<xref:Microsoft.Win32.SystemEvents>類別。  
  
> [!CAUTION]
>  因為這是靜態事件，您必須在您的應用程式已處置，或會造成記憶體流失時中斷連結事件處理常式。  
  
   
  
## Examples  
 下列程式碼範例示範如何監視<xref:Microsoft.Win32.SystemEvents.UserPreferenceChanging>事件。 此程式碼範例是針對提供之較大範例的一部分<xref:Microsoft.Win32.SystemEvents>類別。  
  
 [!code-cpp[SystemEvents#2](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#2)]
 [!code-csharp[SystemEvents#2](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#2)]
 [!code-vb[SystemEvents#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">目前內容不支援系統事件告知。 例如，伺服器處理序可能就不支援全域系統事件告知。</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">建立系統事件視窗執行緒的嘗試未成功。</exception>
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangingEventArgs" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangingEventHandler" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceCategory" />
      </Docs>
    </Member>
  </Members>
</Type>