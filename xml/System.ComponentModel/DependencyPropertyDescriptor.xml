<Type Name="DependencyPropertyDescriptor" FullName="System.ComponentModel.DependencyPropertyDescriptor">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6c7332a580b01563008a7ab49cf4bde76602493e" /><Meta Name="ms.sourcegitcommit" Value="42a3c35677e9d87eeb503607ae50c9d39827d414" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="12/17/2018" /><Meta Name="ms.locfileid" Value="53493660" /></Metadata><TypeSignature Language="C#" Value="public sealed class DependencyPropertyDescriptor : System.ComponentModel.PropertyDescriptor" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DependencyPropertyDescriptor extends System.ComponentModel.PropertyDescriptor" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.DependencyPropertyDescriptor" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DependencyPropertyDescriptor&#xA;Inherits PropertyDescriptor" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyPropertyDescriptor sealed : System::ComponentModel::PropertyDescriptor" />
  <TypeSignature Language="F#" Value="type DependencyPropertyDescriptor = class&#xA;    inherit PropertyDescriptor" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.PropertyDescriptor</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>提供 <see cref="T:System.ComponentModel.PropertyDescriptor" /> 的擴充功能，負責相依性屬性的其他屬性特性。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個類別主要是由設計工具的應用程式。 這些應用程式可能需要透過屬性視窗或其他工具，用來編輯屬性值的相依性屬性特性的報表。  
  
 若要檢查特定的屬性，以判斷是否有<xref:System.ComponentModel.DependencyPropertyDescriptor>可用來做為<xref:System.ComponentModel.PropertyDescriptor>，呼叫<xref:System.ComponentModel.DependencyPropertyDescriptor.FromProperty%28System.ComponentModel.PropertyDescriptor%29?displayProperty=nameWithType>，或<xref:System.ComponentModel.DependencyPropertyDescriptor.FromName%2A?displayProperty=nameWithType>。 如果任一方法都會傳回`null`，則屬性不是相依性屬性。 如果此方法會傳回有效<xref:System.ComponentModel.DependencyPropertyDescriptor>，則屬性為相依性屬性。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddValueChanged">
      <MemberSignature Language="C#" Value="public override void AddValueChanged (object component, EventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void AddValueChanged(object component, class System.EventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.DependencyPropertyDescriptor.AddValueChanged(System.Object,System.EventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub AddValueChanged (component As Object, handler As EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void AddValueChanged(System::Object ^ component, EventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="override this.AddValueChanged : obj * EventHandler -&gt; unit" Usage="dependencyPropertyDescriptor.AddValueChanged (component, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="handler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="component">要為其加入處理常式的元件。</param>
        <param name="handler">要加入以做為接聽程式 (Listener) 的委派。</param>
        <summary>使其他物件能在這個屬性變更時受到告知。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.AttributeCollection Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.AttributeCollection Attributes" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.DependencyPropertyDescriptor.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Attributes As AttributeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::AttributeCollection ^ Attributes { System::ComponentModel::AttributeCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.ComponentModel.AttributeCollection" Usage="System.ComponentModel.DependencyPropertyDescriptor.Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AttributeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個成員的屬性集合。</summary>
        <value>屬性 (Attribute) 的 <see cref="T:System.ComponentModel.AttributeCollection" /> 集合。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanResetValue">
      <MemberSignature Language="C#" Value="public override bool CanResetValue (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool CanResetValue(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.DependencyPropertyDescriptor.CanResetValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CanResetValue (component As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool CanResetValue(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="override this.CanResetValue : obj -&gt; bool" Usage="dependencyPropertyDescriptor.CanResetValue component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">要測試重設能力的元件。</param>
        <summary>傳回值，表示重設物件是否變更其值。</summary>
        <returns>如果重設元件會變更其值，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法需仰賴基礎<xref:System.ComponentModel.PropertyDescriptor>。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.PropertyDescriptor.CanResetValue(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Category">
      <MemberSignature Language="C#" Value="public override string Category { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Category" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.DependencyPropertyDescriptor.Category" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Category As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Category { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Category : string" Usage="System.ComponentModel.DependencyPropertyDescriptor.Category" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得成員所屬的分類名稱，如 <see cref="T:System.ComponentModel.CategoryAttribute" /> 中所指定的。</summary>
        <value>成員所屬的分類名稱。 如果沒有 <see cref="T:System.ComponentModel.CategoryAttribute" />，則分類名稱會設定為預設分類 <see langword="Misc" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會依賴基礎<xref:System.ComponentModel.PropertyDescriptor>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ComponentType">
      <MemberSignature Language="C#" Value="public override Type ComponentType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ComponentType" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.DependencyPropertyDescriptor.ComponentType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ComponentType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ComponentType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ComponentType : Type" Usage="System.ComponentModel.DependencyPropertyDescriptor.ComponentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個屬性所繫結的元件型別。</summary>
        <value><see cref="T:System.Type" />，表示這個屬性所繫結的元件型別。 當叫用 <see cref="M:System.ComponentModel.DependencyPropertyDescriptor.GetValue(System.Object)" /> 或 <see cref="M:System.ComponentModel.DependencyPropertyDescriptor.SetValue(System.Object,System.Object)" /> 時，指定的物件可能是這個型別的執行個體。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會依賴基礎<xref:System.ComponentModel.PropertyDescriptor>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Converter">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.TypeConverter Converter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.TypeConverter Converter" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.DependencyPropertyDescriptor.Converter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Converter As TypeConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::TypeConverter ^ Converter { System::ComponentModel::TypeConverter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Converter : System.ComponentModel.TypeConverter" Usage="System.ComponentModel.DependencyPropertyDescriptor.Converter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeConverter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個屬性的型別轉換子。</summary>
        <value><see cref="T:System.ComponentModel.TypeConverter" />，用來轉換這個屬性的 <see cref="T:System.Type" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性可能`null`萬一其中的屬性化<xref:System.ComponentModel.TypeConverter>不是公用的類別。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.TypeConverterAttribute" />
      </Docs>
    </Member>
    <Member MemberName="DependencyProperty">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty DependencyProperty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyProperty DependencyProperty" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.DependencyPropertyDescriptor.DependencyProperty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependencyProperty As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyProperty ^ DependencyProperty { System::Windows::DependencyProperty ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DependencyProperty : System.Windows.DependencyProperty" Usage="System.ComponentModel.DependencyPropertyDescriptor.DependencyProperty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>傳回相依性屬性的識別項。</summary>
        <value>相依性屬性的識別項。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性可能`null`如果<xref:System.ComponentModel.DependencyPropertyDescriptor>建立執行個體不是相依性屬性的屬性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Description">
      <MemberSignature Language="C#" Value="public override string Description { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Description" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.DependencyPropertyDescriptor.Description" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Description As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Description { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Description : string" Usage="System.ComponentModel.DependencyPropertyDescriptor.Description" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得成員的描述，如 <see cref="T:System.ComponentModel.DescriptionAttribute" /> 中所指定的。</summary>
        <value>成員的描述。 如果沒有 <see cref="T:System.ComponentModel.DescriptionAttribute" />，則屬性值會設為預設，即空字串 ("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會依賴基礎<xref:System.ComponentModel.PropertyDescriptor>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DesignerCoerceValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.CoerceValueCallback DesignerCoerceValueCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.CoerceValueCallback DesignerCoerceValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.DependencyPropertyDescriptor.DesignerCoerceValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property DesignerCoerceValueCallback As CoerceValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::CoerceValueCallback ^ DesignerCoerceValueCallback { System::Windows::CoerceValueCallback ^ get(); void set(System::Windows::CoerceValueCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DesignerCoerceValueCallback : System.Windows.CoerceValueCallback with get, set" Usage="System.ComponentModel.DependencyPropertyDescriptor.DesignerCoerceValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.CoerceValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定回呼，設計工具使用這個回呼修改相依性屬性的有效值，然後再將相依性屬性值儲存在相依性屬性引擎。</summary>
        <value>回呼，設計工具用來修改相依性屬性的有效值，然後再將相依性屬性值儲存在相依性屬性引擎。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DesignTimeOnly">
      <MemberSignature Language="C#" Value="public override bool DesignTimeOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DesignTimeOnly" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.DependencyPropertyDescriptor.DesignTimeOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DesignTimeOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool DesignTimeOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.DesignTimeOnly : bool" Usage="System.ComponentModel.DependencyPropertyDescriptor.DesignTimeOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，表示這個成員是否只在設計階段設定，如 <see cref="T:System.ComponentModel.DesignOnlyAttribute" /> 中所指定的。</summary>
        <value>如果這個成員只應該在設計階段設定，則為 <see langword="true" />；如果成員可在 Run Time 期間設定，則為 <see langword="false" />。 如果沒有 <see cref="T:System.ComponentModel.DesignOnlyAttribute" />，則傳回值為預設值，即 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會依賴基礎<xref:System.ComponentModel.PropertyDescriptor>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisplayName">
      <MemberSignature Language="C#" Value="public override string DisplayName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DisplayName" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.DependencyPropertyDescriptor.DisplayName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DisplayName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ DisplayName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DisplayName : string" Usage="System.ComponentModel.DependencyPropertyDescriptor.DisplayName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得可在視窗 (例如 [屬性] 視窗) 中顯示的名稱。</summary>
        <value>要顯示的屬性名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會依賴基礎<xref:System.ComponentModel.PropertyDescriptor>。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.DependencyProperty.Name" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.DependencyPropertyDescriptor.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="dependencyPropertyDescriptor.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要與目前執行個體比較的 <see cref="T:System.ComponentModel.DependencyPropertyDescriptor" />。</param>
        <summary>比較兩個 <see cref="T:System.ComponentModel.DependencyPropertyDescriptor" /> 執行個體是否相等。</summary>
        <returns>如果值相等，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="FromName">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回所提供屬性名稱的 <see cref="T:System.ComponentModel.DependencyPropertyDescriptor" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FromName">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.DependencyPropertyDescriptor FromName (string name, Type ownerType, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.DependencyPropertyDescriptor FromName(string name, class System.Type ownerType, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.DependencyPropertyDescriptor.FromName(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromName (name As String, ownerType As Type, targetType As Type) As DependencyPropertyDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::DependencyPropertyDescriptor ^ FromName(System::String ^ name, Type ^ ownerType, Type ^ targetType);" />
      <MemberSignature Language="F#" Value="static member FromName : string * Type * Type -&gt; System.ComponentModel.DependencyPropertyDescriptor" Usage="System.ComponentModel.DependencyPropertyDescriptor.FromName (name, ownerType, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.DependencyPropertyDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">相依性屬性或附加屬性的註冊名稱。</param>
        <param name="ownerType">擁有屬性定義之物件的 <see cref="T:System.Type" />。</param>
        <param name="targetType">您想要設定其屬性之物件的 <see cref="T:System.Type" />。</param>
        <summary>傳回所提供屬性名稱的 <see cref="T:System.ComponentModel.DependencyPropertyDescriptor" />。</summary>
        <returns>所要求的 <see cref="T:System.ComponentModel.DependencyPropertyDescriptor" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `name`可能會參考相依性屬性或附加的屬性，而且`name`參數形式傳遞至<xref:System.Windows.DependencyProperty.Register%2A>或<xref:System.Windows.DependencyProperty.RegisterAttached%2A>呼叫定義所討論的屬性。 `ownerType` 做為一次擁有屬性的物件類型傳遞給<xref:System.Windows.DependencyProperty.Register%2A>或<xref:System.Windows.DependencyProperty.RegisterAttached%2A>。 `targetType` 是您想要設定的屬性物件的類型。 相依性屬性`ownerType`和`targetType`都是相同的型別。 它們通常是不同的附加屬性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromName">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.DependencyPropertyDescriptor FromName (string name, Type ownerType, Type targetType, bool ignorePropertyType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.DependencyPropertyDescriptor FromName(string name, class System.Type ownerType, class System.Type targetType, bool ignorePropertyType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.DependencyPropertyDescriptor.FromName(System.String,System.Type,System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromName (name As String, ownerType As Type, targetType As Type, ignorePropertyType As Boolean) As DependencyPropertyDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::DependencyPropertyDescriptor ^ FromName(System::String ^ name, Type ^ ownerType, Type ^ targetType, bool ignorePropertyType);" />
      <MemberSignature Language="F#" Value="static member FromName : string * Type * Type * bool -&gt; System.ComponentModel.DependencyPropertyDescriptor" Usage="System.ComponentModel.DependencyPropertyDescriptor.FromName (name, ownerType, targetType, ignorePropertyType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.DependencyPropertyDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="targetType" Type="System.Type" />
        <Parameter Name="ignorePropertyType" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">相依性屬性或附加屬性的註冊名稱。</param>
        <param name="ownerType">擁有屬性定義之物件的 <see cref="T:System.Type" />。</param>
        <param name="targetType">您想要設定其屬性之物件的 <see cref="T:System.Type" />。</param>
        <param name="ignorePropertyType">指定以忽略屬性類型。</param>
        <summary>傳回所提供屬性名稱的 <see cref="T:System.ComponentModel.DependencyPropertyDescriptor" />。</summary>
        <returns>所要求的 <see cref="T:System.ComponentModel.DependencyPropertyDescriptor" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `name`可能會參考相依性屬性或附加的屬性，而且`name`參數形式傳遞至<xref:System.Windows.DependencyProperty.Register%2A>或<xref:System.Windows.DependencyProperty.RegisterAttached%2A>呼叫定義所討論的屬性。 `ownerType` 做為一次擁有屬性的物件類型傳遞給<xref:System.Windows.DependencyProperty.Register%2A>或<xref:System.Windows.DependencyProperty.RegisterAttached%2A>。 `targetType` 是您想要設定的屬性物件的類型。 相依性屬性`ownerType`和`targetType`都是相同的型別。 它們通常是不同的附加屬性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="FromProperty">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>根據使用的簽章，傳回以提供之 <see cref="T:System.ComponentModel.DependencyPropertyDescriptor" /> 或所提供之型別為基礎的 <see cref="T:System.ComponentModel.PropertyDescriptor" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FromProperty">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.DependencyPropertyDescriptor FromProperty (System.ComponentModel.PropertyDescriptor property);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.DependencyPropertyDescriptor FromProperty(class System.ComponentModel.PropertyDescriptor property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.DependencyPropertyDescriptor.FromProperty(System.ComponentModel.PropertyDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromProperty (property As PropertyDescriptor) As DependencyPropertyDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::DependencyPropertyDescriptor ^ FromProperty(System::ComponentModel::PropertyDescriptor ^ property);" />
      <MemberSignature Language="F#" Value="static member FromProperty : System.ComponentModel.PropertyDescriptor -&gt; System.ComponentModel.DependencyPropertyDescriptor" Usage="System.ComponentModel.DependencyPropertyDescriptor.FromProperty property" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.DependencyPropertyDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="System.ComponentModel.PropertyDescriptor" />
      </Parameters>
      <Docs>
        <param name="property">要進行檢查的 <see cref="T:System.ComponentModel.PropertyDescriptor" />。</param>
        <summary>傳回所提供 <see cref="T:System.ComponentModel.PropertyDescriptor" /> 的 <see cref="T:System.ComponentModel.DependencyPropertyDescriptor" />。</summary>
        <returns>如果 <paramref name="property" /> 所描述的屬性是相依性屬性，則會傳回有效的 <see cref="T:System.ComponentModel.DependencyPropertyDescriptor" />。 否則會傳回 <see langword="null" /><see cref="T:System.ComponentModel.DependencyPropertyDescriptor" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法是用來取得設計工具的應用程式的主要方法<xref:System.ComponentModel.DependencyPropertyDescriptor>檢查的所有屬性為基礎<xref:System.ComponentModel.PropertyDescriptor>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromProperty">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.DependencyPropertyDescriptor FromProperty (System.Windows.DependencyProperty dependencyProperty, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.DependencyPropertyDescriptor FromProperty(class System.Windows.DependencyProperty dependencyProperty, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.DependencyPropertyDescriptor.FromProperty(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::DependencyPropertyDescriptor ^ FromProperty(System::Windows::DependencyProperty ^ dependencyProperty, Type ^ targetType);" />
      <MemberSignature Language="F#" Value="static member FromProperty : System.Windows.DependencyProperty * Type -&gt; System.ComponentModel.DependencyPropertyDescriptor" Usage="System.ComponentModel.DependencyPropertyDescriptor.FromProperty (dependencyProperty, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.DependencyPropertyDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyProperty" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dependencyProperty">相依性屬性的識別項。</param>
        <param name="targetType">設定屬性之物件的類型。</param>
        <summary>傳回所提供之相依性屬性和目標類型的 <see cref="T:System.ComponentModel.DependencyPropertyDescriptor" />。</summary>
        <returns>所提供之相依性屬性的 <see cref="T:System.ComponentModel.DependencyPropertyDescriptor" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `dependencyProperty`可能參考相依性屬性或附加的屬性。 `targetType` 是您想要設定的屬性物件的類型。 相依性屬性的類型相當於<xref:System.Windows.DependencyProperty.OwnerType%2A>針對`dependencyProperty`。 為附加屬性`targetType`通常是其他<xref:System.Windows.DependencyObject>型別。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChildProperties">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.PropertyDescriptorCollection GetChildProperties (object instance, Attribute[] filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ComponentModel.PropertyDescriptorCollection GetChildProperties(object instance, class System.Attribute[] filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.DependencyPropertyDescriptor.GetChildProperties(System.Object,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChildProperties (instance As Object, filter As Attribute()) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::ComponentModel::PropertyDescriptorCollection ^ GetChildProperties(System::Object ^ instance, cli::array &lt;Attribute ^&gt; ^ filter);" />
      <MemberSignature Language="F#" Value="override this.GetChildProperties : obj * Attribute[] -&gt; System.ComponentModel.PropertyDescriptorCollection" Usage="dependencyPropertyDescriptor.GetChildProperties (instance, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
        <Parameter Name="filter" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="instance">要為其取得屬性的元件。</param>
        <param name="filter">做為篩選條件使用的 <see cref="T:System.Attribute" /> 類型陣列。</param>
        <summary>傳回 <see cref="T:System.ComponentModel.PropertyDescriptorCollection" />。</summary>
        <returns><see cref="T:System.ComponentModel.PropertyDescriptorCollection" />，其屬性 (Property) 符合指定元件的指定屬性 (Attribute)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法需仰賴基礎<xref:System.ComponentModel.PropertyDescriptor>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEditor">
      <MemberSignature Language="C#" Value="public override object GetEditor (Type editorBaseType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object GetEditor(class System.Type editorBaseType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.DependencyPropertyDescriptor.GetEditor(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEditor (editorBaseType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ GetEditor(Type ^ editorBaseType);" />
      <MemberSignature Language="F#" Value="override this.GetEditor : Type -&gt; obj" Usage="dependencyPropertyDescriptor.GetEditor editorBaseType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="editorBaseType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="editorBaseType">編輯器的基底型別 (Base Type)，用來區分屬性支援的多個編輯器。</param>
        <summary>取得指定型別的編輯器。</summary>
        <returns>要求的編輯器型別的執行個體，或者如果找不到，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法需仰賴基礎<xref:System.ComponentModel.PropertyDescriptor>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.DependencyPropertyDescriptor.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dependencyPropertyDescriptor.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回這個 <see cref="T:System.ComponentModel.DependencyPropertyDescriptor" /> 的雜湊程式碼。</summary>
        <returns>32 位元帶正負號的整數雜湊碼。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 雜湊碼<xref:System.ComponentModel.DependencyPropertyDescriptor>相依性屬性的識別項和型別，它會設定為基礎。 此實作可確保<xref:System.ComponentModel.DependencyPropertyDescriptor>不當不會傳回相同的雜湊碼的許多可能的衍生類別，繼承的屬性或屬性，否則會重新指派透過屬性系統。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public override object GetValue (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object GetValue(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.DependencyPropertyDescriptor.GetValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetValue (component As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ GetValue(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="override this.GetValue : obj -&gt; obj" Usage="dependencyPropertyDescriptor.GetValue component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">元件執行個體。</param>
        <summary>傳回元件上屬性的目前值。</summary>
        <returns>要求的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法需仰賴基礎<xref:System.ComponentModel.PropertyDescriptor>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAttached">
      <MemberSignature Language="C#" Value="public bool IsAttached { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAttached" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.DependencyPropertyDescriptor.IsAttached" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAttached As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAttached { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAttached : bool" Usage="System.ComponentModel.DependencyPropertyDescriptor.IsAttached" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出屬性是否註冊為附加屬性，並正透過附加使用方式使用中。</summary>
        <value>如果屬性是附加屬性，則為 <see langword="true" />；否則為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBrowsable">
      <MemberSignature Language="C#" Value="public override bool IsBrowsable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowsable" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.DependencyPropertyDescriptor.IsBrowsable" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsBrowsable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowsable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowsable : bool" Usage="System.ComponentModel.DependencyPropertyDescriptor.IsBrowsable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示屬性上的 <see cref="T:System.ComponentModel.BrowsableAttribute" /> 值。</summary>
        <value>如果在屬性上指定了 <see cref="T:System.ComponentModel.BrowsableAttribute" />，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會依賴基礎<xref:System.ComponentModel.PropertyDescriptor>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLocalizable">
      <MemberSignature Language="C#" Value="public override bool IsLocalizable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLocalizable" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.DependencyPropertyDescriptor.IsLocalizable" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsLocalizable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsLocalizable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLocalizable : bool" Usage="System.ComponentModel.DependencyPropertyDescriptor.IsLocalizable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，表示這個屬性是否應該當地語系化，如 <see cref="T:System.ComponentModel.LocalizableAttribute" /> 中指定的。</summary>
        <value>如果使用 true 值的 <see cref="T:System.ComponentModel.LocalizableAttribute" /> 建構函式標示成員，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會依賴基礎<xref:System.ComponentModel.PropertyDescriptor>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public override bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.DependencyPropertyDescriptor.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.ComponentModel.DependencyPropertyDescriptor.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，表示這個屬性是否為唯讀。</summary>
        <value>如果屬性是唯讀，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會依賴基礎<xref:System.ComponentModel.PropertyDescriptor>。  
  
 相依性屬性註冊為唯讀使用特定的方法呼叫，並依照慣例[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]反映和描述元所檢視的屬性的包裝函式屬性也必須是唯讀狀態。 不過，因為這是一種命名慣例，不需要編譯，您可能想要再次檢查相依性屬性識別項 「 唯讀 」 狀態。 若要這樣做，請取得識別項 (<xref:System.Windows.DependencyProperty>) 設定的值<xref:System.ComponentModel.DependencyPropertyDescriptor>，然後檢查的值<xref:System.Windows.DependencyProperty.ReadOnly%2A>。 請注意，<xref:System.Windows.DependencyProperty.ReadOnly%2A>上的識別項本身，不是中繼資料。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Metadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata Metadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyMetadata Metadata" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.DependencyPropertyDescriptor.Metadata" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Metadata As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyMetadata ^ Metadata { System::Windows::PropertyMetadata ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Metadata : System.Windows.PropertyMetadata" Usage="System.ComponentModel.DependencyPropertyDescriptor.Metadata" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得與相依性屬性相關聯的中繼資料。</summary>
        <value>相依性屬性中繼資料。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此值可以是`null`如果沒有任何中繼資料，或如果屬性不是相依性屬性。  
  
 中繼資料具有相符的概念[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]屬性是做為屬性中重新公開<xref:System.ComponentModel.DependencyPropertyDescriptor.Attributes%2A>集合。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyType">
      <MemberSignature Language="C#" Value="public override Type PropertyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type PropertyType" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.DependencyPropertyDescriptor.PropertyType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property PropertyType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ PropertyType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PropertyType : Type" Usage="System.ComponentModel.DependencyPropertyDescriptor.PropertyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得相依性屬性的代表 <see cref="T:System.Type" />。</summary>
        <value>相依性屬性的 <see cref="T:System.Type" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會傳回<xref:System.Type>已註冊的相依性屬性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveValueChanged">
      <MemberSignature Language="C#" Value="public override void RemoveValueChanged (object component, EventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void RemoveValueChanged(object component, class System.EventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.DependencyPropertyDescriptor.RemoveValueChanged(System.Object,System.EventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub RemoveValueChanged (component As Object, handler As EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void RemoveValueChanged(System::Object ^ component, EventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="override this.RemoveValueChanged : obj * EventHandler -&gt; unit" Usage="dependencyPropertyDescriptor.RemoveValueChanged (component, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="handler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="component">要為其加入處理常式的元件。</param>
        <param name="handler">要加入以做為接聽程式 (Listener) 的委派。</param>
        <summary>使其他物件能在這個屬性變更時受到告知。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法需仰賴基礎<xref:System.ComponentModel.PropertyDescriptor>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetValue">
      <MemberSignature Language="C#" Value="public override void ResetValue (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ResetValue(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.DependencyPropertyDescriptor.ResetValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ResetValue (component As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ResetValue(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="override this.ResetValue : obj -&gt; unit" Usage="dependencyPropertyDescriptor.ResetValue component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">屬性值要重設為預設值的元件。</param>
        <summary>將元件的這個屬性值重設為預設值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法需仰賴基礎<xref:System.ComponentModel.PropertyDescriptor>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public override void SetValue (object component, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetValue(object component, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.DependencyPropertyDescriptor.SetValue(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetValue (component As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetValue(System::Object ^ component, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.SetValue : obj * obj -&gt; unit" Usage="dependencyPropertyDescriptor.SetValue (component, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">屬性值將要設定的元件。</param>
        <param name="value">新值。</param>
        <summary>將元件的值設定為不同的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法需仰賴基礎<xref:System.ComponentModel.PropertyDescriptor>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeValue">
      <MemberSignature Language="C#" Value="public override bool ShouldSerializeValue (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool ShouldSerializeValue(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.DependencyPropertyDescriptor.ShouldSerializeValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ShouldSerializeValue (component As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool ShouldSerializeValue(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="override this.ShouldSerializeValue : obj -&gt; bool" Usage="dependencyPropertyDescriptor.ShouldSerializeValue component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">元件，具有要檢查保存性 (Persistence) 的屬性。</param>
        <summary>指出這個屬性值是否需要由序列化處理序保存。</summary>
        <returns>如果屬性應該要保存，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsChangeEvents">
      <MemberSignature Language="C#" Value="public override bool SupportsChangeEvents { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsChangeEvents" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.DependencyPropertyDescriptor.SupportsChangeEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property SupportsChangeEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsChangeEvents { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsChangeEvents : bool" Usage="System.ComponentModel.DependencyPropertyDescriptor.SupportsChangeEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指示這個屬性的數值變更告知是否可能來自屬性描述項之外 (例如來自元件本身)，或者告知只會來自 <see cref="M:System.ComponentModel.DependencyPropertyDescriptor.SetValue(System.Object,System.Object)" /> 的直接呼叫。</summary>
        <value>如果這個屬性的告知可能來自屬性描述項之外，例如來自元件本身，則為 <see langword="true" />。 如果告知只來自 <see cref="M:System.ComponentModel.DependencyPropertyDescriptor.SetValue(System.Object,System.Object)" /> 的直接呼叫，則為 <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 比方說，針對`true`的情況下，元件可能會實作<xref:System.ComponentModel.INotifyPropertyChanged>介面，或可能有明確`propertyName.Changed`此屬性的事件。  
  
 這個屬性會依賴基礎<xref:System.ComponentModel.PropertyDescriptor>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.DependencyPropertyDescriptor.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dependencyPropertyDescriptor.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將這個執行個體的值轉換為它的相等字串表示。</summary>
        <returns>傳回 <see cref="P:System.ComponentModel.MemberDescriptor.Name" /> 值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>