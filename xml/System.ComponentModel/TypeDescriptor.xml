<Type Name="TypeDescriptor" FullName="System.ComponentModel.TypeDescriptor">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="402b90676782f23b4720487e8f9cc3febcd32c4e" />
    <Meta Name="ms.sourcegitcommit" Value="4b4804968da1dfdf71c501075a5b66957b54f2e8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/27/2018" />
    <Meta Name="ms.locfileid" Value="32038095" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class TypeDescriptor" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit TypeDescriptor extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.TypeDescriptor" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class TypeDescriptor" />
  <TypeSignature Language="C++ CLI" Value="public ref class TypeDescriptor sealed" />
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>提供元件特性的相關資訊，例如其屬性 (attribute)、屬性 (property) 與事件。 這個類別無法被繼承。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 提供兩種方式可存取的型別上的中繼資料： 反映應用程式開發介面中提供<xref:System.Reflection?displayProperty=nameWithType>命名空間，而<xref:System.ComponentModel.TypeDescriptor>類別。 Reflection 相當適用於所有類型的一般機制，因為其在中建立<xref:System.Object.GetType%2A>方法的根<xref:System.Object>類別。 無法修改目標型別進行編譯之後，是無法延伸，它會傳回類型的資訊。 如需詳細資訊，請參閱[反映](~/docs/framework/reflection-and-codedom/reflection.md)。  
  
 相反地，<xref:System.ComponentModel.TypeDescriptor>是元件的可延伸檢查機制： 那些類別可實作<xref:System.ComponentModel.IComponent>介面。 不同於反映，它不會檢查的方法。 <xref:System.ComponentModel.TypeDescriptor> 可以由數個服務可透過目標元件的動態擴充<xref:System.ComponentModel.Component.Site%2A>。 下表顯示這些服務。  
  
|服務名稱|描述|  
|------------------|-----------------|  
|<xref:System.ComponentModel.IExtenderProvider>|讓您在另一個類別，例如<xref:System.Windows.Forms.ToolTip>，以提供給元件的額外屬性。|  
|<xref:System.ComponentModel.Design.ITypeDescriptorFilterService>|可讓另一個物件以修改元件所公開的標準中繼資料。|  
|<xref:System.ComponentModel.ICustomTypeDescriptor>|可讓類別完全以動態的方式指定自己的中繼資料，取代的標準檢查機制<xref:System.ComponentModel.TypeDescriptor>。|  
  
 所提供的擴充性<xref:System.ComponentModel.TypeDescriptor>可讓不同於它的實際執行階段，表示，可讓元件的設計階段表示<xref:System.ComponentModel.TypeDescriptor>適用於建立設計階段基礎結構。  
  
 中的所有方法<xref:System.ComponentModel.TypeDescriptor>是`static`。 您無法建立這個類別的執行個體，這個類別無法被繼承。  
  
 您可以設定屬性和事件值兩種不同方式： 在元件類別中指定或變更它們在設計階段。 因為您可以設定這些值兩種方式，多載方法的<xref:System.ComponentModel.TypeDescriptor>採用兩個不同類型的參數： 類別類型或物件執行個體。  
  
 當您想要存取<xref:System.ComponentModel.TypeDescriptor>資訊和您擁有之物件的執行個體，請使用元件呼叫的方法。 使用您不需要物件的執行個體時，才會呼叫類別類型的方法。  
  
 屬性和事件不會快取<xref:System.ComponentModel.TypeDescriptor>速度。 通常，它們都維持不變的物件存留期。 不過，擴充性提供者和設計工具可以變更物件上的屬性的集。 如果這種情況，則<xref:System.ComponentModel.TypeDescriptor.Refresh%2A>必須呼叫方法來更新快取。  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ComponentModel.EventDescriptor" />
    <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
    <altmember cref="N:System.Reflection" />
    <altmember cref="T:System.ComponentModel.IComponent" />
    <altmember cref="T:System.ComponentModel.ISite" />
  </Docs>
  <Members>
    <MemberGroup MemberName="AddAttributes">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將類別層級屬性加入目標元件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddAttributes">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.TypeDescriptionProvider AddAttributes (object instance, params Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.TypeDescriptionProvider AddAttributes(object instance, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.AddAttributes(System.Object,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAttributes (instance As Object, ParamArray attributes As Attribute()) As TypeDescriptionProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::TypeDescriptionProvider ^ AddAttributes(System::Object ^ instance, ... cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeDescriptionProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
        <Parameter Name="attributes" Type="System.Attribute[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">目標元件的執行個體。</param>
        <param name="attributes">要加入至元件類別的 <see cref="T:System.Attribute" /> 物件陣列。</param>
        <summary>將類別層級屬性加入目標元件執行個體。</summary>
        <returns>用來加入指定屬性的新建立 <see cref="T:System.ComponentModel.TypeDescriptionProvider" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.TypeDescriptor.AddAttributes%28System.Object%2CSystem.Attribute%5B%5D%29>方法將類別層級屬性加入至元件的指定執行個體。 因為這是常見的需求，使用 Visual Studio Windows Form 設計工具和 [屬性] 視窗的應用程式時，這個方法會藉由建立已合併的屬性提供的屬性類型描述提供者提供捷徑存在於類別。 傳回值是用來將屬性加入類型描述提供者。 此提供者可以稍後傳遞到<xref:System.ComponentModel.TypeDescriptor.RemoveProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29>方法時不再需要新增的屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">參數的其中之一或兩者都是 <see langword="null" />。</exception>
        <permission cref="T:System.Security.NamedPermissionSet">系統資源的完整存取權。 要求的值： <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />。 相關聯的狀態：</permission>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
      </Docs>
    </Member>
    <Member MemberName="AddAttributes">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.TypeDescriptionProvider AddAttributes (Type type, params Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.TypeDescriptionProvider AddAttributes(class System.Type type, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.AddAttributes(System.Type,System.Attribute[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::TypeDescriptionProvider ^ AddAttributes(Type ^ type, ... cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeDescriptionProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Attribute[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">目標元件的 <see cref="T:System.Type" />。</param>
        <param name="attributes">要加入至元件類別的 <see cref="T:System.Attribute" /> 物件陣列。</param>
        <summary>將類別層級屬性加入目標元件類型。</summary>
        <returns>用來加入指定屬性的新建立 <see cref="T:System.ComponentModel.TypeDescriptionProvider" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.TypeDescriptor.AddAttributes%28System.Type%2CSystem.Attribute%5B%5D%29>方法將類別層級屬性加入至指定類型的元件。 因為這是常見的需求，使用 Visual Studio Windows Form 設計工具和 [屬性] 視窗的應用程式時，這個方法會藉由建立已合併的屬性提供的屬性類型描述提供者提供捷徑存在於類別。 傳回值是用來將屬性加入類型描述提供者。 此提供者可以稍後傳遞到<xref:System.ComponentModel.TypeDescriptor.RemoveProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29>方法時不再需要新增的屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">參數的其中之一或兩者都是 <see langword="null" />。</exception>
        <permission cref="T:System.Security.NamedPermissionSet">系統資源的完整存取權。 要求的值： <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />。 相關聯的狀態：</permission>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
      </Docs>
    </Member>
    <Member MemberName="AddEditorTable">
      <MemberSignature Language="C#" Value="public static void AddEditorTable (Type editorBaseType, System.Collections.Hashtable table);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddEditorTable(class System.Type editorBaseType, class System.Collections.Hashtable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.AddEditorTable(System.Type,System.Collections.Hashtable)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddEditorTable (editorBaseType As Type, table As Hashtable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddEditorTable(Type ^ editorBaseType, System::Collections::Hashtable ^ table);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="editorBaseType" Type="System.Type" />
        <Parameter Name="table" Type="System.Collections.Hashtable" />
      </Parameters>
      <Docs>
        <param name="editorBaseType">要加入編輯器資料表的編輯器基底類型。 如果此類型已經有資料表，這個方法將不會採取任何動作。</param>
        <param name="table">要加入的 <see cref="T:System.Collections.Hashtable" />。</param>
        <summary>為指定的編輯器基底類型加入編輯器資料表。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.TypeDescriptor.AddEditorTable%2A>方法加入編輯器資料表指定的編輯器的基底類型。 一般而言，編輯器會指定為在元件上的中繼資料。 不過，如果沒有中繼資料要求的編輯器基底類型就可以找到上相關聯的元件<xref:System.ComponentModel.TypeDescriptor>將資料表中搜尋編輯器的編輯器類型，如果可以找到其中一個。 一旦加入編輯器資料表類型描述元，它無法移除，並擁有的型別描述項。 類型描述元可以自由修改這個資料表。  
  
 編輯器資料表的格式會使用資料類型做為索引鍵和編輯器做為值。 項目資料表中的值部分表示編輯器執行個體。 它可以有三個值之一。 如果它包含的字串，這是完整限定的名稱的型別，然後載入型別物件假設的類型描述元。 如果它包含的類型，將建立此類型的執行個體取得編輯器。 最後，值部分可能會包含實際編輯器執行個體。 如果類型描述元解析編輯器執行個體，它會儲存在資料表供未來使用的執行個體。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.AddProvider" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEditor" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AddProvider">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將類型描述提供者加入這個類型描述元的提供者清單。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddProvider">
      <MemberSignature Language="C#" Value="public static void AddProvider (System.ComponentModel.TypeDescriptionProvider provider, object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddProvider(class System.ComponentModel.TypeDescriptionProvider provider, object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.AddProvider(System.ComponentModel.TypeDescriptionProvider,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddProvider (provider As TypeDescriptionProvider, instance As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddProvider(System::ComponentModel::TypeDescriptionProvider ^ provider, System::Object ^ instance);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">要加入的 <see cref="T:System.ComponentModel.TypeDescriptionProvider" />。</param>
        <param name="instance">目標元件的執行個體。</param>
        <summary>加入元件之單一執行個體的類型描述提供者。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29>方法會將類型描述提供者提供輸入元件的單一執行個體的資訊。 如果提供者會使用這個方法，提供者的加入<xref:System.ComponentModel.TypeDescriptor.CreateInstance%2A>將不會呼叫方法，因為執行個體已經存在。  
  
 這個方法不會維護硬式元件，參考，所以它不會阻止元件正在完成。  
  
 它是可以加入多個相同的型別或物件的類型描述提供者。 如果發生這種情況，將會以獨佔方式使用的第一個類型描述提供者遇到提供型別資訊。 由於型別資訊提供者會儲存在堆疊中，加入的最後一個提供者將會第一個查詢。 此行為可讓<xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29>和<xref:System.ComponentModel.TypeDescriptor.RemoveProvider%2A>要使用推入和彈出方法類型描述提供者所需的特定案例。  
  
 如果成功，這個方法會呼叫<xref:System.ComponentModel.TypeDescriptor.Refresh%28System.Object%29>方法`instance`參數。  
  
> [!NOTE]
>  這個方法的兩個版本會產生不同的領域的結果。 <xref:System.ComponentModel.TypeDescriptor.AddProvider%2A>採用方法<xref:System.Object>參數會影響指定之元件的單一執行個體。 相反地，其他多載，其可接受<xref:System.Type>參數，會影響該類型所描述之元件的所有執行個體。  
  
 使用<xref:System.ComponentModel.TypeDescriptor.AddProviderTransparent%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29>方法，如果您需要從部分信任程式碼呼叫。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">參數的其中之一或兩者都是 <see langword="null" />。</exception>
        <permission cref="T:System.Security.NamedPermissionSet">系統資源的完整存取權。 要求的值： <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />。 相關聯的狀態：</permission>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.RemoveProvider" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetProvider(System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="AddProvider">
      <MemberSignature Language="C#" Value="public static void AddProvider (System.ComponentModel.TypeDescriptionProvider provider, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddProvider(class System.ComponentModel.TypeDescriptionProvider provider, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.AddProvider(System.ComponentModel.TypeDescriptionProvider,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddProvider(System::ComponentModel::TypeDescriptionProvider ^ provider, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="provider">要加入的 <see cref="T:System.ComponentModel.TypeDescriptionProvider" />。</param>
        <param name="type">目標元件的 <see cref="T:System.Type" />。</param>
        <summary>加入元件類別的類型描述提供者。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29>方法會將類型描述提供者提供類型為指定的類別、 衍生的類別，以及這些類型的所有執行個體的資訊。  
  
> [!NOTE]
>  `type`參數可以是任何類型，包括介面。 例如，若要提供自訂型別和所有元件的執行個體資訊，您會指定`typeof(IComponent)`。 傳遞`typeof(object)`會呼叫提供者提供的所有類型的類型資訊。  
  
 這個方法不會維護硬式參考任何物件，所以它無法防止進行最終處理物件。  
  
 它是可以加入多個相同的型別或物件的類型描述提供者。 如果發生這種情況，將會以獨佔方式使用的第一個類型描述提供者遇到提供型別資訊。 因為型別資訊提供者會儲存在堆疊中，加入的最後一個提供者會是第一個查詢。 此行為可讓<xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29>和<xref:System.ComponentModel.TypeDescriptor.RemoveProvider%2A>要使用推入和彈出方法類型描述提供者所需的特定案例。  
  
 如果成功，這個方法會呼叫<xref:System.ComponentModel.TypeDescriptor.Refresh%28System.Type%29>方法`type`參數。  
  
> [!NOTE]
>  這個方法的兩個版本會產生不同的領域的結果。 <xref:System.ComponentModel.TypeDescriptor.AddProvider%2A>採用方法<xref:System.Object>參數會影響指定之元件的單一執行個體。 相反地，其他多載，其可接受<xref:System.Type>參數，會影響該類型所描述之元件的所有執行個體。  
  
 使用<xref:System.ComponentModel.TypeDescriptor.AddProviderTransparent%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29>方法，如果您需要從部分信任程式碼呼叫。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">參數的其中之一或兩者都是 <see langword="null" />。</exception>
        <permission cref="T:System.Security.NamedPermissionSet">系統資源的完整存取權。 要求的值： <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />。 相關聯的狀態：</permission>
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetProvider(System.Type)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AddProviderTransparent">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將類型描述提供者加入這個類型描述元的提供者清單。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddProviderTransparent">
      <MemberSignature Language="C#" Value="public static void AddProviderTransparent (System.ComponentModel.TypeDescriptionProvider provider, object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddProviderTransparent(class System.ComponentModel.TypeDescriptionProvider provider, object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.AddProviderTransparent(System.ComponentModel.TypeDescriptionProvider,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddProviderTransparent (provider As TypeDescriptionProvider, instance As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddProviderTransparent(System::ComponentModel::TypeDescriptionProvider ^ provider, System::Object ^ instance);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">要加入的 <see cref="T:System.ComponentModel.TypeDescriptionProvider" />。</param>
        <param name="instance">目標元件的執行個體。</param>
        <summary>加入元件之單一執行個體的類型描述提供者。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以從部分信任程式碼呼叫這個方法。 如果<xref:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess>是定義，呼叫端可以註冊指定的執行個體的提供者，如果其類型也受到部分信任。  
  
 使用<xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29>方法，如果您不需要從部分信任程式碼呼叫。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">參數的其中之一或兩者都是 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.TypeDescriptorPermission">用於登錄存取。 安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess" /></permission>
        <permission cref="P:System.Reflection.Assembly.PermissionSet">安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。 關聯的類型：<see cref="T:System.Security.PermissionSet" />所定義的組件所需<paramref name="instance" />參數的型別。</permission>
      </Docs>
    </Member>
    <Member MemberName="AddProviderTransparent">
      <MemberSignature Language="C#" Value="public static void AddProviderTransparent (System.ComponentModel.TypeDescriptionProvider provider, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddProviderTransparent(class System.ComponentModel.TypeDescriptionProvider provider, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.AddProviderTransparent(System.ComponentModel.TypeDescriptionProvider,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddProviderTransparent(System::ComponentModel::TypeDescriptionProvider ^ provider, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="provider">要加入的 <see cref="T:System.ComponentModel.TypeDescriptionProvider" />。</param>
        <param name="type">目標元件的 <see cref="T:System.Type" />。</param>
        <summary>加入元件類別的類型描述提供者。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以從部分信任程式碼呼叫這個方法。 如果<xref:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess>是定義，呼叫端可以註冊為指定的型別提供者，如果也受到部分信任。  
  
 使用<xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29>方法，如果您不需要從部分信任程式碼呼叫。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">參數的其中之一或兩者都是 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.TypeDescriptorPermission">用於登錄存取。 安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess" /></permission>
        <permission cref="P:System.Reflection.Assembly.PermissionSet">安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。 關聯的類型：<see cref="T:System.Security.PermissionSet" />所定義的組件所需<paramref name="type" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="ComNativeDescriptorHandler">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.IComNativeDescriptorHandler ComNativeDescriptorHandler { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.ComponentModel.IComNativeDescriptorHandler ComNativeDescriptorHandler" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.TypeDescriptor.ComNativeDescriptorHandler" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ComNativeDescriptorHandler As IComNativeDescriptorHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::ComponentModel::IComNativeDescriptorHandler ^ ComNativeDescriptorHandler { System::ComponentModel::IComNativeDescriptorHandler ^ get(); void set(System::ComponentModel::IComNativeDescriptorHandler ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This property has been deprecated.  Use a type description provider to supply type information for COM types instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.IComNativeDescriptorHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定目標元件之元件物件模型 (COM) 類型資訊的提供者。</summary>
        <value>
          <see cref="T:System.ComponentModel.IComNativeDescriptorHandler" /> 執行個體，代表 COM 類型資訊提供者。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.TypeDescriptor.ComNativeDescriptorHandler%2A>屬性和<xref:System.ComponentModel.IComNativeDescriptorHandler>介面已經過時。 如需詳細資訊，請參閱 <xref:System.ComponentModel.TypeDescriptor.ComObjectType%2A> 屬性 (Property)。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.NamedPermissionSet">系統資源的完整存取權。 要求的值： <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />。 相關聯的狀態：</permission>
        <altmember cref="P:System.ComponentModel.TypeDescriptor.ComObjectType" />
      </Docs>
    </Member>
    <Member MemberName="ComObjectType">
      <MemberSignature Language="C#" Value="public static Type ComObjectType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Type ComObjectType" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.TypeDescriptor.ComObjectType" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ComObjectType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Type ^ ComObjectType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得以目標元件表示之元件物件模型 (COM) 物件的類型。</summary>
        <value>以這個元件表示之 COM 物件的 <see cref="T:System.Type" />；如果不是 COM 物件，則為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.TypeDescriptor.ComObjectType%2A>屬性會傳回可傳遞至型別<xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29>方法，以定義 COM 類型的類型描述提供者。  
  
 <xref:System.ComponentModel.TypeDescriptor.ComObjectType%2A>屬性與這個類別中的其他成員取代過時的功能<xref:System.ComponentModel.IComNativeDescriptorHandler>介面。 若要實作 COM 物件之間的對應層和<xref:System.ComponentModel.TypeDescriptor>，新增<xref:System.ComponentModel.TypeDescriptionProvider>處理類型<xref:System.ComponentModel.TypeDescriptor.ComObjectType%2A>。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.TypeDescriptor.ComNativeDescriptorHandler" />
      </Docs>
    </Member>
    <Member MemberName="CreateAssociation">
      <MemberSignature Language="C#" Value="public static void CreateAssociation (object primary, object secondary);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateAssociation(object primary, object secondary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.CreateAssociation(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateAssociation (primary As Object, secondary As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateAssociation(System::Object ^ primary, System::Object ^ secondary);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="primary" Type="System.Object" />
        <Parameter Name="secondary" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="primary">主要 <see cref="T:System.Object" />。</param>
        <param name="secondary">次要 <see cref="T:System.Object" />。</param>
        <summary>建立兩個物件之間的主要-次要關聯。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.TypeDescriptor.CreateAssociation%2A>方法會建立主要和次要物件之間的關聯。 一旦建立關聯時，設計工具或其他篩選的機制就可以新增到主要物件的屬性集路由傳送至其中一個物件的屬性。 當屬性的引動過程會對主要物件，<xref:System.ComponentModel.TypeDescriptor.GetAssociation%2A>將呼叫方法，來解決與型別參數的實際物件執行個體。  
  
 A<xref:System.WeakReference>是用來維護主要和次要物件之間的關聯; 因此，這個方法不會阻止任一個物件正在完成並回收進行回收。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">參數的其中之一或兩者都是 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="primary" /> 等於 <paramref name="secondary" />。</exception>
        <permission cref="T:System.Security.NamedPermissionSet">系統資源的完整存取權。 要求的值： <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />。 相關聯的狀態：</permission>
        <altmember cref="M:System.ComponentModel.TypeDescriptor.RemoveAssociation(System.Object,System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetAssociation(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CreateDesigner">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.Design.IDesigner CreateDesigner (System.ComponentModel.IComponent component, Type designerBaseType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.Design.IDesigner CreateDesigner(class System.ComponentModel.IComponent component, class System.Type designerBaseType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.CreateDesigner(System.ComponentModel.IComponent,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDesigner (component As IComponent, designerBaseType As Type) As IDesigner" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::Design::IDesigner ^ CreateDesigner(System::ComponentModel::IComponent ^ component, Type ^ designerBaseType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.Design.IDesigner</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.ComponentModel.IComponent" />
        <Parameter Name="designerBaseType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="component">
          <see cref="T:System.ComponentModel.IComponent" />，指定要與設計工具關聯的元件。</param>
        <param name="designerBaseType">
          <see cref="T:System.Type" />，代表要建立的設計工具類型。</param>
        <summary>建立與指定元件關聯並屬於指定設計工具類型的設計工具執行個體。</summary>
        <returns>
          <see cref="T:System.ComponentModel.Design.IDesigner" />，亦即元件的設計工具執行個體；如果找不到設計工具，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此方法找不到有效<xref:System.ComponentModel.DesignerAttribute>，它會搜尋類別階層架構設計工具。 如果找不到設計工具類別階層架構中，它會傳回`null`。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.IComponent" />
        <altmember cref="T:System.ComponentModel.Design.IDesigner" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetConverter" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEditor" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateEvent">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立新的事件描述元，其等同於現有的事件描述元。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateEvent">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptor CreateEvent (Type componentType, System.ComponentModel.EventDescriptor oldEventDescriptor, params Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptor CreateEvent(class System.Type componentType, class System.ComponentModel.EventDescriptor oldEventDescriptor, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.CreateEvent(System.Type,System.ComponentModel.EventDescriptor,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateEvent (componentType As Type, oldEventDescriptor As EventDescriptor, ParamArray attributes As Attribute()) As EventDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptor ^ CreateEvent(Type ^ componentType, System::ComponentModel::EventDescriptor ^ oldEventDescriptor, ... cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
        <Parameter Name="oldEventDescriptor" Type="System.ComponentModel.EventDescriptor" />
        <Parameter Name="attributes" Type="System.Attribute[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="componentType">要建立新事件的元件類型。</param>
        <param name="oldEventDescriptor">現有的事件資訊。</param>
        <param name="attributes">新屬性</param>
        <summary>當傳遞到現有的 <see cref="T:System.ComponentModel.EventDescriptor" /> 時，建立與現有事件描述元相同的新事件描述元。</summary>
        <returns>新的 <see cref="T:System.ComponentModel.EventDescriptor" />，其合併了指定的中繼資料屬性與現有的中繼資料屬性。</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">需要檢查元件的非公用成員。 連結 視需要存取所需的<see cref="T:System.Security.Permissions.ReflectionPermissionFlag" />類型<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
      </Docs>
    </Member>
    <Member MemberName="CreateEvent">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptor CreateEvent (Type componentType, string name, Type type, params Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptor CreateEvent(class System.Type componentType, string name, class System.Type type, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.CreateEvent(System.Type,System.String,System.Type,System.Attribute[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptor ^ CreateEvent(Type ^ componentType, System::String ^ name, Type ^ type, ... cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Attribute[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="componentType">此事件所在的元件類型。</param>
        <param name="name">事件的名稱。</param>
        <param name="type">處理此事件的委派類型。</param>
        <param name="attributes">這個事件的屬性。</param>
        <summary>從類型上指定事件動態產生描述項資訊，藉此建立與現有事件描述項相同的新的事件描述項。</summary>
        <returns>繫結至類型的 <see cref="T:System.ComponentModel.EventDescriptor" />。</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">需要檢查元件的非公用成員。 連結 視需要存取所需的<see cref="T:System.Security.Permissions.ReflectionPermissionFlag" />類型<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (IServiceProvider provider, Type objectType, Type[] argTypes, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.IServiceProvider provider, class System.Type objectType, class System.Type[] argTypes, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (provider As IServiceProvider, objectType As Type, argTypes As Type(), args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(IServiceProvider ^ provider, Type ^ objectType, cli::array &lt;Type ^&gt; ^ argTypes, cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IServiceProvider" />
        <Parameter Name="objectType" Type="System.Type" />
        <Parameter Name="argTypes" Type="System.Type[]" />
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="provider">提供 <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> 服務的服務提供者。 這個參數可以是 <see langword="null" />。</param>
        <param name="objectType">要建立的物件 <see cref="T:System.Type" />。</param>
        <param name="argTypes">要傳遞給物件建構函式的選擇性參數類型陣列。 這個參數可以是 <see langword="null" /> 或長度為零的陣列。</param>
        <param name="args">要傳遞給物件建構函式的選擇性參數值陣列。 如果不是 <see langword="null" />，元素數就必須和 <c>argTypes</c> 相同。</param>
        <summary>建立可以代替另一種資料類型的物件。</summary>
        <returns>如果找到相關聯的 <see cref="T:System.ComponentModel.TypeDescriptionProvider" />，則為替代資料類型的執行個體；否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.TypeDescriptor.CreateInstance%2A>方法會搜尋<xref:System.ComponentModel.TypeDescriptionProvider>聯指定`objectType`資料型別。 這個方法會先嘗試取得的類型描述提供者，從`provider`參數。 如果失敗，它會搜尋它自己的內部資料表的提供者 (透過先前呼叫所建立這些項目<xref:System.ComponentModel.TypeDescriptor.AddProvider%2A>)。 如果它找到的提供者，這個方法會委派給該物件將建立呼叫。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="objectType" /> 是 <see langword="null" /> 或 <paramref name="args" /> 是 <see langword="null" />，當 <paramref name="argTypes" /> 不是 <see langword="null" /> 時。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argTypes" /> 和 <paramref name="args" /> 的項目數不同。</exception>
        <block subset="none" type="overrides">
          <para>如果衍生的類別沒有提供替代的執行個體，這個方法應該呼叫基底實作。</para>
        </block>
        <altmember cref="M:System.ComponentModel.TypeDescriptionProvider.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetClassName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetComponentName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.AddProvider" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateProperty">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>為元件現有屬性建立新的屬性描述項。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateProperty">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptor CreateProperty (Type componentType, System.ComponentModel.PropertyDescriptor oldPropertyDescriptor, params Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptor CreateProperty(class System.Type componentType, class System.ComponentModel.PropertyDescriptor oldPropertyDescriptor, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.CreateProperty(System.Type,System.ComponentModel.PropertyDescriptor,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateProperty (componentType As Type, oldPropertyDescriptor As PropertyDescriptor, ParamArray attributes As Attribute()) As PropertyDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptor ^ CreateProperty(Type ^ componentType, System::ComponentModel::PropertyDescriptor ^ oldPropertyDescriptor, ... cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
        <Parameter Name="oldPropertyDescriptor" Type="System.ComponentModel.PropertyDescriptor" />
        <Parameter Name="attributes" Type="System.Attribute[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="componentType">屬性所屬之元件的 <see cref="T:System.Type" />。</param>
        <param name="oldPropertyDescriptor">現有的屬性描述項。</param>
        <param name="attributes">這個屬性 (Property) 的新屬性 (Attribute)。</param>
        <summary>使用指定的現有 <see cref="T:System.ComponentModel.PropertyDescriptor" /> 和屬性 (Attribute) 陣列，從現有屬性 (Property) 描述項建立新屬性 (Property) 描述項。</summary>
        <returns>新的 <see cref="T:System.ComponentModel.PropertyDescriptor" />，這個描述項已經將指定的中繼資料屬性與現有的中繼資料屬性合併。</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">需要檢查元件的非公用成員。 連結 視需要存取所需的<see cref="T:System.Security.Permissions.ReflectionPermissionFlag" />類型<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
      </Docs>
    </Member>
    <Member MemberName="CreateProperty">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptor CreateProperty (Type componentType, string name, Type type, params Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptor CreateProperty(class System.Type componentType, string name, class System.Type type, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.CreateProperty(System.Type,System.String,System.Type,System.Attribute[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptor ^ CreateProperty(Type ^ componentType, System::String ^ name, Type ^ type, ... cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Attribute[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="componentType">屬性所屬之元件的 <see cref="T:System.Type" />。</param>
        <param name="name">屬性的名稱。</param>
        <param name="type">屬性的 <see cref="T:System.Type" />。</param>
        <param name="attributes">這個屬性 (Property) 的新屬性 (Attribute)。</param>
        <summary>使用指定的屬性名稱、類型和屬性陣列，建立並以動態方式將屬性描述項繫結至類型。</summary>
        <returns>
          <see cref="T:System.ComponentModel.PropertyDescriptor" />，繫結至指定的類型，且具有與現有的中繼資料屬性合併的指定的中繼資料屬性。</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">需要檢查元件的非公用成員。 連結 視需要存取所需的<see cref="T:System.Security.Permissions.ReflectionPermissionFlag" />類型<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
      </Docs>
    </Member>
    <Member MemberName="GetAssociation">
      <MemberSignature Language="C#" Value="public static object GetAssociation (Type type, object primary);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetAssociation(class System.Type type, object primary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetAssociation(System.Type,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetAssociation(Type ^ type, System::Object ^ primary);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="primary" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="type">目標元件的 <see cref="T:System.Type" />。</param>
        <param name="primary">關聯的主要物件。</param>
        <summary>傳回與指定主要物件相關聯類型的執行個體。</summary>
        <returns>如果關聯存在，則為與主要物件關聯的次要型別執行個體，如果指定的關聯不存在，則為 <paramref name="primary" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果先前的關聯對`type`參數使用<xref:System.ComponentModel.TypeDescriptor.CreateAssociation%2A>方法，然後在<xref:System.ComponentModel.TypeDescriptor.GetAssociation%2A>方法會傳回要為要求的型別叫用正確的次要物件。 否則，<xref:System.ComponentModel.TypeDescriptor.GetAssociation%2A>相容設計工具搜尋`type`，如果找到就傳回設計工具。 這個方法永遠不會傳回 `null`。  
  
 A<xref:System.WeakReference>是用來維護主要和次要物件之間的關聯; 因此，這個方法不會阻止主要或次要物件正在完成並回收進行回收。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">參數的其中之一或兩者都是 <see langword="null" />。</exception>
        <altmember cref="M:System.ComponentModel.Design.IDesignerHost.GetDesigner(System.ComponentModel.IComponent)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateAssociation(System.Object,System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.RemoveAssociation(System.Object,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAttributes">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回元件或類型的屬性集合。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAttributes">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.AttributeCollection GetAttributes (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.AttributeCollection GetAttributes(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetAttributes(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAttributes (component As Object) As AttributeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::AttributeCollection ^ GetAttributes(System::Object ^ component);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AttributeCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">您要取得屬性的元件。</param>
        <summary>傳回指定元件的屬性集合。</summary>
        <returns>包含元件屬性的 <see cref="T:System.ComponentModel.AttributeCollection" />。 如果 <paramref name="component" /> 是 <see langword="null" />，這個方法會傳回空的集合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 所傳回的屬性<xref:System.ComponentModel.TypeDescriptor.GetAttributes%2A>方法可能會動態修改擴充性提供者所列出的原始元件的來源 (<xref:System.ComponentModel.IExtenderProvider>)，篩選服務 (<xref:System.ComponentModel.Design.ITypeDescriptorFilterService>)，和屬性篩選。  
  
 當您定義自訂屬性與<xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType>設`true`，您必須覆寫<xref:System.Attribute.TypeId%2A?displayProperty=nameWithType>讓其成為唯一的屬性。 如果您的屬性的所有執行個體是唯一的覆寫<xref:System.Attribute.TypeId%2A?displayProperty=nameWithType>來傳回屬性的物件識別。 如果只有某些屬性的執行個體是唯一的傳回值，以從<xref:System.Attribute.TypeId%2A?displayProperty=nameWithType>，可在這些情況下傳回是否相等。 例如，某些屬性具有建構函式參數，可做為唯一索引鍵。 對於這些屬性會傳回從建構函式參數的值<xref:System.Attribute.TypeId%2A?displayProperty=nameWithType>屬性。  
  
> [!NOTE]
>  預設實作<xref:System.Attribute.TypeId%2A?displayProperty=nameWithType>傳回型別身分識別的值為何<xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType>屬性。 為了傳回多個執行個體<xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType>屬性從<xref:System.ComponentModel.AttributeCollection>，您的屬性必須覆寫<xref:System.Attribute.TypeId%2A?displayProperty=nameWithType>屬性。  
  
   
  
## Examples  
 如需這個方法的範例，請參閱<xref:System.ComponentModel.AttributeCollection.Matches%2A>方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Attribute" />
        <altmember cref="T:System.ComponentModel.AttributeCollection" />
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.AddAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributes">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.AttributeCollection GetAttributes (Type componentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.AttributeCollection GetAttributes(class System.Type componentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetAttributes(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAttributes (componentType As Type) As AttributeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::AttributeCollection ^ GetAttributes(Type ^ componentType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AttributeCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="componentType">目標元件的 <see cref="T:System.Type" />。</param>
        <summary>傳回指定元件類型的屬性集合。</summary>
        <returns>具有元件型別屬性的 <see cref="T:System.ComponentModel.AttributeCollection" />。 如果元件是 <see langword="null" />，這個方法會傳回空的集合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您不需要物件的執行個體時，才呼叫這個方法的這個版本。  
  
 有屬性<xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType>設`true`，屬性集合中移除重複的執行個體。 這些是在其中執行個體<xref:System.Attribute.TypeId%2A?displayProperty=nameWithType>屬性會傳回相同的值。  
  
 當您定義自訂屬性與<xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType>設`true`，您必須覆寫<xref:System.Attribute.TypeId%2A?displayProperty=nameWithType>讓其成為唯一的屬性。 如果您的屬性的所有執行個體是唯一的覆寫<xref:System.Attribute.TypeId%2A?displayProperty=nameWithType>來傳回屬性的物件識別。 如果只有某些屬性的執行個體是唯一的傳回值，以從<xref:System.Attribute.TypeId%2A?displayProperty=nameWithType>，可在這些情況下傳回是否相等。 例如，某些屬性具有建構函式參數，可做為唯一索引鍵。 對於這些屬性會傳回從建構函式參數的值<xref:System.Attribute.TypeId%2A?displayProperty=nameWithType>屬性。  
  
> [!NOTE]
>  預設實作<xref:System.Attribute.TypeId%2A?displayProperty=nameWithType>傳回型別身分識別的值為何<xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType>屬性。 為了傳回多個執行個體<xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType>屬性從<xref:System.ComponentModel.AttributeCollection>，您的屬性必須覆寫<xref:System.Attribute.TypeId%2A?displayProperty=nameWithType>屬性。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Attribute" />
        <altmember cref="T:System.ComponentModel.AttributeCollection" />
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.AddAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributes">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.AttributeCollection GetAttributes (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.AttributeCollection GetAttributes(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetAttributes(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAttributes (component As Object, noCustomTypeDesc As Boolean) As AttributeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::AttributeCollection ^ GetAttributes(System::Object ^ component, bool noCustomTypeDesc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AttributeCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">您要取得屬性的元件。</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> 表示如果 <c>component</c> 屬於型別 <see cref="T:System.ComponentModel.ICustomTypeDescriptor" />，則使用自訂類型描述元的一組基準屬性，否則為 <see langword="false" />。</param>
        <summary>傳回指定元件的屬性集合，以及表示是否已建立自訂類型描述元的布林值。</summary>
        <returns>具有元件屬性的 <see cref="T:System.ComponentModel.AttributeCollection" />。 如果元件是 <see langword="null" />，這個方法會傳回空的集合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 所傳回的屬性<xref:System.ComponentModel.TypeDescriptor.GetAttributes%2A>方法可能會動態修改原始來源元件的擴充性提供者清單 (<xref:System.ComponentModel.IExtenderProvider>)，篩選服務 (<xref:System.ComponentModel.Design.ITypeDescriptorFilterService>)，和屬性篩選。  
  
 當您定義自訂屬性與<xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType>設`true`，您必須覆寫<xref:System.Attribute.TypeId%2A?displayProperty=nameWithType>讓其成為唯一的屬性。 如果您的屬性的所有執行個體是唯一的覆寫<xref:System.Attribute.TypeId%2A?displayProperty=nameWithType>來傳回屬性的物件識別。 如果只有某些屬性的執行個體是唯一的傳回值，以從<xref:System.Attribute.TypeId%2A?displayProperty=nameWithType>，可在這些情況下傳回是否相等。 例如，某些屬性具有建構函式參數，可做為唯一索引鍵。 對於這些屬性會傳回從建構函式參數的值<xref:System.Attribute.TypeId%2A?displayProperty=nameWithType>屬性。  
  
> [!NOTE]
>  預設實作<xref:System.Attribute.TypeId%2A?displayProperty=nameWithType>傳回型別身分識別的值為何<xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType>屬性。 為了傳回多個執行個體<xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType>屬性從<xref:System.ComponentModel.AttributeCollection>，您的屬性必須覆寫<xref:System.Attribute.TypeId%2A?displayProperty=nameWithType>屬性。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Attribute" />
        <altmember cref="T:System.ComponentModel.AttributeCollection" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.AddAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetClassName">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回指定元件之類別的名稱。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetClassName">
      <MemberSignature Language="C#" Value="public static string GetClassName (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetClassName(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetClassName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetClassName (component As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetClassName(System::Object ^ component);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">需要其類別名稱的 <see cref="T:System.Object" />。</param>
        <summary>傳回使用預設類型描述元之指定元件的類別名稱。</summary>
        <returns>
          <see cref="T:System.String" />，包含指定元件的類別名稱。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一般而言，這個方法會傳回完整<xref:System.Type>名稱`component`參數類型。 例如，按鈕的類別名稱是"System.Windows.Forms.Button"。 如果`component`實作<xref:System.ComponentModel.ICustomTypeDescriptor>，它可以傳回的替代名稱。  
  
 這個方法相當於多載<xref:System.ComponentModel.TypeDescriptor.GetClassName%28System.Object%2CSystem.Boolean%29>具有第二個參數的方法`false`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetClassName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetComponentName" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetFullComponentName(System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
      </Docs>
    </Member>
    <Member MemberName="GetClassName">
      <MemberSignature Language="C#" Value="public static string GetClassName (Type componentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetClassName(class System.Type componentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetClassName(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetClassName (componentType As Type) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetClassName(Type ^ componentType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="componentType">目標元件的 <see cref="T:System.Type" />。</param>
        <summary>傳回指定類型之類別的名稱。</summary>
        <returns>
          <see cref="T:System.String" />，包含指定元件型別的類別名稱。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會使用快取的自訂類型描述元指定之類型探索相關聯的類別名稱。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="componentType" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetClassName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetComponentName" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetFullComponentName(System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
      </Docs>
    </Member>
    <Member MemberName="GetClassName">
      <MemberSignature Language="C#" Value="public static string GetClassName (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetClassName(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetClassName(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetClassName (component As Object, noCustomTypeDesc As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetClassName(System::Object ^ component, bool noCustomTypeDesc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">需要其類別名稱的 <see cref="T:System.Object" />。</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> 表示考慮自訂型別描述資訊，否則為 <see langword="false" />。</param>
        <summary>傳回使用自訂類型描述元之指定元件的類別名稱。</summary>
        <returns>
          <see cref="T:System.String" />，包含指定元件的類別名稱。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一般而言，這個方法會傳回完整<xref:System.Type>名稱`component`參數類型。 例如，按鈕的類別名稱是"System.Windows.Forms.Button"。 如果`component`參數實作<xref:System.ComponentModel.ICustomTypeDescriptor>，它可以傳回的替代名稱。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> 是跨處理序的遠端物件。</exception>
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetClassName" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetComponentName" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetFullComponentName(System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetComponentName">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回指定元件的名稱。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetComponentName">
      <MemberSignature Language="C#" Value="public static string GetComponentName (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetComponentName(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetComponentName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComponentName (component As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetComponentName(System::Object ^ component);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">需要其類別名稱的 <see cref="T:System.Object" />。</param>
        <summary>使用預設類型描述元傳回指定元件的名稱。</summary>
        <returns>
          <see cref="T:System.String" />，包含指定元件的名稱，或 <see langword="null" /> (如果沒有元件名稱)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一般而言，這個方法傳回的元件，網站的名稱，如果有的話。 例如，按鈕的類別名稱是"System.Windows.Forms.Button"。  
  
 這個方法相當於多載<xref:System.ComponentModel.TypeDescriptor.GetComponentName%28System.Object%2CSystem.Boolean%29>具有第二個參數的方法`false`。  
  
 這個方法在執行階段用於擷取元件的執行個體的名稱。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> 是跨處理序的遠端物件。</exception>
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetComponentName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetClassName" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetFullComponentName(System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
      </Docs>
    </Member>
    <Member MemberName="GetComponentName">
      <MemberSignature Language="C#" Value="public static string GetComponentName (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetComponentName(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetComponentName(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComponentName (component As Object, noCustomTypeDesc As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetComponentName(System::Object ^ component, bool noCustomTypeDesc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">需要其類別名稱的 <see cref="T:System.Object" />。</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> 表示考慮自訂型別描述資訊，否則為 <see langword="false" />。</param>
        <summary>使用自訂類型描述元傳回指定元件的名稱。</summary>
        <returns>指定元件的類別名稱，或 <see langword="null" /> (如果沒有元件名稱)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法在執行階段用於擷取元件的執行個體的名稱。 一般而言，這個方法傳回的元件，網站的名稱，如果有的話。 例如，按鈕的類別名稱是"System.Windows.Forms.Button"。 如果元件實作<xref:System.ComponentModel.ICustomTypeDescriptor>介面，它可以傳回的替代名稱。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> 是跨處理序的遠端物件。</exception>
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetComponentName" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetClassName" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetFullComponentName(System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConverter">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回元件或類型的類型轉換子。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConverter">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.TypeConverter GetConverter (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.TypeConverter GetConverter(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetConverter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetConverter (component As Object) As TypeConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::TypeConverter ^ GetConverter(System::Object ^ component);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeConverter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">要為其取得轉換子的元件。</param>
        <summary>傳回指定元件類型的類型轉換子。</summary>
        <returns>指定元件的 <see cref="T:System.ComponentModel.TypeConverter" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法依尋找找出適當的型別轉換器<xref:System.ComponentModel.TypeConverterAttribute>。 如果找不到<xref:System.ComponentModel.TypeConverterAttribute>，直到找到基本型別周遊類別的基底類別階層架構。  
  
 這個方法相當於多載<xref:System.ComponentModel.TypeDescriptor.GetConverter%2A>具有第二個參數的方法`false`。  
  
   
  
## Examples  
 如需使用這個方法的範例，請參閱<xref:System.ComponentModel.TypeConverter>類別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> 是跨處理序的遠端物件。</exception>
        <altmember cref="T:System.ComponentModel.TypeConverterAttribute" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEditor" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateDesigner(System.ComponentModel.IComponent,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetConverter">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.TypeConverter GetConverter (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.TypeConverter GetConverter(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetConverter(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::TypeConverter ^ GetConverter(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeConverter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">目標元件的 <see cref="T:System.Type" />。</param>
        <summary>傳回指定類型的類型轉換子。</summary>
        <returns>指定類型的 <see cref="T:System.ComponentModel.TypeConverter" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您不需要物件的執行個體時，才呼叫這個方法的這個版本。  
  
 這個方法會藉由尋找適當的類型轉換器的<xref:System.ComponentModel.TypeConverterAttribute>。 如果找不到<xref:System.ComponentModel.TypeConverterAttribute>，直到找到基本型別周遊類別的基底類別階層架構。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.ComponentModel.TypeConverterAttribute" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEditor" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateDesigner(System.ComponentModel.IComponent,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetConverter">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.TypeConverter GetConverter (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.TypeConverter GetConverter(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetConverter(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetConverter (component As Object, noCustomTypeDesc As Boolean) As TypeConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::TypeConverter ^ GetConverter(System::Object ^ component, bool noCustomTypeDesc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeConverter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">要為其取得轉換子的元件。</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> 表示考慮自訂型別描述資訊，否則為 <see langword="false" />。</param>
        <summary>傳回指定元件類型的類型轉換子，並提供自訂類型描述元。</summary>
        <returns>指定元件的 <see cref="T:System.ComponentModel.TypeConverter" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會嘗試尋找適當的類型轉換器的<xref:System.ComponentModel.TypeConverterAttribute>。 如果找不到<xref:System.ComponentModel.TypeConverterAttribute>，直到找到基本型別周遊類別的基底類別階層架構。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> 是跨處理序的遠端物件。</exception>
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="T:System.ComponentModel.TypeConverterAttribute" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEditor" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateDesigner(System.ComponentModel.IComponent,System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDefaultEvent">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回元件或類型的預設事件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDefaultEvent">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptor GetDefaultEvent (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptor GetDefaultEvent(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetDefaultEvent(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDefaultEvent (component As Object) As EventDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptor ^ GetDefaultEvent(System::Object ^ component);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">要取得事件的元件。</param>
        <summary>傳回指定元件的預設事件。</summary>
        <returns>具有預設事件的 <see cref="T:System.ComponentModel.EventDescriptor" />，或者如果沒有事件，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法相當於多載<xref:System.ComponentModel.TypeDescriptor.GetDefaultEvent%28System.Object%2CSystem.Boolean%29>具有第二個參數的方法`false`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> 是跨處理序的遠端物件。</exception>
        <altmember cref="T:System.ComponentModel.DefaultEventAttribute" />
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultEvent">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptor GetDefaultEvent (Type componentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptor GetDefaultEvent(class System.Type componentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetDefaultEvent(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDefaultEvent (componentType As Type) As EventDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptor ^ GetDefaultEvent(Type ^ componentType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="componentType">目標元件的 <see cref="T:System.Type" />。</param>
        <summary>傳回指定元件類型的預設事件。</summary>
        <returns>具有預設事件的 <see cref="T:System.ComponentModel.EventDescriptor" />，或者如果沒有事件，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您不需要物件的執行個體時，才呼叫這個方法的這個版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="componentType" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.ComponentModel.DefaultEventAttribute" />
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultEvent">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptor GetDefaultEvent (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptor GetDefaultEvent(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetDefaultEvent(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDefaultEvent (component As Object, noCustomTypeDesc As Boolean) As EventDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptor ^ GetDefaultEvent(System::Object ^ component, bool noCustomTypeDesc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">要取得事件的元件。</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> 表示考慮自訂型別描述資訊，否則為 <see langword="false" />。</param>
        <summary>傳回具有自訂類型描述元之元件的預設事件。</summary>
        <returns>具有預設事件的 <see cref="T:System.ComponentModel.EventDescriptor" />，或者如果沒有事件，則為 <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> 是跨處理序的遠端物件。</exception>
        <altmember cref="T:System.ComponentModel.DefaultEventAttribute" />
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDefaultProperty">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回元件的預設屬性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDefaultProperty">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptor GetDefaultProperty (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptor GetDefaultProperty(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetDefaultProperty(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDefaultProperty (component As Object) As PropertyDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptor ^ GetDefaultProperty(System::Object ^ component);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">要取得預設屬性的元件。</param>
        <summary>傳回指定元件的預設屬性。</summary>
        <returns>具有預設屬性的 <see cref="T:System.ComponentModel.PropertyDescriptor" />，或者如果沒有屬性，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`component`參數是`null`，這個方法會傳回`null`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> 是跨處理序的遠端物件。</exception>
        <altmember cref="T:System.ComponentModel.DefaultPropertyAttribute" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultProperty">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptor GetDefaultProperty (Type componentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptor GetDefaultProperty(class System.Type componentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetDefaultProperty(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDefaultProperty (componentType As Type) As PropertyDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptor ^ GetDefaultProperty(Type ^ componentType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="componentType">
          <see cref="T:System.Type" />，表示要為其取得屬性的類別。</param>
        <summary>傳回指定元件類型的預設屬性。</summary>
        <returns>具有預設屬性的 <see cref="T:System.ComponentModel.PropertyDescriptor" />，或者如果沒有屬性，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您不需要物件的執行個體時，才呼叫這個方法的這個版本。  
  
 如果`componentType`參數是`null`，這個方法會傳回`null`。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.DefaultPropertyAttribute" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultProperty">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptor GetDefaultProperty (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptor GetDefaultProperty(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetDefaultProperty(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDefaultProperty (component As Object, noCustomTypeDesc As Boolean) As PropertyDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptor ^ GetDefaultProperty(System::Object ^ component, bool noCustomTypeDesc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">要取得預設屬性的元件。</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> 表示考慮自訂型別描述資訊，否則為 <see langword="false" />。</param>
        <summary>傳回具有自訂類型描述元之指定元件的預設屬性。</summary>
        <returns>具有預設屬性的 <see cref="T:System.ComponentModel.PropertyDescriptor" />，或者如果沒有屬性，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`component`參數是`null`，這個方法會傳回`null`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> 是跨處理序的遠端物件。</exception>
        <altmember cref="T:System.ComponentModel.DefaultPropertyAttribute" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEditor">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回具有指定基底型別的編輯器。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEditor">
      <MemberSignature Language="C#" Value="public static object GetEditor (object component, Type editorBaseType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetEditor(object component, class System.Type editorBaseType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEditor(System.Object,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEditor (component As Object, editorBaseType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetEditor(System::Object ^ component, Type ^ editorBaseType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="editorBaseType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="component">要為其取得編輯器的元件。</param>
        <param name="editorBaseType">
          <see cref="T:System.Type" />，表示您要尋找的編輯器的基底型別。</param>
        <summary>取得具有指定元件之指定基底類型的編輯器。</summary>
        <returns>編輯器的執行個體，可以轉型為指定的編輯器型別，如果找不到要求型別的編輯器，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型別`editorBaseType`通常是<xref:System.Drawing.Design.UITypeEditor>，但您也可以使用其他類型 (例如，<xref:System.ComponentModel.ComponentEditor>和<xref:System.ComponentModel.InstanceCreationEditor>)。  
  
 您可以定義多個屬性編輯器。 您可以使用這個方法來選取您想要使用的編輯器。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> 或 <paramref name="editorBaseType" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> 是跨處理序的遠端物件。</exception>
        <altmember cref="M:System.ComponentModel.TypeDescriptor.AddEditorTable(System.Type,System.Collections.Hashtable)" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetConverter" />
      </Docs>
    </Member>
    <Member MemberName="GetEditor">
      <MemberSignature Language="C#" Value="public static object GetEditor (Type type, Type editorBaseType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetEditor(class System.Type type, class System.Type editorBaseType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEditor(System.Type,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetEditor(Type ^ type, Type ^ editorBaseType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="editorBaseType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">目標元件的 <see cref="T:System.Type" />。</param>
        <param name="editorBaseType">
          <see cref="T:System.Type" />，表示您試著要尋找的編輯器的基底型別。</param>
        <summary>傳回具有指定類型之指定基底類型的編輯器。</summary>
        <returns>編輯器物件的執行個體，可以轉型為指定的基底型別，如果找不到要求型別的編輯器，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型別`editorBaseType`通常是<xref:System.Drawing.Design.UITypeEditor>，但您也可以使用其他類型 (例如<xref:System.ComponentModel.ComponentEditor>和<xref:System.ComponentModel.InstanceCreationEditor>)。  
  
 您可以定義多個型別的編輯器。 您可以使用這個方法來選取您想要使用的一個。  
  
 您不需要物件的執行個體時，才呼叫這個方法的這個版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> 或 <paramref name="editorBaseType" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.ComponentModel.TypeDescriptor.AddEditorTable(System.Type,System.Collections.Hashtable)" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetConverter" />
      </Docs>
    </Member>
    <Member MemberName="GetEditor">
      <MemberSignature Language="C#" Value="public static object GetEditor (object component, Type editorBaseType, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetEditor(object component, class System.Type editorBaseType, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEditor(System.Object,System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEditor (component As Object, editorBaseType As Type, noCustomTypeDesc As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetEditor(System::Object ^ component, Type ^ editorBaseType, bool noCustomTypeDesc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="editorBaseType" Type="System.Type" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">要為其取得編輯器的元件。</param>
        <param name="editorBaseType">
          <see cref="T:System.Type" />，表示您要尋找的編輯器的基底型別。</param>
        <param name="noCustomTypeDesc">表示是否應該考慮自訂類型描述資訊的旗標。</param>
        <summary>傳回具有指定基底類型與指定元件之自訂類型描述元的編輯器。</summary>
        <returns>編輯器的執行個體，可以轉型為指定的編輯器型別，如果找不到要求型別的編輯器，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型別`editorBaseType`通常是<xref:System.Drawing.Design.UITypeEditor>，但您也可以使用其他類型 (例如<xref:System.ComponentModel.ComponentEditor>和<xref:System.ComponentModel.InstanceCreationEditor>)。  
  
 您可以定義多個屬性編輯器。 您可以使用這個方法來選取您想要使用的編輯器。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> 或 <paramref name="editorBaseType" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> 是跨處理序的遠端物件。</exception>
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.AddEditorTable(System.Type,System.Collections.Hashtable)" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetConverter" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回元件或類型之事件的集合。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptorCollection GetEvents (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptorCollection GetEvents(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEvents(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEvents (component As Object) As EventDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptorCollection ^ GetEvents(System::Object ^ component);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">要取得事件的元件。</param>
        <summary>傳回指定元件的事件集合。</summary>
        <returns>具有這個元件事件的 <see cref="T:System.ComponentModel.EventDescriptorCollection" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 擷取的事件集合的指定`component`參數執行個體會提供。 此集合可以與不同類別提供的事件集。 如果`component`設置參數、 站台可以新增或移除額外的事件。  
  
 如果`component`是`null`，則會傳回空集合。  
  
 所傳回之集合的順序不保證是相同的呼叫之間，所以一定訂購，才能使用。  
  
   
  
## Examples  
 如需這個方法的範例，請參閱<xref:System.ComponentModel.EventDescriptorCollection.Count%2A>屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> 是跨處理序的遠端物件。</exception>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptorCollection" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptorCollection GetEvents (Type componentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptorCollection GetEvents(class System.Type componentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEvents(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEvents (componentType As Type) As EventDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptorCollection ^ GetEvents(Type ^ componentType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="componentType">目標元件的 <see cref="T:System.Type" />。</param>
        <summary>傳回指定元件類型的事件集合。</summary>
        <returns>具有這個元件事件的 <see cref="T:System.ComponentModel.EventDescriptorCollection" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您不需要物件的執行個體時，才呼叫這個方法的這個版本。  
  
 如果`componentType`參數是`null`，就會傳回空集合。  
  
 所傳回之集合的順序不保證是相同的呼叫之間，所以一定訂購，才能使用。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptorCollection" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptorCollection GetEvents (object component, Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptorCollection GetEvents(object component, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEvents(System.Object,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEvents (component As Object, attributes As Attribute()) As EventDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptorCollection ^ GetEvents(System::Object ^ component, cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="attributes" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="component">要取得事件的元件。</param>
        <param name="attributes">
          <see cref="T:System.Attribute" /> 型別的陣列，可用來當做篩選條件。</param>
        <summary>使用指定的屬性陣列做為篩選條件，傳回指定元件的事件集合。</summary>
        <returns>
          <see cref="T:System.ComponentModel.EventDescriptorCollection" />，具有與這個元件的指定屬性相符的事件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 針對事件`component`參數可能會與不同的事件類別，因為站台可以新增或移除事件，如果`component`設置參數。  
  
 `attributes`陣列可以具有多種<xref:System.Type>和<xref:System.Attribute>物件。 篩選是由下列規則定義：  
  
-   A<xref:System.Type>會被視為萬用字元使用，它會比對有任何事件<xref:System.Type>集中的屬性。  
  
-   如果事件沒有<xref:System.Attribute>相同類別的事件不包含傳回陣列中。  
  
-   如果屬性的執行個體<xref:System.Attribute>類別事件必須為完全相符，或它不會包含傳回陣列中。  
  
-   如果<xref:System.Attribute>指定執行個體，這是預設事件，即使沒有任何執行個體，它包含傳回陣列中<xref:System.Attribute>事件中。  
  
 如果`component`是`null`，就會傳回空集合。  
  
 所傳回之集合的順序不保證是相同的呼叫之間，所以一定訂購，才能使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> 是跨處理序的遠端物件。</exception>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptorCollection" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptorCollection GetEvents (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptorCollection GetEvents(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEvents(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEvents (component As Object, noCustomTypeDesc As Boolean) As EventDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptorCollection ^ GetEvents(System::Object ^ component, bool noCustomTypeDesc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">要取得事件的元件。</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> 表示考慮自訂型別描述資訊，否則為 <see langword="false" />。</param>
        <summary>傳回具有自訂類型描述元之指定元件的事件集合。</summary>
        <returns>具有這個元件事件的 <see cref="T:System.ComponentModel.EventDescriptorCollection" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會擷取事件的集合，指定`component`參數執行個體會提供。 這可能不同於類別提供的事件集。 如果`component`設置參數、 站台可以新增或移除額外的事件。  
  
 如果`component`是`null`，就會傳回空集合。  
  
 所傳回之集合的順序不保證是相同的呼叫之間，所以一定訂購，才能使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> 是跨處理序的遠端物件。</exception>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptorCollection" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptorCollection GetEvents (Type componentType, Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptorCollection GetEvents(class System.Type componentType, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEvents(System.Type,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEvents (componentType As Type, attributes As Attribute()) As EventDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptorCollection ^ GetEvents(Type ^ componentType, cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="componentType">目標元件的 <see cref="T:System.Type" />。</param>
        <param name="attributes">
          <see cref="T:System.Attribute" /> 型別的陣列，可用來當做篩選條件。</param>
        <summary>使用指定的屬性陣列做為篩選條件，傳回指定元件類型的事件集合。</summary>
        <returns>
          <see cref="T:System.ComponentModel.EventDescriptorCollection" />，具有與這個元件的指定屬性相符的事件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您不需要物件的執行個體時，才呼叫這個方法的這個版本。  
  
 `attributes`參數陣列可以具有多種<xref:System.Type>和<xref:System.Attribute>物件。 篩選是由下列規則定義：  
  
-   A<xref:System.Type>會被視為萬用字元使用，它會比對有任何事件<xref:System.Type>集中的屬性。  
  
-   如果事件沒有<xref:System.Attribute>相同類別的事件不包含傳回陣列中。  
  
-   如果屬性的執行個體<xref:System.Attribute>類別事件必須為完全相符，或它不會包含傳回陣列中。  
  
-   如果<xref:System.Attribute>指定執行個體，這是預設事件，即使沒有任何執行個體，它包含傳回陣列中<xref:System.Attribute>事件中。  
  
 如果`componentType`參數是`null`，就會傳回空集合。  
  
 所傳回之集合的順序不保證是相同的呼叫之間，所以一定訂購，才能使用。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptorCollection" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptorCollection GetEvents (object component, Attribute[] attributes, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptorCollection GetEvents(object component, class System.Attribute[] attributes, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEvents(System.Object,System.Attribute[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEvents (component As Object, attributes As Attribute(), noCustomTypeDesc As Boolean) As EventDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptorCollection ^ GetEvents(System::Object ^ component, cli::array &lt;Attribute ^&gt; ^ attributes, bool noCustomTypeDesc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="attributes" Type="System.Attribute[]" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">要取得事件的元件。</param>
        <param name="attributes">
          <see cref="T:System.Attribute" /> 型別的陣列，可用來當做篩選條件。</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> 表示考慮自訂型別描述資訊，否則為 <see langword="false" />。</param>
        <summary>使用指定的屬性陣列做為篩選條件並使用自訂類型描述元，傳回指定元件的事件集合。</summary>
        <returns>
          <see cref="T:System.ComponentModel.EventDescriptorCollection" />，具有與這個元件的指定屬性相符的事件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 針對事件`component`參數可能會與不同的事件類別，因為站台可以新增或移除事件，如果`component`設置參數。  
  
 `attributes`參數陣列可以具有多種<xref:System.Type>和<xref:System.Attribute>物件。 篩選是由下列規則定義：  
  
-   A<xref:System.Type>會被視為萬用字元使用，它會比對有任何事件<xref:System.Type>集中的屬性。  
  
-   如果事件沒有<xref:System.Attribute>相同類別的事件不包含傳回陣列中。  
  
-   如果屬性的執行個體<xref:System.Attribute>類別事件必須為完全相符，或它不會包含傳回陣列中。  
  
-   如果<xref:System.Attribute>指定執行個體，這是預設事件，即使沒有任何執行個體，它包含傳回陣列中<xref:System.Attribute>事件中。  
  
 如果`component`是`null`，就會傳回空集合。  
  
 所傳回之集合的順序不保證是相同的呼叫之間，所以一定訂購，才能使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> 是跨處理序的遠端物件。</exception>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptorCollection" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <Member MemberName="GetFullComponentName">
      <MemberSignature Language="C#" Value="public static string GetFullComponentName (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullComponentName(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetFullComponentName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullComponentName (component As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullComponentName(System::Object ^ component);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">要尋找名稱的 <see cref="T:System.ComponentModel.Component" />。</param>
        <summary>傳回元件的完整名稱。</summary>
        <returns>指定元件的完整名稱，或 <see langword="null" /> (如果元件沒有名稱)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在許多情況下，<xref:System.ComponentModel.TypeDescriptor.GetFullComponentName%2A>方法會傳回相同的值<xref:System.ComponentModel.TypeDescriptor.GetComponentName%2A>方法。 不過，如果元件位於巢狀容器，或有其他巢狀的語意，它可能會傳回不同的完整的名稱。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.ComponentModel.TypeDescriptionProvider.GetFullComponentName(System.Object)" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetComponentName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetClassName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperties">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回元件或類型之屬性的集合。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptorCollection GetProperties (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptorCollection GetProperties(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProperties(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProperties (component As Object) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptorCollection ^ GetProperties(System::Object ^ component);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">要為其取得屬性的元件。</param>
        <summary>傳回指定元件的屬性集合。</summary>
        <returns>具有指定元件屬性的 <see cref="T:System.ComponentModel.PropertyDescriptorCollection" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 元件的屬性可以與不同類別的屬性，因為站台可以新增或移除屬性，如果元件決定位置。  
  
 如果`component`參數是`null`，就會傳回空集合。  
  
 所傳回之集合的順序不保證是相同的呼叫之間，所以一定訂購，才能使用。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.ComponentModel.TypeDescriptor.GetProperties%2A>方法來存取控制項的屬性。 這個程式碼範例是針對所提供之較大範例的一部分<xref:System.ComponentModel.Design.ComponentDesigner>類別。  
  
 [!code-csharp[System.ComponentModel.Design.DesignerServices#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.Design.DesignerServices/CS/Form1.cs#8)]
 [!code-vb[System.ComponentModel.Design.DesignerServices#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.Design.DesignerServices/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> 是跨處理序的遠端物件。</exception>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptorCollection GetProperties (Type componentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptorCollection GetProperties(class System.Type componentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProperties(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProperties (componentType As Type) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptorCollection ^ GetProperties(Type ^ componentType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="componentType">
          <see cref="T:System.Type" />，表示要為其取得屬性的元件。</param>
        <summary>傳回元件指定類型的屬性集合。</summary>
        <returns>
          <see cref="T:System.ComponentModel.PropertyDescriptorCollection" />，具有元件指定型別的屬性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您不需要物件的執行個體時，才呼叫這個方法的這個版本。  
  
 如果`componentType`參數是`null`，就會傳回空集合。  
  
 所傳回之集合的順序不保證是相同的呼叫之間，所以一定訂購，才能使用。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptorCollection GetProperties (object component, Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptorCollection GetProperties(object component, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProperties(System.Object,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProperties (component As Object, attributes As Attribute()) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptorCollection ^ GetProperties(System::Object ^ component, cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="attributes" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="component">要為其取得屬性的元件。</param>
        <param name="attributes">
          <see cref="T:System.Attribute" /> 型別的陣列，可用來當做篩選條件。</param>
        <summary>使用指定的屬性陣列做為篩選條件，傳回指定元件的屬性集合。</summary>
        <returns>
          <see cref="T:System.ComponentModel.PropertyDescriptorCollection" />，具有與指定元件的指定屬性 (Attribute) 相符的屬性 (Property)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 屬性`component`參數可能會與不同類別的屬性，因為站台可以新增或移除屬性，如果`component`設置參數。  
  
 `attributes`參數陣列用來篩選陣列。 篩選是由下列規則定義：  
  
-   如果屬性沒有<xref:System.Attribute>相同類別的屬性不包含傳回陣列中。  
  
-   如果屬性的執行個體<xref:System.Attribute>類別的屬性必須是完全相符，或它不會包含傳回陣列中。  
  
-   如果<xref:System.Attribute>指定執行個體和它的預設屬性，即使沒有任何執行個體，它包含傳回陣列中<xref:System.Attribute>屬性中。  
  
-   如果`attributes`具有預設屬性，<xref:System.ComponentModel.TypeDescriptor.GetProperties%2A>方法符合大小寫，此屬性沒有套用屬性時。  
  
 如果`component`是`null`，就會傳回空集合。  
  
 所傳回之集合的順序不保證是相同的呼叫之間，所以一定訂購，才能使用。  
  
   
  
## Examples  
 下列程式碼範例示範如何實作<xref:System.Windows.Forms.Design.PropertyTab.GetProperties%2A>方法。 這個程式碼範例是針對所提供之較大範例的一部分<xref:System.Windows.Forms.Design.PropertyTab>類別。  
  
 [!code-cpp[PropertyTabExample#2](~/samples/snippets/cpp/VS_Snippets_Winforms/PropertyTabExample/CPP/class1.cpp#2)]
 [!code-csharp[PropertyTabExample#2](~/samples/snippets/csharp/VS_Snippets_Winforms/PropertyTabExample/CS/class1.cs#2)]
 [!code-vb[PropertyTabExample#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/PropertyTabExample/VB/class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> 是跨處理序的遠端物件。</exception>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptorCollection GetProperties (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptorCollection GetProperties(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProperties(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProperties (component As Object, noCustomTypeDesc As Boolean) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptorCollection ^ GetProperties(System::Object ^ component, bool noCustomTypeDesc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">要為其取得屬性的元件。</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> 表示不要考慮自訂型別描述資訊，否則為 <see langword="false" />。</param>
        <summary>傳回使用預設類型描述元之指定元件的屬性集合。</summary>
        <returns>具有指定元件屬性的 <see cref="T:System.ComponentModel.PropertyDescriptorCollection" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 屬性`component`參數可能會與不同類別的屬性，因為站台可以新增或移除屬性，如果`component`設置參數。  
  
 如果`component`是`null`，就會傳回空集合。  
  
 所傳回之集合的順序不保證是相同的呼叫之間，所以一定訂購，才能使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> 是跨處理序的遠端物件。</exception>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptorCollection GetProperties (Type componentType, Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptorCollection GetProperties(class System.Type componentType, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProperties(System.Type,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProperties (componentType As Type, attributes As Attribute()) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptorCollection ^ GetProperties(Type ^ componentType, cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="componentType">目標元件的 <see cref="T:System.Type" />。</param>
        <param name="attributes">
          <see cref="T:System.Attribute" /> 型別的陣列，可用來當做篩選條件。</param>
        <summary>使用指定的屬性陣列做為篩選條件，傳回元件指定類型的屬性集合。</summary>
        <returns>
          <see cref="T:System.ComponentModel.PropertyDescriptorCollection" />，具有與元件這個型別的指定屬性 (Attribute) 相符的屬性 (Property)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您不需要物件的執行個體時，才呼叫這個方法的這個版本。  
  
 `attributes`參數陣列用來篩選陣列。 篩選是由下列規則定義：  
  
-   如果屬性沒有<xref:System.Attribute>相同類別的屬性不包含傳回陣列中。  
  
-   如果屬性的執行個體<xref:System.Attribute>類別的屬性必須是完全相符，或它不會包含傳回陣列中。  
  
-   如果<xref:System.Attribute>指定執行個體和它的預設屬性，即使沒有任何執行個體，它包含傳回陣列中<xref:System.Attribute>屬性中。  
  
-   如果`attributes`具有預設屬性，<xref:System.ComponentModel.TypeDescriptor.GetProperties%2A>方法符合大小寫，此屬性沒有套用屬性時。  
  
 如果`componentType`參數是`null`，就會傳回空集合。  
  
 所傳回之集合的順序不保證是相同的呼叫之間，所以一定訂購，才能使用。  
  
   
  
## Examples  
 下列程式碼範例示範如何實作<xref:System.Windows.Forms.Design.PropertyTab.GetProperties%2A>方法。 這個程式碼範例是針對所提供之較大範例的一部分<xref:System.Windows.Forms.Design.PropertyTab>類別。  
  
 [!code-cpp[PropertyTabExample#2](~/samples/snippets/cpp/VS_Snippets_Winforms/PropertyTabExample/CPP/class1.cpp#2)]
 [!code-csharp[PropertyTabExample#2](~/samples/snippets/csharp/VS_Snippets_Winforms/PropertyTabExample/CS/class1.cs#2)]
 [!code-vb[PropertyTabExample#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/PropertyTabExample/VB/class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptorCollection GetProperties (object component, Attribute[] attributes, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptorCollection GetProperties(object component, class System.Attribute[] attributes, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProperties(System.Object,System.Attribute[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProperties (component As Object, attributes As Attribute(), noCustomTypeDesc As Boolean) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptorCollection ^ GetProperties(System::Object ^ component, cli::array &lt;Attribute ^&gt; ^ attributes, bool noCustomTypeDesc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="attributes" Type="System.Attribute[]" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">要為其取得屬性的元件。</param>
        <param name="attributes">
          <see cref="T:System.Attribute" /> 型別的陣列，可用來當做篩選條件。</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> 表示考慮自訂型別描述資訊，否則為 <see langword="false" />。</param>
        <summary>使用指定的屬性陣列做為篩選條件並使用自訂類型描述元，傳回指定元件的屬性集合。</summary>
        <returns>
          <see cref="T:System.ComponentModel.PropertyDescriptorCollection" />，具有與指定元件的指定屬性相符的事件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 屬性`component`可以與不同類別的屬性，因為站台可以新增或移除屬性，如果`component`設置。  
  
 `attributes`參數陣列用來篩選陣列。 篩選是由下列規則定義：  
  
-   如果屬性沒有<xref:System.Attribute>相同類別的屬性不包含傳回陣列中。  
  
-   如果屬性的執行個體<xref:System.Attribute>類別的屬性必須是完全相符，或它不會包含傳回陣列中。  
  
-   如果<xref:System.Attribute>指定執行個體和它的預設屬性，即使沒有任何執行個體，它包含傳回陣列中<xref:System.Attribute>屬性中。  
  
-   如果`attributes`具有預設屬性，<xref:System.ComponentModel.TypeDescriptor.GetProperties%2A>方法符合大小寫，此屬性沒有套用屬性時。  
  
 如果`component`參數是`null`，就會傳回空集合。  
  
 所傳回之集合的順序不保證是相同的呼叫之間，所以一定訂購，才能使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> 是跨處理序的遠端物件。</exception>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProvider">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回元件或類型的類型描述提供者。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProvider">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.TypeDescriptionProvider GetProvider (object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.TypeDescriptionProvider GetProvider(object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProvider(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProvider (instance As Object) As TypeDescriptionProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::TypeDescriptionProvider ^ GetProvider(System::Object ^ instance);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeDescriptionProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instance">目標元件的執行個體。</param>
        <summary>傳回指定元件的類型描述提供者。</summary>
        <returns>與指定元件相關的 <see cref="T:System.ComponentModel.TypeDescriptionProvider" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.TypeDescriptor.GetProvider%2A>方法一律會傳回的類型描述提供者。 即使預設<xref:System.ComponentModel.TypeDescriptor>實作根據<xref:System.ComponentModel.TypeDescriptionProvider>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.ComponentModel.TypeDescriptionProvider" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.RemoveProvider" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEditor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetConverter" />
      </Docs>
    </Member>
    <Member MemberName="GetProvider">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.TypeDescriptionProvider GetProvider (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.TypeDescriptionProvider GetProvider(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProvider(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::TypeDescriptionProvider ^ GetProvider(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeDescriptionProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">目標元件的 <see cref="T:System.Type" />。</param>
        <summary>傳回指定類型的類型描述提供者。</summary>
        <returns>與指定型別相關的 <see cref="T:System.ComponentModel.TypeDescriptionProvider" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.TypeDescriptor.GetProvider%2A>方法一律會傳回的類型描述提供者。 即使預設<xref:System.ComponentModel.TypeDescriptor>實作根據<xref:System.ComponentModel.TypeDescriptionProvider>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.ComponentModel.TypeDescriptionProvider" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.RemoveProvider" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEditor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetConverter" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetReflectionType">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回可用來執行反映的 <see cref="T:System.Type" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetReflectionType">
      <MemberSignature Language="C#" Value="public static Type GetReflectionType (object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetReflectionType(object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetReflectionType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetReflectionType (instance As Object) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetReflectionType(System::Object ^ instance);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instance">目標元件的執行個體。</param>
        <summary>傳回可用來執行反映的 <see cref="T:System.Type" /> (已指定物件)。</summary>
        <returns>指定物件的 <see cref="T:System.Type" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.TypeDescriptor.GetReflectionType%2A>方法是低階版本的<xref:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor%2A>方法。 <xref:System.ComponentModel.TypeDescriptor.GetReflectionType%2A> 通常用來執行對物件的標準反映，沒有自訂類型描述元可以找到它。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> 為 <see langword="null" />。</exception>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetClassName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetComponentName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProvider" />
      </Docs>
    </Member>
    <Member MemberName="GetReflectionType">
      <MemberSignature Language="C#" Value="public static Type GetReflectionType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetReflectionType(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetReflectionType(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetReflectionType(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">目標元件的 <see cref="T:System.Type" />。</param>
        <summary>傳回可用來執行反映的 <see cref="T:System.Type" /> (已指定類別型別)。</summary>
        <returns>指定類別的 <see cref="T:System.Type" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.TypeDescriptor.GetReflectionType%2A>方法是低階版本的<xref:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor%2A>方法。 <xref:System.ComponentModel.TypeDescriptor.GetReflectionType%2A> 通常用來執行標準的反映類別，沒有自訂類型描述元可以找到它。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> 為 <see langword="null" />。</exception>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetClassName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetComponentName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProvider" />
      </Docs>
    </Member>
    <Member MemberName="InterfaceType">
      <MemberSignature Language="C#" Value="public static Type InterfaceType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Type InterfaceType" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.TypeDescriptor.InterfaceType" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property InterfaceType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Type ^ InterfaceType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得代表所有介面類型的類型描述提供者的類型。</summary>
        <value>
          <see cref="T:System.Type" />，表示所有介面型別的自訂型別描述提供者。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.TypeDescriptor.InterfaceType%2A>屬性會取得<xref:System.Type>可以傳遞給物件<xref:System.ComponentModel.TypeDescriptor.AddProvider%2A>方法來定義介面類型的類型描述提供者。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Refresh">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>從快取清除屬性和事件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public static void Refresh (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Refresh(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.Refresh(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Refresh (component As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Refresh(System::Object ^ component);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">其屬性或事件已變更的元件。</param>
        <summary>從快取清除指定元件的屬性和事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 屬性和事件不會快取<xref:System.ComponentModel.TypeDescriptor>速度。 通常，它們都維持不變的物件存留期。 不過，擴充性提供者和設計工具可以變更物件上的屬性的集。 如果沒有的話，它們應該呼叫這個方法，以清除物件的屬性和事件描述項。 這個方法只能在設計階段使用。 在執行階段不使用它。  
  
 這個方法也會引發<xref:System.ComponentModel.TypeDescriptor.Refreshed>事件屬性或事件的元件變更時。 如果沒有在先前呼叫只會引發這個事件<xref:System.ComponentModel.TypeDescriptor.GetProperties%2A>或<xref:System.ComponentModel.TypeDescriptor.GetEvents%2A>快取資訊的方法。  
  
   
  
## Examples  
 如需使用這個方法的範例，請參閱<xref:System.ComponentModel.RefreshEventHandler>類別。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="E:System.ComponentModel.TypeDescriptor.Refreshed" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public static void Refresh (System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Refresh(class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.Refresh(System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Refresh(System::Reflection::Assembly ^ assembly);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="assembly">
          <see cref="T:System.Reflection.Assembly" />，表示要重新整理的組件。 這個組件中的各個 <see cref="T:System.Type" /> 都會被重新整理。</param>
        <summary>從快取清除指定組件的屬性和事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 屬性和事件不會快取<xref:System.ComponentModel.TypeDescriptor>速度。 通常，它們都維持不變的物件存留期。 不過，擴充性提供者和設計工具可以變更物件上的屬性的集。 如果沒有的話，它們能呼叫這個方法，以清除物件的屬性和事件描述項。 這個方法只能在設計階段使用。 在執行階段不使用它。  
  
 之前，請呼叫<xref:System.ComponentModel.TypeDescriptor.Refresh%2A>方法，以清除快取中，您需要呼叫<xref:System.ComponentModel.TypeDescriptor.GetProperties%2A>第一次快取的資訊的特定組件的方法。  
  
 這個方法也會引發<xref:System.ComponentModel.TypeDescriptor.Refreshed>事件以通知所有想要的屬性集元件變更時收到通知的類別。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Assembly" />
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.IExtenderProvider" />
        <altmember cref="T:System.ComponentModel.Design.IDesigner" />
        <altmember cref="E:System.ComponentModel.TypeDescriptor.Refreshed" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public static void Refresh (System.Reflection.Module module);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Refresh(class System.Reflection.Module module) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.Refresh(System.Reflection.Module)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Refresh(System::Reflection::Module ^ module);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="module" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="module">
          <see cref="T:System.Reflection.Module" />，表示要重新整理的模組。 這個模組中的各個 <see cref="T:System.Type" /> 都會被重新整理。</param>
        <summary>從快取清除指定模組的屬性和事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 屬性和事件不會快取<xref:System.ComponentModel.TypeDescriptor>速度。 通常，它們都維持不變的物件存留期。 不過，擴充性提供者和設計工具可以變更物件上的屬性的集。 如果沒有的話，它們能呼叫這個方法，以清除物件的屬性和事件描述項。 這個方法只能在設計階段使用。 在執行階段不使用它。  
  
 之前，請呼叫<xref:System.ComponentModel.TypeDescriptor.Refresh%2A>方法，以清除快取中，您需要呼叫<xref:System.ComponentModel.TypeDescriptor.GetProperties%2A>第一次快取的資訊的特定模組的方法。  
  
 這個方法也會引發<xref:System.ComponentModel.TypeDescriptor.Refreshed>事件以通知所有想要的屬性集元件變更時收到通知的類別。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Module" />
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.IExtenderProvider" />
        <altmember cref="T:System.ComponentModel.Design.IDesigner" />
        <altmember cref="E:System.ComponentModel.TypeDescriptor.Refreshed" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public static void Refresh (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Refresh(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.Refresh(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Refresh(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">目標元件的 <see cref="T:System.Type" />。</param>
        <summary>從快取清除指定元件類型的屬性和事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您不需要物件的執行個體時，才呼叫這個方法的這個版本。  
  
 屬性和事件不會快取<xref:System.ComponentModel.TypeDescriptor>速度。 通常，它們都維持不變的物件存留期。 不過，擴充性提供者和設計工具可以變更物件上的屬性的集。 如果沒有的話，它們能呼叫這個方法，以清除物件的屬性和事件描述項。 這個方法只能在設計階段使用。 在執行階段不使用它。  
  
 這個方法也會引發<xref:System.ComponentModel.TypeDescriptor.Refreshed>事件屬性或事件的元件變更時。 如果沒有在先前呼叫只會引發這個事件<xref:System.ComponentModel.TypeDescriptor.GetProperties%2A>或<xref:System.ComponentModel.TypeDescriptor.GetEvents%2A>快取資訊的方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.IExtenderProvider" />
        <altmember cref="T:System.ComponentModel.Design.IDesigner" />
        <altmember cref="E:System.ComponentModel.TypeDescriptor.Refreshed" />
      </Docs>
    </Member>
    <Member MemberName="Refreshed">
      <MemberSignature Language="C#" Value="public static event System.ComponentModel.RefreshEventHandler Refreshed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.RefreshEventHandler Refreshed" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.TypeDescriptor.Refreshed" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event Refreshed As RefreshEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event System::ComponentModel::RefreshEventHandler ^ Refreshed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.RefreshEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>清除元件快取時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需處理事件的詳細資訊，請參閱[NIB： 使用事件](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)。  
  
   
  
## Examples  
 如需使用此事件的範例，請參閱<xref:System.ComponentModel.RefreshEventHandler>類別。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAssociation">
      <MemberSignature Language="C#" Value="public static void RemoveAssociation (object primary, object secondary);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveAssociation(object primary, object secondary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.RemoveAssociation(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveAssociation (primary As Object, secondary As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveAssociation(System::Object ^ primary, System::Object ^ secondary);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="primary" Type="System.Object" />
        <Parameter Name="secondary" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="primary">主要 <see cref="T:System.Object" />。</param>
        <param name="secondary">次要 <see cref="T:System.Object" />。</param>
        <summary>移除兩個物件之間的關聯。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.TypeDescriptor.RemoveAssociation%2A>方法會移除所形成的兩個物件之間的關聯<xref:System.ComponentModel.TypeDescriptor.CreateAssociation%2A>方法。  
  
 A<xref:System.WeakReference>是用來維護主要和次要物件之間的關聯; 因此，這個方法不會影響任一物件已完成或記憶體回收所回收時。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">參數的其中之一或兩者都是 <see langword="null" />。</exception>
        <permission cref="T:System.Security.NamedPermissionSet">系統資源的完整存取權。 要求的值： <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />。 相關聯的狀態：</permission>
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateAssociation(System.Object,System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetAssociation(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAssociations">
      <MemberSignature Language="C#" Value="public static void RemoveAssociations (object primary);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveAssociations(object primary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.RemoveAssociations(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveAssociations (primary As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveAssociations(System::Object ^ primary);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="primary" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="primary">關聯的主要 <see cref="T:System.Object" />。</param>
        <summary>移除所有主要物件的關聯。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.TypeDescriptor.RemoveAssociations%2A>方法會移除主要物件以及其所有次要物件，呼叫所建立的所有關聯<xref:System.ComponentModel.TypeDescriptor.CreateAssociation%2A>方法。  
  
 A<xref:System.WeakReference>是用來維護主要和次要物件之間的關聯; 因此，這個方法不會影響當完成次要物件的主要或記憶體回收所回收。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="primary" /> 為 <see langword="null" />。</exception>
        <permission cref="T:System.Security.NamedPermissionSet">系統資源的完整存取權。 要求的值： <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />。 相關聯的狀態：</permission>
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateAssociation(System.Object,System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetAssociation(System.Type,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveProvider">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>移除先前加入的類型描述提供者。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveProvider">
      <MemberSignature Language="C#" Value="public static void RemoveProvider (System.ComponentModel.TypeDescriptionProvider provider, object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveProvider(class System.ComponentModel.TypeDescriptionProvider provider, object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.RemoveProvider(System.ComponentModel.TypeDescriptionProvider,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveProvider (provider As TypeDescriptionProvider, instance As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveProvider(System::ComponentModel::TypeDescriptionProvider ^ provider, System::Object ^ instance);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">要移除的 <see cref="T:System.ComponentModel.TypeDescriptionProvider" />。</param>
        <param name="instance">目標元件的執行個體。</param>
        <summary>移除先前所加入之與指定物件相關聯的類型描述提供者。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會移除先前新增的類型描述提供者<xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29>方法。 移除提供者會使<xref:System.ComponentModel.TypeDescriptor.Refreshed>相關聯的物件會引發事件。  
  
 使用<xref:System.ComponentModel.TypeDescriptor.RemoveProviderTransparent%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29>方法，如果您需要從部分信任程式碼呼叫。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">參數的其中之一或兩者都是 <see langword="null" />。</exception>
        <permission cref="T:System.Security.NamedPermissionSet">系統資源的完整存取權。 要求的值： <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />。 相關聯的狀態：</permission>
        <altmember cref="T:System.ComponentModel.TypeDescriptionProvider" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.AddProvider" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProvider" />
      </Docs>
    </Member>
    <Member MemberName="RemoveProvider">
      <MemberSignature Language="C#" Value="public static void RemoveProvider (System.ComponentModel.TypeDescriptionProvider provider, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveProvider(class System.ComponentModel.TypeDescriptionProvider provider, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.RemoveProvider(System.ComponentModel.TypeDescriptionProvider,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveProvider(System::ComponentModel::TypeDescriptionProvider ^ provider, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="provider">要移除的 <see cref="T:System.ComponentModel.TypeDescriptionProvider" />。</param>
        <param name="type">目標元件的 <see cref="T:System.Type" />。</param>
        <summary>移除先前所加入與指定類型相關聯的類型描述提供者。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會移除先前新增的類型描述提供者<xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29>方法。 移除提供者會使<xref:System.ComponentModel.TypeDescriptor.Refreshed>相關聯的類型會引發事件。  
  
 使用<xref:System.ComponentModel.TypeDescriptor.RemoveProviderTransparent%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29>方法，如果您需要從部分信任程式碼呼叫。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">參數的其中之一或兩者都是 <see langword="null" />。</exception>
        <permission cref="T:System.Security.NamedPermissionSet">系統資源的完整存取權。 要求的值： <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />。 相關聯的狀態：</permission>
        <altmember cref="T:System.ComponentModel.TypeDescriptionProvider" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.AddProvider" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProvider" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveProviderTransparent">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>移除先前加入的類型描述提供者。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveProviderTransparent">
      <MemberSignature Language="C#" Value="public static void RemoveProviderTransparent (System.ComponentModel.TypeDescriptionProvider provider, object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveProviderTransparent(class System.ComponentModel.TypeDescriptionProvider provider, object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.RemoveProviderTransparent(System.ComponentModel.TypeDescriptionProvider,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveProviderTransparent (provider As TypeDescriptionProvider, instance As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveProviderTransparent(System::ComponentModel::TypeDescriptionProvider ^ provider, System::Object ^ instance);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">要移除的 <see cref="T:System.ComponentModel.TypeDescriptionProvider" />。</param>
        <param name="instance">目標元件的執行個體。</param>
        <summary>移除先前所加入之與指定物件相關聯的類型描述提供者。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會移除先前新增的類型描述提供者<xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29>方法。 移除提供者會使<xref:System.ComponentModel.TypeDescriptor.Refreshed>相關聯的物件會引發事件。  
  
 可以從部分信任程式碼呼叫這個方法。 如果<xref:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess>是定義，呼叫端可以註冊指定的執行個體的提供者，如果其類型也受到部分信任。  
  
 使用<xref:System.ComponentModel.TypeDescriptor.RemoveProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29>方法，如果您不需要從部分信任程式碼呼叫。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">參數的其中之一或兩者都是 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.TypeDescriptorPermission">用於登錄存取。 安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess" /></permission>
        <permission cref="P:System.Reflection.Assembly.PermissionSet">安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。 關聯的類型：<see cref="T:System.Security.PermissionSet" />所定義的組件所需<paramref name="instance" />參數的型別。</permission>
      </Docs>
    </Member>
    <Member MemberName="RemoveProviderTransparent">
      <MemberSignature Language="C#" Value="public static void RemoveProviderTransparent (System.ComponentModel.TypeDescriptionProvider provider, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveProviderTransparent(class System.ComponentModel.TypeDescriptionProvider provider, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.RemoveProviderTransparent(System.ComponentModel.TypeDescriptionProvider,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveProviderTransparent(System::ComponentModel::TypeDescriptionProvider ^ provider, Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="provider">要移除的 <see cref="T:System.ComponentModel.TypeDescriptionProvider" />。</param>
        <param name="type">目標元件的 <see cref="T:System.Type" />。</param>
        <summary>移除先前所加入與指定類型相關聯的類型描述提供者。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會移除先前新增的類型描述提供者<xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29>方法。 移除提供者會使<xref:System.ComponentModel.TypeDescriptor.Refreshed>相關聯的類型會引發事件。  
  
 可以從部分信任程式碼呼叫這個方法。 如果<xref:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess>是定義，呼叫端可以取消註冊提供者指定的類型如果也受到部分信任。  
  
 使用<xref:System.ComponentModel.TypeDescriptor.RemoveProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29>方法，如果您不需要從部分信任程式碼呼叫。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">參數的其中之一或兩者都是 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.TypeDescriptorPermission">用於登錄存取。 安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess" /></permission>
        <permission cref="P:System.Reflection.Assembly.PermissionSet">安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。 關聯的類型：<see cref="T:System.Security.PermissionSet" />所定義的組件所需<paramref name="type" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="SortDescriptorArray">
      <MemberSignature Language="C#" Value="public static void SortDescriptorArray (System.Collections.IList infos);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SortDescriptorArray(class System.Collections.IList infos) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.SortDescriptorArray(System.Collections.IList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SortDescriptorArray (infos As IList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SortDescriptorArray(System::Collections::IList ^ infos);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="infos" Type="System.Collections.IList" />
      </Parameters>
      <Docs>
        <param name="infos">
          <see cref="T:System.Collections.IList" />，包含要排序的描述項。</param>
        <summary>使用描述項名稱的排序描述元。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="infos" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.Refresh" />
      </Docs>
    </Member>
  </Members>
</Type>