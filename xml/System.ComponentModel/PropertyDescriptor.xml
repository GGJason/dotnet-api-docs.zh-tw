<Type Name="PropertyDescriptor" FullName="System.ComponentModel.PropertyDescriptor">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8e059b64b5fedee627a7dad23bafc67c4252df0d" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30381222" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class PropertyDescriptor : System.ComponentModel.MemberDescriptor" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit PropertyDescriptor extends System.ComponentModel.MemberDescriptor" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.PropertyDescriptor" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class PropertyDescriptor&#xA;Inherits MemberDescriptor" />
  <TypeSignature Language="C++ CLI" Value="public ref class PropertyDescriptor abstract : System::ComponentModel::MemberDescriptor" />
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.MemberDescriptor</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供類別上屬性的抽象。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 屬性的描述是由名稱、 其屬性、 屬性相關聯，元件類別和屬性的型別所組成。  
  
 <xref:System.ComponentModel.PropertyDescriptor> 提供下列屬性和方法：  
  
-   <xref:System.ComponentModel.PropertyDescriptor.Converter%2A> 包含<xref:System.ComponentModel.TypeConverter>這個屬性。  
  
-   <xref:System.ComponentModel.PropertyDescriptor.IsLocalizable%2A> 指出是否應該當地語系化此屬性。  
  
-   <xref:System.ComponentModel.PropertyDescriptor.GetEditor%2A> 傳回指定之型別的編輯器。  
  
 <xref:System.ComponentModel.PropertyDescriptor> 也提供了下列`abstract`屬性和方法：  
  
-   <xref:System.ComponentModel.PropertyDescriptor.ComponentType%2A> 包含這個屬性所繫結至元件的類型。  
  
-   <xref:System.ComponentModel.PropertyDescriptor.IsReadOnly%2A> 指出此屬性是否為唯讀。  
  
-   <xref:System.ComponentModel.PropertyDescriptor.PropertyType%2A> 取得屬性的型別。  
  
-   <xref:System.ComponentModel.PropertyDescriptor.CanResetValue%2A> 指出是否重設此元件變更元件的值。  
  
-   <xref:System.ComponentModel.PropertyDescriptor.GetValue%2A> 在元件上傳回屬性的目前值。  
  
-   <xref:System.ComponentModel.PropertyDescriptor.ResetValue%2A> 重設元件的這個屬性的值。  
  
-   <xref:System.ComponentModel.PropertyDescriptor.SetValue%2A> 設定元件的值不同的值。  
  
-   <xref:System.ComponentModel.PropertyDescriptor.ShouldSerializeValue%2A> 指出是否需要保存此屬性的值。  
  
 一般而言，`abstract`成員會透過反映來實作。 如需反映的詳細資訊，請參閱[反映](~/docs/framework/reflection-and-codedom/reflection.md)。  
  
   
  
## Examples  
 下列程式碼範例會根據中的範例<xref:System.ComponentModel.PropertyDescriptorCollection>類別。 它會列印在文字方塊中的按鈕的文字資訊 （類別、 描述、 顯示名稱）。 它假設`button1`和`textbox1`具現化表單上。  
  
 [!code-cpp[PropertyDescriptor#1](~/samples/snippets/cpp/VS_Snippets_Winforms/PropertyDescriptor/CPP/propertydescriptor.cpp#1)]
 [!code-csharp[PropertyDescriptor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/PropertyDescriptor/CS/propertydescriptor.cs#1)]
 [!code-vb[PropertyDescriptor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/PropertyDescriptor/VB/propertydescriptor.vb#1)]  
  
 下列程式碼範例示範如何實作提供屬性的唯讀包裝函式的自訂屬性描述元。 `SerializeReadOnlyPropertyDescriptor`用於自訂的設計工具提供控制項的唯讀屬性描述元<xref:System.Windows.Forms.Control.Size%2A>屬性。  
  
 [!code-csharp[System.ComponentModel.PropertyDescriptor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.PropertyDescriptor/CS/SerializeReadOnlyPropertyDescriptor.cs#1)]
 [!code-vb[System.ComponentModel.PropertyDescriptor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.PropertyDescriptor/VB/SerializeReadOnlyPropertyDescriptor.vb#1)]  
  
 下列程式碼範例示範如何使用`SerializeReadOnlyPropertyDescriptor`自訂設計工具中。  
  
 [!code-csharp[System.ComponentModel.PropertyDescriptor#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.PropertyDescriptor/CS/DemoControlDesigner.cs#10)]
 [!code-vb[System.ComponentModel.PropertyDescriptor#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.PropertyDescriptor/VB/DemoControlDesigner.vb#10)]  
[!code-csharp[System.ComponentModel.PropertyDescriptor#100](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.PropertyDescriptor/CS/DemoControl.cs#100)]
[!code-vb[System.ComponentModel.PropertyDescriptor#100](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.PropertyDescriptor/VB/DemoControl.vb#100)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ComponentModel.MemberDescriptor" />
    <altmember cref="T:System.Attribute" />
    <altmember cref="T:System.ComponentModel.DefaultValueAttribute" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.ComponentModel.PropertyDescriptor" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PropertyDescriptor (System.ComponentModel.MemberDescriptor descr);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.ComponentModel.MemberDescriptor descr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.#ctor(System.ComponentModel.MemberDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (descr As MemberDescriptor)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PropertyDescriptor(System::ComponentModel::MemberDescriptor ^ descr);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="descr" Type="System.ComponentModel.MemberDescriptor" />
      </Parameters>
      <Docs>
        <param name="descr">
          <see cref="T:System.ComponentModel.MemberDescriptor" />，包含屬性的名稱和其屬性。</param>
        <summary>使用指定 <see cref="T:System.ComponentModel.PropertyDescriptor" /> 中的名稱和屬性，初始化 <see cref="T:System.ComponentModel.MemberDescriptor" /> 類別的新執行個體。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.ComponentModel.MemberDescriptor" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PropertyDescriptor (System.ComponentModel.MemberDescriptor descr, Attribute[] attrs);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.ComponentModel.MemberDescriptor descr, class System.Attribute[] attrs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.#ctor(System.ComponentModel.MemberDescriptor,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (descr As MemberDescriptor, attrs As Attribute())" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PropertyDescriptor(System::ComponentModel::MemberDescriptor ^ descr, cli::array &lt;Attribute ^&gt; ^ attrs);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="descr" Type="System.ComponentModel.MemberDescriptor" />
        <Parameter Name="attrs" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="descr">
          <see cref="T:System.ComponentModel.MemberDescriptor" />，包含成員名稱和其屬性。</param>
        <param name="attrs">
          <see cref="T:System.Attribute" /> 陣列，含有要與屬性 (Property) 關聯的屬性 (Attribute)。</param>
        <summary>使用指定 <see cref="T:System.ComponentModel.PropertyDescriptor" /> 中的名稱，以及 <see cref="T:System.ComponentModel.MemberDescriptor" /> 和 <see cref="T:System.ComponentModel.MemberDescriptor" /> 陣列中的屬性，初始化 <see cref="T:System.Attribute" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個建構函式會將附加的屬性中<xref:System.Attribute>中屬性的陣列<xref:System.ComponentModel.MemberDescriptor>。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.MemberDescriptor" />
        <altmember cref="T:System.Attribute" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PropertyDescriptor (string name, Attribute[] attrs);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string name, class System.Attribute[] attrs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.#ctor(System.String,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (name As String, attrs As Attribute())" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PropertyDescriptor(System::String ^ name, cli::array &lt;Attribute ^&gt; ^ attrs);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attrs" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="name">屬性的名稱。</param>
        <param name="attrs">
          <see cref="T:System.Attribute" /> 型別的陣列，包含 Property 屬性。</param>
        <summary>使用指定的名稱和屬性，初始化 <see cref="T:System.ComponentModel.PropertyDescriptor" /> 類別的新執行個體。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Attribute" />
      </Docs>
    </Member>
    <Member MemberName="AddValueChanged">
      <MemberSignature Language="C#" Value="public virtual void AddValueChanged (object component, EventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddValueChanged(object component, class System.EventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.AddValueChanged(System.Object,System.EventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AddValueChanged (component As Object, handler As EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AddValueChanged(System::Object ^ component, EventHandler ^ handler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="handler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="component">要為其加入處理常式的元件。</param>
        <param name="handler">要加入以做為接聽程式 (Listener) 的委派。</param>
        <summary>使其他物件能在這個屬性變更時受到告知。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> 或 <paramref name="handler" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="CanResetValue">
      <MemberSignature Language="C#" Value="public abstract bool CanResetValue (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanResetValue(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.CanResetValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CanResetValue (component As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool CanResetValue(System::Object ^ component);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">要測試重設能力的元件。</param>
        <summary>在衍生類別中覆寫時，傳回重設物件是否變更其值。</summary>
        <returns>
          如果重設元件會變更其值，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一般而言，透過反映來實作這個方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當在衍生類別中覆寫時，這個方法會尋找<see cref="T:System.ComponentModel.DefaultValueAttribute" />。 如果找到，它會比較屬性的目前值與屬性的值。 它會傳回<see langword="true" />當預設值不符合屬性的目前值。 如果找不到這個方法<see cref="T:System.ComponentModel.DefaultValueAttribute" />，它會尋找您需要實作您自己的 「 ShouldPersistMyProperty"方法。 如果找到，<see cref="M:System.ComponentModel.PropertyDescriptor.CanResetValue(System.Object)" />傳回"ShouldPersistMyProperty"的傳回值。 否則，它會尋找您需要實作您自己的 「 ResetMyProperty"方法。 如果找到，<see cref="M:System.ComponentModel.PropertyDescriptor.CanResetValue(System.Object)" />傳回<see langword="true" />。 如果找不到<see cref="T:System.ComponentModel.DefaultValueAttribute" />，"ShouldPersistMyProperty"方法，或 「 ResetMyProperty"方法，則它會傳回<see langword="false" />。</para>
        </block>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
      </Docs>
    </Member>
    <Member MemberName="ComponentType">
      <MemberSignature Language="C#" Value="public abstract Type ComponentType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ComponentType" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.PropertyDescriptor.ComponentType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property ComponentType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ ComponentType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在衍生類別中覆寫時，取得這個屬性所繫結的元件型別。</summary>
        <value>
          <see cref="T:System.Type" />，表示這個屬性所繫結的元件型別。 當叫用 <see cref="M:System.ComponentModel.PropertyDescriptor.GetValue(System.Object)" /> 或 <see cref="M:System.ComponentModel.PropertyDescriptor.SetValue(System.Object,System.Object)" /> 方法時，指定的物件可能是這個型別的執行個體。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常，這個屬性是透過反映來實作。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Converter">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.TypeConverter Converter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.TypeConverter Converter" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.PropertyDescriptor.Converter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Converter As TypeConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::TypeConverter ^ Converter { System::ComponentModel::TypeConverter ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeConverter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個屬性的型別轉換子。</summary>
        <value>
          <see cref="T:System.ComponentModel.TypeConverter" />，用來轉換這個屬性的 <see cref="T:System.Type" />。</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.ComponentModel.TypeConverter" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected object CreateInstance (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object CreateInstance(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.CreateInstance(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ CreateInstance(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" />，表示要建立的型別。</param>
        <summary>建立指定類型的執行個體。</summary>
        <returns>型別的新執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.PropertyDescriptor.CreateInstance%2A> 看起來會採用指定之類型的建構函式。 如果找到建構函式，會傳入屬性的型別。  
  
 轉換和編輯器使用這個方法來建立元件的版本。 這個方法可讓您可以重複使用於多個類型的單一元件。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">用於存取私用類別成員和中繼資料。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.ComponentModel.TypeConverter" />
        <altmember cref="T:System.Drawing.Design.UITypeEditor" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">與這個 <see cref="T:System.ComponentModel.PropertyDescriptor" /> 相比較的物件。</param>
        <summary>比較這個與另一個物件，以檢視它們是否相等。</summary>
        <returns>
          如果值相等，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FillAttributes">
      <MemberSignature Language="C#" Value="protected override void FillAttributes (System.Collections.IList attributeList);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void FillAttributes(class System.Collections.IList attributeList) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.FillAttributes(System.Collections.IList)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub FillAttributes (attributeList As IList)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void FillAttributes(System::Collections::IList ^ attributeList);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeList" Type="System.Collections.IList" />
      </Parameters>
      <Docs>
        <param name="attributeList">
          <see cref="T:System.Collections.IList" />，列出父類別中的屬性。 這個一開始是空的。</param>
        <summary>將 <see cref="T:System.ComponentModel.PropertyDescriptor" /> 的屬性加入至父類別中的指定屬性清單。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 針對重複的屬性，會保留最後一個新增至清單。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChildProperties">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回 <see cref="T:System.ComponentModel.PropertyDescriptorCollection" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChildProperties">
      <MemberSignature Language="C#" Value="public System.ComponentModel.PropertyDescriptorCollection GetChildProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ComponentModel.PropertyDescriptorCollection GetChildProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.GetChildProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChildProperties () As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ComponentModel::PropertyDescriptorCollection ^ GetChildProperties();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回預設的 <see cref="T:System.ComponentModel.PropertyDescriptorCollection" />。</summary>
        <returns>屬性描述元的集合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳遞`null`兩者`instance`參數和`filter`參數。  
  
 屬性`instance`參數可能會與不同類別的屬性，因為容器可以新增或移除屬性，如果`instance`設置參數。  
  
 `filter`參數可以混合<xref:System.Type>和<xref:System.Attribute>物件。 篩選是由下列規則定義：  
  
-   A<xref:System.Type>物件會被視為萬用字元，它會比對的任何屬性<xref:System.Type>集中的屬性。  
  
-   如果屬性沒有<xref:System.Attribute>的相同類別中，屬性將不會包含傳回陣列中。  
  
-   如果屬性的執行個體<xref:System.Attribute>，屬性必須是包含傳回陣列中完全相符。  
  
-   如果您指定<xref:System.Attribute>且其為預設屬性，就會包含在傳回陣列中，即使沒有任何執行個體<xref:System.Attribute>屬性中。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.TypeDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="T:System.Attribute" />
      </Docs>
    </Member>
    <Member MemberName="GetChildProperties">
      <MemberSignature Language="C#" Value="public System.ComponentModel.PropertyDescriptorCollection GetChildProperties (Attribute[] filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ComponentModel.PropertyDescriptorCollection GetChildProperties(class System.Attribute[] filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.GetChildProperties(System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChildProperties (filter As Attribute()) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ComponentModel::PropertyDescriptorCollection ^ GetChildProperties(cli::array &lt;Attribute ^&gt; ^ filter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="filter">
          <see cref="T:System.Attribute" /> 型別的陣列，可用來當做篩選條件。</param>
        <summary>使用指定的屬性陣列做為篩選條件，傳回 <see cref="T:System.ComponentModel.PropertyDescriptorCollection" />。</summary>
        <returns>
          <see cref="T:System.ComponentModel.PropertyDescriptorCollection" />，具有與指定屬性 (Attribute) 相符的屬性 (Property)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳遞`null`如`instance`參數。  
  
 屬性`instance`參數可能會與不同類別的屬性，因為站台可以新增或移除屬性，如果`instance`設置參數。  
  
 `filter`參數可以混合<xref:System.Type>和<xref:System.Attribute>物件。 篩選是由下列規則定義：  
  
-   A<xref:System.Type>物件會被視為萬用字元，它會比對的任何屬性<xref:System.Type>集中的屬性。  
  
-   如果屬性沒有<xref:System.Attribute>的相同類別中，屬性將不會包含傳回陣列中。  
  
-   如果屬性的執行個體<xref:System.Attribute>，屬性必須是包含傳回陣列中完全相符。  
  
-   如果您指定<xref:System.Attribute>執行個體，且它的預設屬性，就會包含傳回陣列中即使沒有任何執行個體<xref:System.Attribute>屬性中。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.TypeDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="T:System.Attribute" />
      </Docs>
    </Member>
    <Member MemberName="GetChildProperties">
      <MemberSignature Language="C#" Value="public System.ComponentModel.PropertyDescriptorCollection GetChildProperties (object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ComponentModel.PropertyDescriptorCollection GetChildProperties(object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.GetChildProperties(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChildProperties (instance As Object) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ComponentModel::PropertyDescriptorCollection ^ GetChildProperties(System::Object ^ instance);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instance">要為其取得屬性的元件。</param>
        <summary>傳回指定物件的 <see cref="T:System.ComponentModel.PropertyDescriptorCollection" />。</summary>
        <returns>具有指定元件屬性的 <see cref="T:System.ComponentModel.PropertyDescriptorCollection" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳遞`null`如`filter`參數。  
  
 屬性`instance`參數可能會與不同類別的屬性，因為站台可以新增或移除屬性，如果`instance`設置參數。  
  
 `filter`參數可以混合<xref:System.Type>和<xref:System.Attribute>物件。 篩選是由下列規則定義：  
  
-   A<xref:System.Type>物件會被視為萬用字元，它會比對的任何屬性<xref:System.Type>集中的屬性。  
  
-   如果屬性沒有<xref:System.Attribute>的相同類別中，屬性將不會包含傳回陣列中。  
  
-   如果屬性的執行個體<xref:System.Attribute>，屬性必須是包含傳回陣列中完全相符。  
  
-   如果您指定<xref:System.Attribute>執行個體，且它的預設屬性，就會包含傳回陣列中即使沒有任何執行個體<xref:System.Attribute>屬性中。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.TypeDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="T:System.Attribute" />
      </Docs>
    </Member>
    <Member MemberName="GetChildProperties">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.PropertyDescriptorCollection GetChildProperties (object instance, Attribute[] filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ComponentModel.PropertyDescriptorCollection GetChildProperties(object instance, class System.Attribute[] filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.GetChildProperties(System.Object,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChildProperties (instance As Object, filter As Attribute()) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::ComponentModel::PropertyDescriptorCollection ^ GetChildProperties(System::Object ^ instance, cli::array &lt;Attribute ^&gt; ^ filter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
        <Parameter Name="filter" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="instance">要為其取得屬性的元件。</param>
        <param name="filter">
          <see cref="T:System.Attribute" /> 型別的陣列，可用來當做篩選條件。</param>
        <summary>使用指定的屬性陣列做為篩選條件，傳回指定物件的 <see cref="T:System.ComponentModel.PropertyDescriptorCollection" />。</summary>
        <returns>
          <see cref="T:System.ComponentModel.PropertyDescriptorCollection" />，具有與指定元件的指定屬性 (Attribute) 相符的屬性 (Property)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 屬性`instance`參數可能會與不同類別的屬性，因為站台可以新增或移除屬性，如果`instance`設置參數。  
  
 `filter`參數可以混合<xref:System.Type>和<xref:System.Attribute>物件。 篩選是由下列規則定義：  
  
-   A<xref:System.Type>物件會被視為萬用字元，它會比對的任何屬性<xref:System.Type>集中的屬性。  
  
-   如果屬性沒有<xref:System.Attribute>的相同類別中，屬性將不會包含傳回陣列中。  
  
-   如果屬性的執行個體<xref:System.Attribute>，屬性必須是包含傳回陣列中完全相符。  
  
-   如果您指定<xref:System.Attribute>執行個體，且它的預設屬性，就會包含傳回陣列中即使沒有任何執行個體<xref:System.Attribute>屬性中。  
  
 一般而言，子內容應該傳回藉由實作<xref:System.ComponentModel.TypeConverter.GetProperties%2A>隸屬<xref:System.ComponentModel.TypeConverter>這個屬性傳回。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.TypeDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="T:System.Attribute" />
      </Docs>
    </Member>
    <Member MemberName="GetEditor">
      <MemberSignature Language="C#" Value="public virtual object GetEditor (Type editorBaseType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetEditor(class System.Type editorBaseType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.GetEditor(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEditor (editorBaseType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetEditor(Type ^ editorBaseType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="editorBaseType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="editorBaseType">編輯器的基底型別 (Base Type)，用來區分屬性支援的多個編輯器。</param>
        <summary>取得指定型別的編輯器。</summary>
        <returns>要求的編輯器型別的執行個體，或者如果找不到，則為 <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回這個物件的雜湊程式碼。</summary>
        <returns>這個物件的雜湊程式碼。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInvocationTarget">
      <MemberSignature Language="C#" Value="protected override object GetInvocationTarget (Type type, object instance);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance object GetInvocationTarget(class System.Type type, object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.GetInvocationTarget(System.Type,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Object ^ GetInvocationTarget(Type ^ type, System::Object ^ instance);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="type">引動目標的 <see cref="T:System.Type" />。</param>
        <param name="instance">可能的引動目標。</param>
        <summary>這個方法會傳回應該在成員的引動過程使用的物件。</summary>
        <returns>
          <see cref="T:System.Object" />，應該在成員的引動過程使用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳回的值通常是相同`instance`傳入。 如果有人與這個執行個體，相關聯的另一個物件或執行個體是自訂類型描述元<xref:System.ComponentModel.PropertyDescriptor.GetInvocationTarget%2A>方法可能會傳回不同的值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromName">
      <MemberSignature Language="C#" Value="protected Type GetTypeFromName (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Type GetTypeFromName(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.GetTypeFromName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetTypeFromName (typeName As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Type ^ GetTypeFromName(System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">要擷取型別的組件限定名稱。</param>
        <summary>使用其名稱以傳回型別。</summary>
        <returns>符合指定型別名稱的 <see cref="T:System.Type" />，或者如果找不到符合的指定型別名稱，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要尋找適當的型別，這個方法會先檢查類型的組件這個<xref:System.ComponentModel.PropertyDescriptor>參考。 如果它在組件中找不到型別，它會呼叫<xref:System.Type.GetType%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public abstract object GetValue (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetValue(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.GetValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetValue (component As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ GetValue(System::Object ^ component);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">具有要為其擷取值之屬性的元件。</param>
        <summary>在衍生類別中覆寫時，取得元件上屬性的目前值。</summary>
        <returns>指定元件的屬性值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一般而言，透過反映來實作這個方法。  
  
 這個方法會自動呼叫變更前方法<xref:System.ComponentModel.Design.IComponentChangeService.OnComponentChanging%2A>，以及變更後的方法，<xref:System.ComponentModel.Design.IComponentChangeService.OnComponentChanged%2A>的<xref:System.ComponentModel.Design.IComponentChangeService>。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當您覆寫這個方法時，它會叫用 「 GetMyProperty"方法，您需要實作取得屬性的目前值。 該方法中的例外狀況應該傳遞。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetValueChangedHandler">
      <MemberSignature Language="C#" Value="protected internal EventHandler GetValueChangedHandler (object component);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.EventHandler GetValueChangedHandler(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.GetValueChangedHandler(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function GetValueChangedHandler (component As Object) As EventHandler" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; EventHandler ^ GetValueChangedHandler(System::Object ^ component);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">為其擷取事件處理常式的元件。</param>
        <summary>擷取特定元件目前的 <c>ValueChanged</c> 事件處理常式集</summary>
        <returns>組合的多點傳送事件處理常式；如果目前沒有指定給 <paramref name="component" /> 的事件處理常式，則為 <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLocalizable">
      <MemberSignature Language="C#" Value="public virtual bool IsLocalizable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLocalizable" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.PropertyDescriptor.IsLocalizable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsLocalizable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsLocalizable { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，表示這個屬性是否應該當地語系化，如 <see cref="T:System.ComponentModel.LocalizableAttribute" /> 中指定的。</summary>
        <value>
          如果成員是以設為 <see langword="true" /> 的 <see cref="T:System.ComponentModel.LocalizableAttribute" /> 標記則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當屬性會標示<xref:System.ComponentModel.LocalizableAttribute>設`true`和視覺化設計工具中使用，其值會儲存在資源檔。 如果標記與屬性的屬性，然後在程式碼中設定屬性時，不會使用資源檔。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.LocalizableAttribute" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public abstract bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.PropertyDescriptor.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在衍生類別中覆寫時，取得數值以指示這個屬性是否為唯讀。</summary>
        <value>
          如果屬性是唯讀，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.ComponentModel.ReadOnlyAttribute" />
      </Docs>
    </Member>
    <Member MemberName="OnValueChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnValueChanged (object component, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnValueChanged(object component, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.OnValueChanged(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnValueChanged (component As Object, e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnValueChanged(System::Object ^ component, EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="component">引發事件的物件。</param>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發您之前實作的 <c>ValueChanged</c> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 屬性值變更時，應該呼叫這個方法的屬性描述元實作。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyType">
      <MemberSignature Language="C#" Value="public abstract Type PropertyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type PropertyType" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.PropertyDescriptor.PropertyType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property PropertyType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ PropertyType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在衍生類別中覆寫時，取得屬性的型別。</summary>
        <value>
          <see cref="T:System.Type" />，表示屬性的型別。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常，這個屬性是透過反映來實作。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveValueChanged">
      <MemberSignature Language="C#" Value="public virtual void RemoveValueChanged (object component, EventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveValueChanged(object component, class System.EventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.RemoveValueChanged(System.Object,System.EventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveValueChanged (component As Object, handler As EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveValueChanged(System::Object ^ component, EventHandler ^ handler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="handler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="component">要為其移除處理常式的元件。</param>
        <param name="handler">要移除以做為接聽程式的委派。</param>
        <summary>使其他物件能在這個屬性變更時受到告知。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> 或 <paramref name="handler" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetValue">
      <MemberSignature Language="C#" Value="public abstract void ResetValue (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetValue(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.ResetValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub ResetValue (component As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void ResetValue(System::Object ^ component);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">屬性值要重設為預設值的元件。</param>
        <summary>在衍生類別中覆寫時，將元件的這個屬性值重設為預設值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一般而言，透過反映來實作這個方法。  
  
 這個方法會判斷要重設要依下列優先順序之屬性的值：  
  
1.  沒有這個屬性加上陰影的屬性。  
  
2.  沒有<xref:System.ComponentModel.DefaultValueAttribute>這個屬性。  
  
3.  沒有您已實作，其中"MyProperty"是您傳遞給它的屬性名稱"ResetMyProperty 」 方法。  
  
 這個方法會建立<xref:System.ComponentModel.Design.DesignerTransaction>自動以下列順序：  
  
1.  這個方法會呼叫<xref:System.ComponentModel.Design.IDesignerHost.CreateTransaction%2A?displayProperty=nameWithType>方法來建立新<xref:System.ComponentModel.Design.DesignerTransaction>來代表所做的變更。  
  
2.  這個方法會呼叫<xref:System.ComponentModel.Design.IComponentChangeService.OnComponentChanging%2A?displayProperty=nameWithType>方法，指出在交易開始，並不會發生的變更。  
  
3.  方法屬性重設為這個方法檢查順序所判斷的值。  
  
4.  這個方法會呼叫<xref:System.ComponentModel.Design.IComponentChangeService.OnComponentChanged%2A?displayProperty=nameWithType>方法，以表示已發生變更。  
  
5.  這個方法會呼叫<xref:System.ComponentModel.Design.DesignerTransaction.Commit%2A?displayProperty=nameWithType>表示交易已完成。  
  
 交易的目的在於支援`Undo`和`Redo`功能。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當在衍生類別中覆寫時，這個方法會尋找<see cref="T:System.ComponentModel.DefaultValueAttribute" />。 如果找到，它會設定的屬性值<see cref="T:System.ComponentModel.DefaultValueAttribute" />找到它。 如果找不到這個方法<see cref="T:System.ComponentModel.DefaultValueAttribute" />，它會尋找您需要實作 「 ResetMyProperty"方法。 如果找到，<see cref="M:System.ComponentModel.PropertyDescriptor.ResetValue(System.Object)" />方法會叫用它。 如果<see cref="M:System.ComponentModel.PropertyDescriptor.ResetValue(System.Object)" />找不到<see cref="T:System.ComponentModel.DefaultValueAttribute" />或 「 ResetMyProperty"方法實作時，不會執行作業。</para>
        </block>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
      </Docs>
    </Member>
    <Member MemberName="SerializationVisibility">
      <MemberSignature Language="C#" Value="public System.ComponentModel.DesignerSerializationVisibility SerializationVisibility { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ComponentModel.DesignerSerializationVisibility SerializationVisibility" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.PropertyDescriptor.SerializationVisibility" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SerializationVisibility As DesignerSerializationVisibility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::DesignerSerializationVisibility SerializationVisibility { System::ComponentModel::DesignerSerializationVisibility get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.DesignerSerializationVisibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，表示這個屬性是否應該序列化，如 <see cref="T:System.ComponentModel.DesignerSerializationVisibilityAttribute" /> 中指定的。</summary>
        <value>其中一個 <see cref="T:System.ComponentModel.DesignerSerializationVisibility" /> 列舉值，指定這個屬性是否應該序列化。</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.ComponentModel.DesignerSerializationVisibilityAttribute" />
        <altmember cref="T:System.ComponentModel.DesignerSerializationVisibility" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public abstract void SetValue (object component, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetValue(object component, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.SetValue(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub SetValue (component As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void SetValue(System::Object ^ component, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">屬性值將要設定的元件。</param>
        <param name="value">新值。</param>
        <summary>在衍生類別中覆寫時，將元件的值設定為不同的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一般而言，透過反映來實作這個方法。  
  
 這個方法會建立<xref:System.ComponentModel.Design.DesignerTransaction>自動以下列順序：  
  
1.  這個方法會呼叫<xref:System.ComponentModel.Design.IDesignerHost.CreateTransaction%2A?displayProperty=nameWithType>方法來建立新<xref:System.ComponentModel.Design.DesignerTransaction>來代表所做的變更。  
  
2.  這個方法會呼叫<xref:System.ComponentModel.Design.IComponentChangeService.OnComponentChanging%2A?displayProperty=nameWithType>方法，指出在交易開始，並不會發生的變更。  
  
3.  方法屬性重設為這個方法檢查順序所判斷的值。  
  
4.  這個方法會呼叫<xref:System.ComponentModel.Design.IComponentChangeService.OnComponentChanged%2A?displayProperty=nameWithType>方法，以表示已發生變更。  
  
5.  這個方法會呼叫<xref:System.ComponentModel.Design.DesignerTransaction.Commit%2A?displayProperty=nameWithType>表示交易已完成。  
  
 交易的目的在於支援`Undo`和`Redo`功能。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當您覆寫這個方法時，它應該藉由叫用適當的 「 SetMyProperty"方法，您需要實作設定屬性的值。 如果指定的值不是有效的元件應該擲回的例外狀況，它會向上傳遞。 您應該設計屬性 （也就您已實作） 遵循 「 SetMyProperty"方法 」 GetMyProperty"方法會傳回"SetMyProperty"方法不會擲回例外狀況時，會傳遞值。</para>
        </block>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeValue">
      <MemberSignature Language="C#" Value="public abstract bool ShouldSerializeValue (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ShouldSerializeValue(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.PropertyDescriptor.ShouldSerializeValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ShouldSerializeValue (component As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool ShouldSerializeValue(System::Object ^ component);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">元件，具有要檢查保存性 (Persistence) 的屬性。</param>
        <summary>在衍生類別中覆寫時，判斷指示這個屬性的值是否需要保存的值。</summary>
        <returns>
          如果屬性應該要保存，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一般而言，透過反映來實作這個方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當在衍生類別中覆寫時，這個方法會傳回<see langword="true" />如果屬性的目前值為其預設值不同。 做為預設值會尋找第一次尋找<see cref="T:System.ComponentModel.DefaultValueAttribute" />。 如果此方法會尋找此屬性，它會比較屬性的目前值與屬性的值。 如果找不到這個方法<see cref="T:System.ComponentModel.DefaultValueAttribute" />，它會尋找您需要實作 「 ShouldSerializeMyProperty"方法。 如果找到，<see cref="M:System.ComponentModel.PropertyDescriptor.ShouldSerializeValue(System.Object)" />叫用它。 如果找不到這個方法<see cref="T:System.ComponentModel.DefaultValueAttribute" />或 「 ShouldSerializeMyProperty"方法，它無法建立最佳化，並傳回<see langword="true" />。
 <block subset="none" type="note"><para><see cref="T:System.ComponentModel.Design.ComponentDesigner" />類別會實作繼承元件的特殊的序列化邏輯。 如需詳細資訊，請參閱<see cref="T:System.ComponentModel.Design.ComponentDesigner" />。  
</para></block></para>
        </block>
        <altmember cref="T:System.ComponentModel.Design.ComponentDesigner" />
      </Docs>
    </Member>
    <Member MemberName="SupportsChangeEvents">
      <MemberSignature Language="C#" Value="public virtual bool SupportsChangeEvents { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsChangeEvents" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.PropertyDescriptor.SupportsChangeEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsChangeEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsChangeEvents { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，表示這個屬性的數值變更告知是否可能來自屬性描述項之外。</summary>
        <value>
          如果數值變更告知可能來自屬性描述項之外則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.PropertyDescriptor.SupportsChangeEvents%2A>屬性會指出是否對此屬性的值變更通知可能來自外部的屬性描述元，例如與元件本身，或通知只能從直接呼叫對源自<xref:System.ComponentModel.PropertyDescriptor.SetValue%2A>方法。 例如，實作元件可能<xref:System.ComponentModel.INotifyPropertyChanged>介面，或可能有明確的`name.Changed`這個屬性的事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>