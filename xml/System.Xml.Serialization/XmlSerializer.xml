<Type Name="XmlSerializer" FullName="System.Xml.Serialization.XmlSerializer">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="27ab9939bf5a4c79ef30685cadd432730d74118c" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36438816" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XmlSerializer" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XmlSerializer extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Xml.Serialization.XmlSerializer" />
  <TypeSignature Language="VB.NET" Value="Public Class XmlSerializer" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlSerializer" />
  <TypeSignature Language="F#" Value="type XmlSerializer = class" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>將物件序列化為 XML 文件，以及從 XML 文件將物件還原序列化。 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 可讓您控制如何將物件編碼為 XML。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 XML 序列化 (Serialization) 是將物件公用屬性和欄位轉換為儲存或傳輸所用的序列格式 (此處即為 XML) 的程。 還原序列化重新建立 XML 輸出從其原始狀態中的物件。 您可以將序列化成資料流或緩衝區中儲存物件狀態的方式。 例如，ASP.NET 會使用<xref:System.Xml.Serialization.XmlSerializer>類別來編碼 XML Web 服務訊息。  
  
 您物件中的資料是用程式語言來描述的，該程式語言會建構如類別、欄位、屬性、基本型別 (Primitive Type)、陣列，甚至是以 <xref:System.Xml.XmlElement> 或 <xref:System.Xml.XmlAttribute> 物件為格式的內嵌 XML。 您可以選擇建立您自己的類別，標註具有屬性，或使用[XML 結構描述定義工具 (Xsd.exe)](http://msdn.microsoft.com/library/a6e6e65c-347f-4494-9457-653bf29baac2)產生根據現有 XML 結構描述定義 (XSD) 文件的類別。 如果您有 XML 結構描述，您可以執行 Xsd.exe 產生一組的強型別為結構描述和標註具有屬性，以遵守序列化時的結構描述的類別。  
  
 物件與 XML 之間傳輸資料需要從 XML 結構描述的程式設計語言建構和程式設計語言建構的 XML 結構描述的對應。 <xref:System.Xml.Serialization.XmlSerializer>和相關的工具，像是 Xsd.exe 提供這兩種技術，同時設計階段與執行階段之間的橋樑。 在設計階段使用 Xsd.exe，從您的自訂類別產生的 XML 結構描述文件 (.xsd)，或產生指定的結構描述中的類別。 在任一情況下，類別必須標註具有自訂屬性，以指示<xref:System.Xml.Serialization.XmlSerializer>如何將 XML 結構描述系統和通用語言執行平台之間的對應。 在執行階段，可以依照指定的結構描述的 XML 文件序列化的類別執行個體。 同樣地，這些 XML 文件可以還原序列化成執行階段物件。 請注意，XML 結構描述選擇性的並不需要在設計階段或執行階段。  
  
## <a name="controlling-generated-xml"></a>控制產生的 XML  
 若要控制所產生的 XML，您可以套用到類別和成員的特殊屬性。 例如，若要指定不同的 XML 項目名稱，套用<xref:System.Xml.Serialization.XmlElementAttribute>公用欄位或屬性，並設定<xref:System.Xml.Serialization.XmlElementAttribute.ElementName%2A>屬性。 如需類似屬性的完整清單，請參閱[屬性，控制 XML 序列化](http://msdn.microsoft.com/library/414b820f-a696-4206-b576-2711d85490c7)。 您也可以實作<xref:System.Xml.Serialization.IXmlSerializable>介面，以控制 XML 輸出。  
  
 如果產生的 XML 必須符合 World Wide 協會 (www.w3.org) 文件的第 5 節中，「 簡單物件存取通訊協定 (SOAP) 1.1 」，您必須建構<xref:System.Xml.Serialization.XmlSerializer>與<xref:System.Xml.Serialization.XmlTypeMapping>。 若要進一步控制編碼的 SOAP XML，使用 屬性列在[屬性，控制編碼 SOAP 序列化](http://msdn.microsoft.com/library/93ee258c-9c0f-4a08-897c-c10db7a00f91)。  
  
 與<xref:System.Xml.Serialization.XmlSerializer>您可以利用使用強型別類別，仍有彈性的 XML。 使用欄位或屬性的型別<xref:System.Xml.XmlElement>，<xref:System.Xml.XmlAttribute>或<xref:System.Xml.XmlNode>在強類型的類別中，您可以直接將 XML 物件讀取 XML 文件的一部分。  
  
 如果您使用可延伸的 XML 結構描述時，您也可以使用<xref:System.Xml.Serialization.XmlAnyElementAttribute>和<xref:System.Xml.Serialization.XmlAnyAttributeAttribute>序列化和還原序列化的原始結構描述中找不到元素或屬性的屬性。 若要使用的物件，將套用<xref:System.Xml.Serialization.XmlAnyElementAttribute>的欄位，傳回的陣列<xref:System.Xml.XmlElement>物件，或套用<xref:System.Xml.Serialization.XmlAnyAttributeAttribute>的欄位，傳回的陣列<xref:System.Xml.XmlAttribute>物件。  
  
 如果屬性或欄位傳回複雜物件 (例如陣列或類別執行個體)，<xref:System.Xml.Serialization.XmlSerializer> 會將它轉換為主要 XML 文件中的巢狀項目。 例如，下列程式碼中的第一個類別會傳回第二個類別的執行個體。  
  
```vb  
Public Class MyClass  
    Public MyObjectProperty As MyObject  
End Class  
  
Public Class MyObject  
    Public ObjectName As String  
End Class  
```  
  
```csharp  
public class MyClass  
{  
    public MyObject MyObjectProperty;  
}  
public class MyObject  
{  
    public string ObjectName;  
}  
```  
  
 序列化時，XML 輸出看起來像這樣：  
  
```  
<MyClass>  
  <MyObjectProperty>  
  <ObjectName>My String</ObjectName>  
  </MyObjectProperty>  
</MyClass>  
```  
  
 如果結構描述包含的項目是選擇性 (minOccurs = '0')，或結構描述包含預設值，如果您有兩個選項。 其中一個選項是使用<xref:System.ComponentModel.DefaultValueAttribute?displayProperty=nameWithType>來指定預設值，如下列程式碼所示。  
  
```vb  
Public Class PurchaseOrder  
    <System.ComponentModel.DefaultValueAttribute ("2002")> _  
    Public Year As String  
End Class  
```  
  
```csharp  
public class PurchaseOrder  
{  
    [System.ComponentModel.DefaultValueAttribute ("2002")]  
    public string Year;  
}  
```  
  
 另一個選項是使用特殊的模式來建立所辨識的布林值欄位<xref:System.Xml.Serialization.XmlSerializer>，及套用<xref:System.Xml.Serialization.XmlIgnoreAttribute>的欄位。 模式中的表單建立`propertyNameSpecified`。 例如，如果是名為"MyFirstName 」 也會建立名為"MyFirstNameSpecified"的欄位的欄位，會指示<xref:System.Xml.Serialization.XmlSerializer>是否要產生名為"MyFirstName"的 XML 項目。 這在下列範例中顯示。  
  
```vb  
Public Class OptionalOrder  
    ' This field's value should not be serialized   
    ' if it is uninitialized.  
    Public FirstOrder As String  
  
    ' Use the XmlIgnoreAttribute to ignore the   
    ' special field named "FirstOrderSpecified".  
    <System.Xml.Serialization.XmlIgnoreAttribute> _  
    Public FirstOrderSpecified As Boolean  
End Class  
```  
  
```csharp  
public class OptionalOrder  
{  
    // This field should not be serialized   
    // if it is uninitialized.  
    public string FirstOrder;  
  
    // Use the XmlIgnoreAttribute to ignore the   
    // special field named "FirstOrderSpecified".  
    [System.Xml.Serialization.XmlIgnoreAttribute]  
    public bool FirstOrderSpecified;  
}  
```  
  
## <a name="overriding-default-serialization"></a>覆寫預設的序列化  
 您可以藉由建立其中一個適當的屬性，並將它加入至執行個體也覆寫序列化的物件及其欄位和屬性的任何組<xref:System.Xml.Serialization.XmlAttributes>類別。 覆寫序列化這種方式有兩種用途： 首先，您可以控制和加強在 DLL 中，找到的物件序列化，即使您沒有存取來源。第二，您可以建立一組可序列化的類別，但是序列化多個方法中的物件。 如需詳細資訊，請參閱<xref:System.Xml.Serialization.XmlAttributeOverrides>類別和[如何： 控制序列化的衍生類別](http://msdn.microsoft.com/library/caa92596-9e15-4d91-acbe-56911ef47a84)。  
  
 若要序列化的物件，呼叫<xref:System.Xml.Serialization.XmlSerializer.Serialize%2A>方法。 若要還原序列化物件，呼叫<xref:System.Xml.Serialization.XmlSerializer.Deserialize%2A>方法。  
  
 若要加入至 XML 文件的 XML 命名空間，請參閱<xref:System.Xml.Serialization.XmlSerializerNamespaces>。  
  
> [!NOTE]
>  <xref:System.Xml.Serialization.XmlSerializer>提供特殊處理，類別可實作<xref:System.Collections.IEnumerable>或<xref:System.Collections.ICollection>。 實作 <xref:System.Collections.IEnumerable> 的類別必須實作只取單一參數的公用 `Add` 方法。 `Add`方法的參數必須屬於相同的型別傳回的`Current`屬性的傳回值`GetEnumerator`，或其中一個該類型的基底。 類別可實作<xref:System.Collections.ICollection>(例如<xref:System.Collections.CollectionBase>) 除了<xref:System.Collections.IEnumerable>必須有公用的`Item`索引的屬性 （C# 中的索引子） 接受一個整數，且必須具有公用`Count`屬性類型為整數。 參數以`Add`方法必須是相同的型別，傳回的`Item`屬性，或其中一個該類型的基底。 針對類別可實作<xref:System.Collections.ICollection>，擷取要序列化的值從索引`Item`屬性，不是呼叫`GetEnumerator`。  
  
 您必須擁有寫入權限的暫存目錄 （如 TEMP 環境變數所定義） 將物件還原序列化。  
  
## <a name="dynamically-generated-assemblies"></a>動態產生的組件  
 若要增加效能，XML 序列化基礎結構會動態產生序列化和還原序列化指定的類型的組件。 基礎結構會尋找並重複使用這些組件。 使用下列建構函式時，才會發生此問題：  
  
 <xref:System.Xml.Serialization.XmlSerializer.%23ctor%28System.Type%29?displayProperty=nameWithType>  
  
 <xref:System.Xml.Serialization.XmlSerializer.%23ctor%28System.Type%2CSystem.String%29?displayProperty=nameWithType>  
  
 如果您使用任何其他建構函式，會產生相同的組件的多個版本，並永遠不會卸載，而這會造成記憶體流失和效能不佳。 最簡單的解決方案是使用其中一個先前所述的兩個建構函式。 否則，您必須快取中的組件<xref:System.Collections.Hashtable>，如下列範例所示。  
  
```csharp  
Hashtable serializers = new Hashtable();  
  
// Use the constructor that takes a type and XmlRootAttribute.  
XmlSerializer s = new XmlSerializer(typeof(MyClass), myRoot);  
  
// Implement a method named GenerateKey that creates unique keys   
// for each instance of the XmlSerializer. The code should take   
// into account all parameters passed to the XmlSerializer   
// constructor.  
object key = GenerateKey(typeof(MyClass), myRoot);  
  
// Check the local cache for a matching serializer.  
XmlSerializer ser = (XmlSerializer)serializers[key];  
if (ser == null)   
{  
    ser = new XmlSerializer(typeof(MyClass), myRoot);  
    // Cache the serializer.  
    serializers[key] = ser;  
}  
else  
{  
    // Use the serializer to serialize, or deserialize.  
}  
```  
  
```vb  
Dim serializers As New Hashtable()  
  
' Use the constructor that takes a type and XmlRootAttribute.  
Dim s As New XmlSerializer(GetType([MyClass]), myRoot)  
  
' Implement a method named GenerateKey that creates unique keys   
' for each instance of the XmlSerializer. The code should take   
' into account all parameters passed to the XmlSerializer   
' constructor.  
Dim key As Object = GenerateKey(GetType([MyClass]), myRoot)  
  
' Check the local cache for a matching serializer.  
Dim ser As XmlSerializer = CType(serializers(key), XmlSerializer)  
  
If ser Is Nothing Then  
    ser = New XmlSerializer(GetType([MyClass]), myRoot)  
    ' Cache the serializer.  
    serializers(key) = ser  
Else   
    ' Use the serializer to serialize, or deserialize.  
End If  
```  
  
## <a name="serialization-of-arraylist-and-generic-list"></a>序列化的 ArrayList 和泛型清單  
 <xref:System.Xml.Serialization.XmlSerializer>無法序列化或還原序列化下：  
  
-   陣列 <xref:System.Collections.ArrayList>  
  
-   陣列 <xref:System.Collections.Generic.List%601>  
  
## <a name="serialization-of-enumerations-of-unsigned-long"></a>列舉的 Unsigned Long 的序列化  
 <xref:System.Xml.Serialization.XmlSerializer>無法具現化符合下列條件時，序列化列舉型別： 列舉型別是不帶正負號長時間的型別 (`ulong` C# 中) 和列舉型別包含任何成員的值大於9,223,372,036,854,775,807。 例如，下列不可序列化。  
  
```  
public enum LargeNumbers: ulong  
{  
    a = 9223372036854775808  
}  
// At runtime, the following code will fail.  
xmlSerializer mySerializer=new XmlSerializer(typeof(LargeNumbers));  
```  
  
## <a name="objects-marked-with-the-obsolete-attribute-no-longer-serialized"></a>標記為過時的屬性不會再序列化的物件  
 在[!INCLUDE[netfx35_short](~/includes/netfx35-short-md.md)]<xref:System.Xml.Serialization.XmlSerializer>類別不會再序列化的物件標示為`[Obsolete]`。  
  
   
  
## Examples  
 下列範例包含兩個主要類別：`PurchaseOrder`和`Test`。 `PurchaseOrder`類別包含單一訂單的相關資訊。 `Test`類別包含可建立訂單，以及讀取建立的訂單的方法。  
  
 [!code-cpp[Classic XmlSerializer Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlSerializer Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlSerializer Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlSerializer Example/CS/source.cs#1)]
 [!code-vb[Classic XmlSerializer Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlSerializer Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>此型別具備執行緒安全。</threadsafe>
    <altmember cref="T:System.Xml.Serialization.XmlAttributeOverrides" />
    <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
    <altmember cref="T:System.Xml.Serialization.XmlSerializer" />
    <altmember cref="P:System.Xml.Serialization.XmlAttributes.XmlText" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected XmlSerializer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; XmlSerializer();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 類別的新執行個體。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlSerializer (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.#ctor(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlSerializer(Type ^ type);" />
      <MemberSignature Language="F#" Value="new System.Xml.Serialization.XmlSerializer : Type -&gt; System.Xml.Serialization.XmlSerializer" Usage="new System.Xml.Serialization.XmlSerializer type" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">這個 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 可序列化的物件型別。</param>
        <summary>初始化 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 類別的新執行個體，該類別可將指定型別的物件序列化為 XML 文件，並可將 XML 文件還原序列化為指定型別的物件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一般而言，應用程式定義數個類別，<xref:System.Xml.Serialization.XmlSerializer>將轉換成單一的 XML 執行個體文件。 不過，<xref:System.Xml.Serialization.XmlSerializer>必須知道只能有一個類型-的 XML 根項目表示的類別類型。 <xref:System.Xml.Serialization.XmlSerializer>自動序列化所有的附屬類別執行個體。 同樣地，XML 根項目類型是為了還原序列化。  
  
   
  
## Examples  
 下列範例會建構<xref:System.Xml.Serialization.XmlSerializer>，將物件序列化為名為`Widget`。 此範例會設定各種屬性，然後再呼叫物件的<xref:System.Xml.Serialization.XmlSerializer.Serialize%2A>方法。  
  
 [!code-cpp[Classic XmlSerializer.XmlSerializer6 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlSerializer.XmlSerializer6 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlSerializer.XmlSerializer6 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlSerializer.XmlSerializer6 Example/CS/source.cs#1)]
 [!code-vb[Classic XmlSerializer.XmlSerializer6 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlSerializer.XmlSerializer6 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Serialization.XmlSerializer.Serialize(System.IO.TextWriter,System.Object)" />
        <altmember cref="M:System.Xml.Serialization.XmlSerializer.Deserialize(System.IO.Stream)" />
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlSerializer (System.Xml.Serialization.XmlTypeMapping xmlTypeMapping);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Serialization.XmlTypeMapping xmlTypeMapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.#ctor(System.Xml.Serialization.XmlTypeMapping)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlSerializer(System::Xml::Serialization::XmlTypeMapping ^ xmlTypeMapping);" />
      <MemberSignature Language="F#" Value="new System.Xml.Serialization.XmlSerializer : System.Xml.Serialization.XmlTypeMapping -&gt; System.Xml.Serialization.XmlSerializer" Usage="new System.Xml.Serialization.XmlSerializer xmlTypeMapping" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="xmlTypeMapping" Type="System.Xml.Serialization.XmlTypeMapping" />
      </Parameters>
      <Docs>
        <param name="xmlTypeMapping">將某個型別對應至另一個型別的 <see cref="T:System.Xml.Serialization.XmlTypeMapping" />。</param>
        <summary>使用將一個型別對應到另一個型別的物件，初始化 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 類別的執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個建構函式用來建立<xref:System.Xml.Serialization.XmlSerializer>將物件序列化成 SOAP 訊息。 若要控制產生的 SOAP 訊息，使用中找到的特殊屬性 （"Soap"這個字開頭）<xref:System.Xml.Serialization>命名空間。  
  
   
  
## Examples  
 下列範例會序列化類別，名為`Group`。 序列化`GroupName`，`IgnoreThis`欄位和成員`GroupType`列舉型別會覆寫。 在`CreateOverrideSerializer`方法，<xref:System.Xml.Serialization.SoapAttributeOverrides>物件已建立，且每個覆寫的成員或列舉型別、<xref:System.Xml.Serialization.SoapAttributes>物件使用適當的屬性設定，然後新增至建立<xref:System.Xml.Serialization.SoapAttributeOverrides>物件。 <xref:System.Xml.Serialization.XmlMapping>物件使用建立<xref:System.Xml.Serialization.SoapAttributeOverrides>物件，而且<xref:System.Xml.Serialization.XmlMapping>物件用來建立<xref:System.Xml.Serialization.XmlSerializer>會覆寫預設的序列化。  
  
 [!code-cpp[SoapAttributesOverrides#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SoapAttributesOverrides/CPP/soapover.cpp#1)]
 [!code-csharp[SoapAttributesOverrides#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SoapAttributesOverrides/CS/soapover.cs#1)]
 [!code-vb[SoapAttributesOverrides#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SoapAttributesOverrides/VB/SoapOver.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlSerializer (Type type, string defaultNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type type, string defaultNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.#ctor(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlSerializer(Type ^ type, System::String ^ defaultNamespace);" />
      <MemberSignature Language="F#" Value="new System.Xml.Serialization.XmlSerializer : Type * string -&gt; System.Xml.Serialization.XmlSerializer" Usage="new System.Xml.Serialization.XmlSerializer (type, defaultNamespace)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="defaultNamespace" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">這個 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 可序列化的物件型別。</param>
        <param name="defaultNamespace">用於所有 XML 項目的預設命名空間。</param>
        <summary>初始化 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 類別的新執行個體，該類別可將指定型別的物件序列化為 XML 文件，並可將 XML 文件還原序列化為指定型別的物件。 指定所有 XML 項目的預設命名空間。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會建構<xref:System.Xml.Serialization.XmlSerializer>，將物件序列化為名為`Widget`。 此範例會設定各種屬性，然後再呼叫物件的<xref:System.Xml.Serialization.XmlSerializer.Serialize%2A>方法。  
  
 [!code-cpp[Classic XmlSerializer.XmlSerializer1 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlSerializer.XmlSerializer1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlSerializer.XmlSerializer1 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlSerializer.XmlSerializer1 Example/CS/source.cs#1)]
 [!code-vb[Classic XmlSerializer.XmlSerializer1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlSerializer.XmlSerializer1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlSerializer (Type type, Type[] extraTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type type, class System.Type[] extraTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.#ctor(System.Type,System.Type[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlSerializer(Type ^ type, cli::array &lt;Type ^&gt; ^ extraTypes);" />
      <MemberSignature Language="F#" Value="new System.Xml.Serialization.XmlSerializer : Type * Type[] -&gt; System.Xml.Serialization.XmlSerializer" Usage="new System.Xml.Serialization.XmlSerializer (type, extraTypes)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="extraTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="type">這個 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 可序列化的物件型別。</param>
        <param name="extraTypes">要序列化之其他物件型別的 <see cref="T:System.Type" /> 陣列。</param>
        <summary>初始化 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 類別的新執行個體，該類別可將指定型別的物件序列化為 XML 文件，並可將 XML 文件還原序列化為指定型別的物件。 如果屬性或欄位傳回陣列，<paramref name="extraTypes" /> 參數就會指定可插入陣列的物件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設，如果公用屬性或欄位傳回物件或物件陣列，也都會自動序列化的物件類型。 不過，如果類別包含的欄位或屬性的傳回型別的陣列<xref:System.Object>，任何物件都可以插入該陣列。 在此情況下，<xref:System.Xml.Serialization.XmlSerializer>預期會插入到的所有可能的物件類型，必須指示<xref:System.Object>陣列。 若要這樣做，請使用`extraTypes`參數來指定要序列化或還原序列化的額外的物件類型。  
  
 您也可以使用`extraTypes`指定的型別參數衍生自基底類別。 例如，假設名為基底類別`Phone`存在，以及名為的類別`InternationalPhone`衍生自它。 使用`extraTypes`參數來指定衍生型別。  
  
   
  
## Examples  
 下列範例會序列化包含公用欄位傳回的物件陣列的類別執行個體。 `extraTypes`參數<xref:System.Xml.Serialization.XmlSerializer>建構函式會指定陣列中的可序列化的物件類型。  
  
 [!code-cpp[Classic XmlSerializer.XmlSerializer3 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlSerializer.XmlSerializer3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlSerializer.XmlSerializer3 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlSerializer.XmlSerializer3 Example/CS/source.cs#1)]
 [!code-vb[Classic XmlSerializer.XmlSerializer3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlSerializer.XmlSerializer3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlSerializer (Type type, System.Xml.Serialization.XmlAttributeOverrides overrides);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type type, class System.Xml.Serialization.XmlAttributeOverrides overrides) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.#ctor(System.Type,System.Xml.Serialization.XmlAttributeOverrides)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlSerializer(Type ^ type, System::Xml::Serialization::XmlAttributeOverrides ^ overrides);" />
      <MemberSignature Language="F#" Value="new System.Xml.Serialization.XmlSerializer : Type * System.Xml.Serialization.XmlAttributeOverrides -&gt; System.Xml.Serialization.XmlSerializer" Usage="new System.Xml.Serialization.XmlSerializer (type, overrides)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="overrides" Type="System.Xml.Serialization.XmlAttributeOverrides" />
      </Parameters>
      <Docs>
        <param name="type">要序列化的物件型別。</param>
        <param name="overrides">
          <see cref="T:System.Xml.Serialization.XmlAttributeOverrides" />。</param>
        <summary>初始化 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 類別的新執行個體，該類別可將指定型別的物件序列化為 XML 文件，並可將 XML 文件還原序列化為指定型別的物件。 每個要序列化的物件本身會包含類別執行個體，這個多載可以其他類別覆寫。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `overrides`參數可以用來控制欄位和屬性在 XML 中的編碼方式。 這些設定會覆寫已存在的物件的任何屬性。 無法修改原始碼或多個編碼所需的相同的類別時，這非常有用。  
  
   
  
## Examples  
 下列範例會序列化定義在 DLL 中，若要這樣做，請覆寫在 DLL 中找到的公用成員的類別執行個體。  
  
 [!code-cpp[Classic XmlSerializer.XmlSerializer4 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlSerializer.XmlSerializer4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlSerializer.XmlSerializer4 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlSerializer.XmlSerializer4 Example/CS/source.cs#1)]
 [!code-vb[Classic XmlSerializer.XmlSerializer4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlSerializer.XmlSerializer4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Serialization.XmlAttributeOverrides" />
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlSerializer (Type type, System.Xml.Serialization.XmlRootAttribute root);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type type, class System.Xml.Serialization.XmlRootAttribute root) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.#ctor(System.Type,System.Xml.Serialization.XmlRootAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlSerializer(Type ^ type, System::Xml::Serialization::XmlRootAttribute ^ root);" />
      <MemberSignature Language="F#" Value="new System.Xml.Serialization.XmlSerializer : Type * System.Xml.Serialization.XmlRootAttribute -&gt; System.Xml.Serialization.XmlSerializer" Usage="new System.Xml.Serialization.XmlSerializer (type, root)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="root" Type="System.Xml.Serialization.XmlRootAttribute" />
      </Parameters>
      <Docs>
        <param name="type">這個 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 可序列化的物件型別。</param>
        <param name="root">表示 XML 根項目的 <see cref="T:System.Xml.Serialization.XmlRootAttribute" />。</param>
        <summary>初始化 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 類別的新執行個體，該類別可將指定型別的物件序列化為 XML 文件，並可將 XML 文件還原序列化為指定型別的物件。 它還指定做為 XML 根項目的類別。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 XML 文件的根元素會括住所有其他項目。 根據預設，該物件指定`type`參數序列化為根項目。 屬性，例如根元素的 XML 項目名稱取自`type`物件。 不過，`root`參數可讓您藉由指定取代預設的物件資訊<xref:System.Xml.Serialization.XmlRootAttribute>; 的物件可讓您設定不同的命名空間、 項目名稱等等。  
  
   
  
## Examples  
 下列範例會建構<xref:System.Xml.Serialization.XmlSerializer>使用<xref:System.Xml.Serialization.XmlRootAttribute>，其中包含各種屬性的 XML 根項目，例如其命名空間和項目名稱。  
  
 [!code-cpp[Classic XmlSerializer.XmlSerializer2 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlSerializer.XmlSerializer2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlSerializer.XmlSerializer2 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlSerializer.XmlSerializer2 Example/CS/source.cs#1)]
 [!code-vb[Classic XmlSerializer.XmlSerializer2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlSerializer.XmlSerializer2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlSerializer (Type type, System.Xml.Serialization.XmlAttributeOverrides overrides, Type[] extraTypes, System.Xml.Serialization.XmlRootAttribute root, string defaultNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type type, class System.Xml.Serialization.XmlAttributeOverrides overrides, class System.Type[] extraTypes, class System.Xml.Serialization.XmlRootAttribute root, string defaultNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.#ctor(System.Type,System.Xml.Serialization.XmlAttributeOverrides,System.Type[],System.Xml.Serialization.XmlRootAttribute,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlSerializer(Type ^ type, System::Xml::Serialization::XmlAttributeOverrides ^ overrides, cli::array &lt;Type ^&gt; ^ extraTypes, System::Xml::Serialization::XmlRootAttribute ^ root, System::String ^ defaultNamespace);" />
      <MemberSignature Language="F#" Value="new System.Xml.Serialization.XmlSerializer : Type * System.Xml.Serialization.XmlAttributeOverrides * Type[] * System.Xml.Serialization.XmlRootAttribute * string -&gt; System.Xml.Serialization.XmlSerializer" Usage="new System.Xml.Serialization.XmlSerializer (type, overrides, extraTypes, root, defaultNamespace)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="overrides" Type="System.Xml.Serialization.XmlAttributeOverrides" />
        <Parameter Name="extraTypes" Type="System.Type[]" />
        <Parameter Name="root" Type="System.Xml.Serialization.XmlRootAttribute" />
        <Parameter Name="defaultNamespace" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">這個 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 可序列化的物件型別。</param>
        <param name="overrides">
          <see cref="T:System.Xml.Serialization.XmlAttributeOverrides" />，可延伸或覆寫在 <c>type</c> 參數中指定的類別行為。</param>
        <param name="extraTypes">要序列化之其他物件型別的 <see cref="T:System.Type" /> 陣列。</param>
        <param name="root">定義 XML 根項目屬性的 <see cref="T:System.Xml.Serialization.XmlRootAttribute" />。</param>
        <param name="defaultNamespace">XML 文件中所有 XML 項目的預設命名空間。</param>
        <summary>初始化 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 類別的新執行個體，該類別可將 <see cref="T:System.Object" /> 型別的物件序列化為 XML 文件執行個體，並可將 XML 文件執行個體還原序列化為 <see cref="T:System.Object" /> 型別的物件。 每個要序列化的物件本身都可包含類別的執行個體，這個多載會使用其他類別對其進行覆寫。 這個多載也會指定所有 XML 項目的預設命名空間，以及要做為 XML 根項目的類別。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `overrides`參數則允許建立 [XmlSerializer 建構函式 (型別，XmlAttributeOverrides，型別\<xref:System.Xml.Serialization.XmlSerializer > 可序列化類別來擴充或覆寫的行為基底類別。 例如，提供 DLL，它可建立的類別，繼承或延伸 DLL 中包含的類別。 若要序列化這種類別，您必須使用的執行個體 [XmlSerializer 建構函式 (型別，XmlAttributeOverrides，型別\<xref:System.Xml.Serialization.XmlAttributeOverrides > 類別建構 [XmlSerializer 建構函式 （時型別，XmlAttributeOverrides，型別\<xref:System.Xml.Serialization.XmlSerializer >。 如需詳細資訊，請參閱 [XmlSerializer 建構函式 (型別，XmlAttributeOverrides，型別\<xref:System.Xml.Serialization.XmlAttributeOverrides >。  
  
 根據預設，如果公用屬性或欄位傳回物件或物件陣列，也都會自動序列化的物件類型。 不過，如果類別包含的欄位或屬性的傳回類型的陣列 [XmlSerializer 建構函式 (型別，XmlAttributeOverrides，型別\<xref:System.Object >，任何物件都可以插入該陣列。 在此情況下，[XmlSerializer 建構函式 (型別，XmlAttributeOverrides，型別\<xref:System.Xml.Serialization.XmlSerializer > 預期插入 [XmlSerializer 的所有可能的物件類型，必須指示建構函式 (型別，XmlAttributeOverrides，型別\<xref:System.Object > 陣列。 若要這樣做，請使用`extraTypes`參數來指定要序列化或還原序列化的額外的物件類型。  
  
 XML 文件的根元素會括住所有其他項目。 根據預設，該物件指定`type`參數序列化為根項目。 屬性，例如根元素的 XML 項目名稱取自`type`物件。 不過，`root`參數可讓您藉由指定取代預設物件的資訊 [XmlSerializer 建構函式 (型別，XmlAttributeOverrides，型別\<xref:System.Xml.Serialization.XmlRootAttribute >;物件可讓您設定不同的命名空間、 項目名稱等等。  
  
 使用`defaultName`參數來指定所有的 XML 項目所產生的預設命名空間 [XmlSerializer 建構函式 (型別，XmlAttributeOverrides，型別\<xref:System.Xml.Serialization.XmlSerializer >。  
  
   
  
## Examples  
 下列範例會序列化定義在 DLL 中，若要這樣做，請覆寫類別中找到的公用成員的類別執行個體。 此範例也會指定額外的類型，所有的 XML 項目，並提供 XML 根項目資訊的類別使用的預設命名空間的陣列。 這個範例假設，開頭的程式碼編譯成 DLL，名為`HighSchool`。  
  
 [!code-cpp[Classic XmlSerializer.XmlSerializer Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlSerializer.XmlSerializer Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlSerializer.XmlSerializer Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlSerializer.XmlSerializer Example/CS/source.cs#1)]
 [!code-vb[Classic XmlSerializer.XmlSerializer Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlSerializer.XmlSerializer Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Serialization.XmlAttributeOverrides" />
        <altmember cref="T:System.Xml.Serialization.XmlRootAttribute" />
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlSerializer (Type type, System.Xml.Serialization.XmlAttributeOverrides overrides, Type[] extraTypes, System.Xml.Serialization.XmlRootAttribute root, string defaultNamespace, string location);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type type, class System.Xml.Serialization.XmlAttributeOverrides overrides, class System.Type[] extraTypes, class System.Xml.Serialization.XmlRootAttribute root, string defaultNamespace, string location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.#ctor(System.Type,System.Xml.Serialization.XmlAttributeOverrides,System.Type[],System.Xml.Serialization.XmlRootAttribute,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlSerializer(Type ^ type, System::Xml::Serialization::XmlAttributeOverrides ^ overrides, cli::array &lt;Type ^&gt; ^ extraTypes, System::Xml::Serialization::XmlRootAttribute ^ root, System::String ^ defaultNamespace, System::String ^ location);" />
      <MemberSignature Language="F#" Value="new System.Xml.Serialization.XmlSerializer : Type * System.Xml.Serialization.XmlAttributeOverrides * Type[] * System.Xml.Serialization.XmlRootAttribute * string * string -&gt; System.Xml.Serialization.XmlSerializer" Usage="new System.Xml.Serialization.XmlSerializer (type, overrides, extraTypes, root, defaultNamespace, location)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="overrides" Type="System.Xml.Serialization.XmlAttributeOverrides" />
        <Parameter Name="extraTypes" Type="System.Type[]" />
        <Parameter Name="root" Type="System.Xml.Serialization.XmlRootAttribute" />
        <Parameter Name="defaultNamespace" Type="System.String" />
        <Parameter Name="location" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">這個 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 可序列化的物件型別。</param>
        <param name="overrides">
          <see cref="T:System.Xml.Serialization.XmlAttributeOverrides" />，可延伸或覆寫在 <c>type</c> 參數中指定的類別行為。</param>
        <param name="extraTypes">要序列化之其他物件型別的 <see cref="T:System.Type" /> 陣列。</param>
        <param name="root">定義 XML 根項目屬性的 <see cref="T:System.Xml.Serialization.XmlRootAttribute" />。</param>
        <param name="defaultNamespace">XML 文件中所有 XML 項目的預設命名空間。</param>
        <param name="location">型別的位置。</param>
        <summary>初始化 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 類別的新執行個體，該類別可將 <see cref="T:System.Object" /> 型別的物件序列化為 XML 文件執行個體，並可將 XML 文件執行個體還原序列化為 <see cref="T:System.Object" /> 型別的物件。 每個要序列化的物件本身都可包含類別的執行個體，這個多載會使用其他類別對其進行覆寫。 這個多載也會指定所有 XML 項目的預設命名空間，以及要做為 XML 根項目的類別。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlSerializer (Type type, System.Xml.Serialization.XmlAttributeOverrides overrides, Type[] extraTypes, System.Xml.Serialization.XmlRootAttribute root, string defaultNamespace, string location, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type type, class System.Xml.Serialization.XmlAttributeOverrides overrides, class System.Type[] extraTypes, class System.Xml.Serialization.XmlRootAttribute root, string defaultNamespace, string location, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.#ctor(System.Type,System.Xml.Serialization.XmlAttributeOverrides,System.Type[],System.Xml.Serialization.XmlRootAttribute,System.String,System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlSerializer(Type ^ type, System::Xml::Serialization::XmlAttributeOverrides ^ overrides, cli::array &lt;Type ^&gt; ^ extraTypes, System::Xml::Serialization::XmlRootAttribute ^ root, System::String ^ defaultNamespace, System::String ^ location, System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="new System.Xml.Serialization.XmlSerializer : Type * System.Xml.Serialization.XmlAttributeOverrides * Type[] * System.Xml.Serialization.XmlRootAttribute * string * string * System.Security.Policy.Evidence -&gt; System.Xml.Serialization.XmlSerializer" Usage="new System.Xml.Serialization.XmlSerializer (type, overrides, extraTypes, root, defaultNamespace, location, evidence)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use a XmlSerializer constructor overload which does not take an Evidence parameter. See http://go2.microsoft.com/fwlink/?LinkId=131738 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="overrides" Type="System.Xml.Serialization.XmlAttributeOverrides" />
        <Parameter Name="extraTypes" Type="System.Type[]" />
        <Parameter Name="root" Type="System.Xml.Serialization.XmlRootAttribute" />
        <Parameter Name="defaultNamespace" Type="System.String" />
        <Parameter Name="location" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="type">這個 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 可序列化的物件型別。</param>
        <param name="overrides">
          <see cref="T:System.Xml.Serialization.XmlAttributeOverrides" />，可延伸或覆寫在 <c>type</c> 參數中指定的類別行為。</param>
        <param name="extraTypes">要序列化之其他物件型別的 <see cref="T:System.Type" /> 陣列。</param>
        <param name="root">定義 XML 根項目屬性的 <see cref="T:System.Xml.Serialization.XmlRootAttribute" />。</param>
        <param name="defaultNamespace">XML 文件中所有 XML 項目的預設命名空間。</param>
        <param name="location">型別的位置。</param>
        <param name="evidence">
          <see cref="T:System.Security.Policy.Evidence" /> 類別的執行個體，包含存取型別所需的認證。</param>
        <summary>初始化 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 類別的新執行個體，該類別可將指定型別的物件序列化為 XML 文件執行個體，並可將 XML 文件執行個體還原序列化為指定型別的物件。 這個多載可讓您提供序列化或還原序列化作業期間遇到的其他型別，以及所有 XML 項目的預設命名空間、用做 XML 根項目的類別及其位置，和存取所需的認證。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 讓暫存目錄的存取權的更精確地控制，並防止程式碼資料隱碼攻擊和入侵。 若要使用此方法，指定的位置，只讓特定使用者存取。 系統管理員可以設定原則與符合的權限的辨識項的辨識項清單。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanDeserialize">
      <MemberSignature Language="C#" Value="public virtual bool CanDeserialize (System.Xml.XmlReader xmlReader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanDeserialize(class System.Xml.XmlReader xmlReader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.CanDeserialize(System.Xml.XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanDeserialize(System::Xml::XmlReader ^ xmlReader);" />
      <MemberSignature Language="F#" Value="abstract member CanDeserialize : System.Xml.XmlReader -&gt; bool&#xA;override this.CanDeserialize : System.Xml.XmlReader -&gt; bool" Usage="xmlSerializer.CanDeserialize xmlReader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xmlReader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="xmlReader">
          <see cref="T:System.Xml.XmlReader" />，指向要還原序列化的文件。</param>
        <summary>取得值，指出這個 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 是否可以還原序列化指定的 XML 文件。</summary>
        <returns>如果這個 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 可以還原序列化 <see cref="T:System.Xml.XmlReader" /> 所指向的物件，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會呼叫<xref:System.Xml.Serialization.XmlSerializer.CanDeserialize%2A>方法來檢查是否可以還原序列化的 XML 文件。  
  
 [!code-cpp[Classic XmlSerializer.CanDeserialize Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlSerializer.CanDeserialize Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlSerializer.CanDeserialize Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlSerializer.CanDeserialize Example/CS/source.cs#1)]
 [!code-vb[Classic XmlSerializer.CanDeserialize Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlSerializer.CanDeserialize Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Serialization.XmlSerializer.Deserialize(System.IO.Stream)" />
      </Docs>
    </Member>
    <Member MemberName="CreateReader">
      <MemberSignature Language="C#" Value="protected virtual System.Xml.Serialization.XmlSerializationReader CreateReader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xml.Serialization.XmlSerializationReader CreateReader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.CreateReader" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateReader () As XmlSerializationReader" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xml::Serialization::XmlSerializationReader ^ CreateReader();" />
      <MemberSignature Language="F#" Value="abstract member CreateReader : unit -&gt; System.Xml.Serialization.XmlSerializationReader&#xA;override this.CreateReader : unit -&gt; System.Xml.Serialization.XmlSerializationReader" Usage="xmlSerializer.CreateReader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Serialization.XmlSerializationReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回物件，該物件用於讀取要序列化的 XML 文件。</summary>
        <returns>
          <see cref="T:System.Xml.Serialization.XmlSerializationReader" />，用於讀取 XML 文件。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">當方法在子代類別中未覆寫時，會嘗試存取該方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateWriter">
      <MemberSignature Language="C#" Value="protected virtual System.Xml.Serialization.XmlSerializationWriter CreateWriter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xml.Serialization.XmlSerializationWriter CreateWriter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.CreateWriter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateWriter () As XmlSerializationWriter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xml::Serialization::XmlSerializationWriter ^ CreateWriter();" />
      <MemberSignature Language="F#" Value="abstract member CreateWriter : unit -&gt; System.Xml.Serialization.XmlSerializationWriter&#xA;override this.CreateWriter : unit -&gt; System.Xml.Serialization.XmlSerializationWriter" Usage="xmlSerializer.CreateWriter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Serialization.XmlSerializationWriter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中覆寫時，傳回用於序列化物件的寫入器。</summary>
        <returns>實作 <see cref="T:System.Xml.Serialization.XmlSerializationWriter" /> 類別的執行個體。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">當方法在子代類別中未覆寫時，會嘗試存取該方法。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Deserialize">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將 XML 文件還原序列化。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Deserialize">
      <MemberSignature Language="C#" Value="public object Deserialize (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Deserialize(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.Deserialize(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Deserialize(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.Deserialize : System.IO.Stream -&gt; obj" Usage="xmlSerializer.Deserialize stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">
          <see cref="T:System.IO.Stream" />，包含要還原序列化的 XML 文件。</param>
        <summary>還原序列化指定 <see cref="T:System.IO.Stream" /> 所包含的 XML 文件。</summary>
        <returns>要進行還原序列化的 <see cref="T:System.Object" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 還原序列化是讀取 XML 文件，並建構的物件已強類型到 XML 結構描述 (XSD) 文件的程序。  
  
 還原序列化時之前,<xref:System.Xml.Serialization.XmlSerializer>必須使用正在還原序列化的物件型別建構。  
  
 使用`stream`參數來指定物件衍生自<xref:System.IO.Stream>類別，其設計目的是要寫入資料流。 類別衍生自<xref:System.IO.Stream>類別包括：  
  
-   <xref:System.IO.BufferedStream>  
  
-   <xref:System.IO.FileStream>  
  
-   <xref:System.IO.MemoryStream>  
  
-   <xref:System.Net.Sockets.NetworkStream>  
  
-   <xref:System.Security.Cryptography.CryptoStream>  
  
> [!NOTE]
>  <xref:System.Xml.Serialization.XmlSerializer>無法還原序列化下： 陣列<xref:System.Collections.ArrayList>和陣列<xref:System.Collections.Generic.List%601>。  
  
   
  
## Examples  
 下列範例會還原序列化的物件使用<xref:System.IO.Stream>物件。  
  
 [!code-cpp[Classic XmlSerializer.Deserialize Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlSerializer.Deserialize Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlSerializer.Deserialize Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlSerializer.Deserialize Example/CS/source.cs#1)]
 [!code-vb[Classic XmlSerializer.Deserialize Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlSerializer.Deserialize Example/VB/source.vb#1)]
 [!code-xml[Classic XmlSerializer.Deserialize Example#1](~/samples/snippets/common/VS_Snippets_Remoting/Classic XmlSerializer.Deserialize Example/Common/simple.xml#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
        <altmember cref="M:System.Xml.Serialization.XmlSerializer.CanDeserialize(System.Xml.XmlReader)" />
        <altmember cref="M:System.Xml.Serialization.XmlSerializer.Serialize(System.IO.TextWriter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Deserialize">
      <MemberSignature Language="C#" Value="public object Deserialize (System.IO.TextReader textReader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Deserialize(class System.IO.TextReader textReader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.Deserialize(System.IO.TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Deserialize(System::IO::TextReader ^ textReader);" />
      <MemberSignature Language="F#" Value="member this.Deserialize : System.IO.TextReader -&gt; obj" Usage="xmlSerializer.Deserialize textReader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textReader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="textReader">
          <see cref="T:System.IO.TextReader" />，包含要還原序列化的 XML 文件。</param>
        <summary>還原序列化指定 <see cref="T:System.IO.TextReader" /> 所包含的 XML 文件。</summary>
        <returns>要進行還原序列化的 <see cref="T:System.Object" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 還原序列化是讀取 XML 文件的執行個體，並建構物件，強型別至 XML 結構描述 (XSD) 文件的程序。  
  
 還原序列化時之前,<xref:System.Xml.Serialization.XmlSerializer>必須使用正在還原序列化的物件型別建構。  
  
 類別繼承自<xref:System.IO.TextReader>包含<xref:System.IO.StringReader>和<xref:System.IO.StreamReader>。 如果您使用<xref:System.IO.StreamReader>物件還原序列化，您必須建構<xref:System.IO.StreamReader>以適當<xref:System.Text.Encoding>。 已忽略指定的 XML 文件的編碼方式。  
  
> [!NOTE]
>  若要使用指定的 XML 文件的編碼方式，使用<xref:System.Xml.Serialization.XmlSerializer.Deserialize%2A>採用多載<xref:System.Xml.XmlReader>改為。 <xref:System.Xml.XmlReader>自動偵測及使用指定的 XML 文件的編碼方式。  
  
> [!NOTE]
>  <xref:System.Xml.Serialization.XmlSerializer>無法還原序列化下： 陣列<xref:System.Collections.ArrayList>和陣列<xref:System.Collections.Generic.List%601>。  
  
   
  
## Examples  
 下列範例會還原序列化的物件使用<xref:System.IO.TextReader>物件。  
  
 [!code-cpp[Classic XmlSerializer.Deserialize1 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlSerializer.Deserialize1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlSerializer.Deserialize1 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlSerializer.Deserialize1 Example/CS/source.cs#1)]
 [!code-vb[Classic XmlSerializer.Deserialize1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlSerializer.Deserialize1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在還原序列化期間發生錯誤。 可以使用 <see cref="P:System.Exception.InnerException" /> 屬性取得原始例外狀況。</exception>
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
        <altmember cref="M:System.Xml.Serialization.XmlSerializer.CanDeserialize(System.Xml.XmlReader)" />
        <altmember cref="M:System.Xml.Serialization.XmlSerializer.Serialize(System.IO.TextWriter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Deserialize">
      <MemberSignature Language="C#" Value="protected virtual object Deserialize (System.Xml.Serialization.XmlSerializationReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object Deserialize(class System.Xml.Serialization.XmlSerializationReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.Deserialize(System.Xml.Serialization.XmlSerializationReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Deserialize (reader As XmlSerializationReader) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ Deserialize(System::Xml::Serialization::XmlSerializationReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member Deserialize : System.Xml.Serialization.XmlSerializationReader -&gt; obj&#xA;override this.Deserialize : System.Xml.Serialization.XmlSerializationReader -&gt; obj" Usage="xmlSerializer.Deserialize reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.Serialization.XmlSerializationReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.Serialization.XmlSerializationReader" />，包含要還原序列化的 XML 文件。</param>
        <summary>還原序列化指定 <see cref="T:System.Xml.Serialization.XmlSerializationReader" /> 所包含的 XML 文件。</summary>
        <returns>已還原序列化的物件。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">當方法在子代類別中未覆寫時，會嘗試存取該方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="Deserialize">
      <MemberSignature Language="C#" Value="public object Deserialize (System.Xml.XmlReader xmlReader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Deserialize(class System.Xml.XmlReader xmlReader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.Deserialize(System.Xml.XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Deserialize(System::Xml::XmlReader ^ xmlReader);" />
      <MemberSignature Language="F#" Value="member this.Deserialize : System.Xml.XmlReader -&gt; obj" Usage="xmlSerializer.Deserialize xmlReader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xmlReader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="xmlReader">
          <see cref="T:System.Xml.XmlReader" />，包含要還原序列化的 XML 文件。</param>
        <summary>還原序列化指定 <see cref="T:System.Xml.XmlReader" /> 所包含的 XML 文件。</summary>
        <returns>要進行還原序列化的 <see cref="T:System.Object" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 還原序列化是讀取 XML 文件的執行個體，並建構物件，強型別至 XML 結構描述 (XSD) 文件的程序。  
  
 還原序列化時之前,<xref:System.Xml.Serialization.XmlSerializer>必須使用正在還原序列化的物件型別建構。  
  
 <xref:System.Xml.XmlReader>自動偵測及使用指定的 XML 文件的編碼方式。  
  
> [!NOTE]
>  <xref:System.Xml.Serialization.XmlSerializer>無法還原序列化下： 陣列<xref:System.Collections.ArrayList>和陣列<xref:System.Collections.Generic.List%601>。  
  
   
  
## Examples  
 下列範例會還原序列化的物件使用<xref:System.Xml.XmlReader>。  
  
 [!code-cpp[Classic XmlSerializer.Deserialize2 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlSerializer.Deserialize2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlSerializer.Deserialize2 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlSerializer.Deserialize2 Example/CS/source.cs#1)]
 [!code-vb[Classic XmlSerializer.Deserialize2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlSerializer.Deserialize2 Example/VB/source.vb#1)]
 [!code-xml[Classic XmlSerializer.Deserialize2 Example#1](~/samples/snippets/common/VS_Snippets_Remoting/Classic XmlSerializer.Deserialize2 Example/Common/simple.xml#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在還原序列化期間發生錯誤。 可以使用 <see cref="P:System.Exception.InnerException" /> 屬性取得原始例外狀況。</exception>
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
        <altmember cref="M:System.Xml.Serialization.XmlSerializer.CanDeserialize(System.Xml.XmlReader)" />
        <altmember cref="M:System.Xml.Serialization.XmlSerializer.Serialize(System.IO.TextWriter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Deserialize">
      <MemberSignature Language="C#" Value="public object Deserialize (System.Xml.XmlReader xmlReader, string encodingStyle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Deserialize(class System.Xml.XmlReader xmlReader, string encodingStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.Deserialize(System.Xml.XmlReader,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Deserialize(System::Xml::XmlReader ^ xmlReader, System::String ^ encodingStyle);" />
      <MemberSignature Language="F#" Value="member this.Deserialize : System.Xml.XmlReader * string -&gt; obj" Usage="xmlSerializer.Deserialize (xmlReader, encodingStyle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xmlReader" Type="System.Xml.XmlReader" />
        <Parameter Name="encodingStyle" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xmlReader">
          <see cref="T:System.Xml.XmlReader" />，包含要還原序列化的 XML 文件。</param>
        <param name="encodingStyle">序列化 XML 的編碼樣式。</param>
        <summary>還原序列化指定 <see cref="T:System.Xml.XmlReader" /> 和編碼樣式所包含的 XML 文件。</summary>
        <returns>已還原序列化的物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 還原序列化是讀取 XML 文件的執行個體，並建構物件，強型別至 XML 結構描述 (XSD) 文件的程序。  
  
 還原序列化時之前,<xref:System.Xml.Serialization.XmlSerializer>必須使用正在還原序列化的物件型別建構。  
  
 設定`encodingStyle`參數 」http://schemas.xmlsoap.org/soap/encoding/ "如 SOAP 1.1 版的編碼。否則，將它設定為"http://www.w3.org/2001/12/soap-encoding"SOAP 1.2 編碼方式。  
  
 **請注意**<xref:System.Xml.Serialization.XmlSerializer>無法還原序列化下： 陣列<xref:System.Collections.ArrayList>和陣列<xref:System.Collections.Generic.List%601>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在還原序列化期間發生錯誤。 可以使用 <see cref="P:System.Exception.InnerException" /> 屬性取得原始例外狀況。</exception>
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
        <altmember cref="M:System.Xml.Serialization.XmlSerializer.CanDeserialize(System.Xml.XmlReader)" />
        <altmember cref="M:System.Xml.Serialization.XmlSerializer.Serialize(System.IO.TextWriter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Deserialize">
      <MemberSignature Language="C#" Value="public object Deserialize (System.Xml.XmlReader xmlReader, System.Xml.Serialization.XmlDeserializationEvents events);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Deserialize(class System.Xml.XmlReader xmlReader, valuetype System.Xml.Serialization.XmlDeserializationEvents events) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.Deserialize(System.Xml.XmlReader,System.Xml.Serialization.XmlDeserializationEvents)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Deserialize(System::Xml::XmlReader ^ xmlReader, System::Xml::Serialization::XmlDeserializationEvents events);" />
      <MemberSignature Language="F#" Value="member this.Deserialize : System.Xml.XmlReader * System.Xml.Serialization.XmlDeserializationEvents -&gt; obj" Usage="xmlSerializer.Deserialize (xmlReader, events)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xmlReader" Type="System.Xml.XmlReader" />
        <Parameter Name="events" Type="System.Xml.Serialization.XmlDeserializationEvents" />
      </Parameters>
      <Docs>
        <param name="xmlReader">
          <see cref="T:System.Xml.XmlReader" />，包含要還原序列化的文件。</param>
        <param name="events">
          <see cref="T:System.Xml.Serialization.XmlDeserializationEvents" /> 類別的執行個體。</param>
        <summary>還原序列化指定 <see cref="T:System.Xml.XmlReader" /> 包含的 XML 文件，並允許覆寫還原序列化期間發生的事件。</summary>
        <returns>要進行還原序列化的 <see cref="T:System.Object" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 正在還原序列化的物件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Deserialize">
      <MemberSignature Language="C#" Value="public object Deserialize (System.Xml.XmlReader xmlReader, string encodingStyle, System.Xml.Serialization.XmlDeserializationEvents events);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Deserialize(class System.Xml.XmlReader xmlReader, string encodingStyle, valuetype System.Xml.Serialization.XmlDeserializationEvents events) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.Deserialize(System.Xml.XmlReader,System.String,System.Xml.Serialization.XmlDeserializationEvents)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Deserialize(System::Xml::XmlReader ^ xmlReader, System::String ^ encodingStyle, System::Xml::Serialization::XmlDeserializationEvents events);" />
      <MemberSignature Language="F#" Value="member this.Deserialize : System.Xml.XmlReader * string * System.Xml.Serialization.XmlDeserializationEvents -&gt; obj" Usage="xmlSerializer.Deserialize (xmlReader, encodingStyle, events)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xmlReader" Type="System.Xml.XmlReader" />
        <Parameter Name="encodingStyle" Type="System.String" />
        <Parameter Name="events" Type="System.Xml.Serialization.XmlDeserializationEvents" />
      </Parameters>
      <Docs>
        <param name="xmlReader">
          <see cref="T:System.Xml.XmlReader" /> 類別的執行個體，用於讀取文件。</param>
        <param name="encodingStyle">使用的編碼方式。</param>
        <param name="events">
          <see cref="T:System.Xml.Serialization.XmlDeserializationEvents" /> 類別的執行個體。</param>
        <summary>使用指定 <see cref="T:System.Xml.XmlReader" /> 包含的資料，還原序列化物件。</summary>
        <returns>正在還原序列化的物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法是序列化的未知標頭的 Web 服務案例所需的項目。 這個方法可讓您避免在 Web 服務方法的事件同步處理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="FromMappings">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回指定對應的 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 類別執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FromMappings">
      <MemberSignature Language="C#" Value="public static System.Xml.Serialization.XmlSerializer[] FromMappings (System.Xml.Serialization.XmlMapping[] mappings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Serialization.XmlSerializer[] FromMappings(class System.Xml.Serialization.XmlMapping[] mappings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.FromMappings(System.Xml.Serialization.XmlMapping[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromMappings (mappings As XmlMapping()) As XmlSerializer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Xml::Serialization::XmlSerializer ^&gt; ^ FromMappings(cli::array &lt;System::Xml::Serialization::XmlMapping ^&gt; ^ mappings);" />
      <MemberSignature Language="F#" Value="static member FromMappings : System.Xml.Serialization.XmlMapping[] -&gt; System.Xml.Serialization.XmlSerializer[]" Usage="System.Xml.Serialization.XmlSerializer.FromMappings mappings" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Serialization.XmlSerializer[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mappings" Type="System.Xml.Serialization.XmlMapping[]" />
      </Parameters>
      <Docs>
        <param name="mappings">
          <see cref="T:System.Xml.Serialization.XmlTypeMapping" /> 陣列，將一個型別對應至另一個型別。</param>
        <summary>傳回建立自 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 物件陣列的 <see cref="T:System.Xml.Serialization.XmlTypeMapping" /> 物件陣列。</summary>
        <returns>
          <see cref="T:System.Xml.Serialization.XmlSerializer" /> 物件的陣列。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromMappings">
      <MemberSignature Language="C#" Value="public static System.Xml.Serialization.XmlSerializer[] FromMappings (System.Xml.Serialization.XmlMapping[] mappings, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Serialization.XmlSerializer[] FromMappings(class System.Xml.Serialization.XmlMapping[] mappings, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.FromMappings(System.Xml.Serialization.XmlMapping[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Xml::Serialization::XmlSerializer ^&gt; ^ FromMappings(cli::array &lt;System::Xml::Serialization::XmlMapping ^&gt; ^ mappings, System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="static member FromMappings : System.Xml.Serialization.XmlMapping[] * System.Security.Policy.Evidence -&gt; System.Xml.Serialization.XmlSerializer[]" Usage="System.Xml.Serialization.XmlSerializer.FromMappings (mappings, evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of FromMappings which does not take an Evidence parameter. See http://go2.microsoft.com/fwlink/?LinkId=131738 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Serialization.XmlSerializer[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mappings" Type="System.Xml.Serialization.XmlMapping[]" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="mappings">
          <see cref="T:System.Xml.Serialization.XmlMapping" /> 物件的陣列，用於將一個型別對應至另一個型別。</param>
        <param name="evidence">
          <see cref="T:System.Security.Policy.Evidence" /> 類別的執行個體，包含顯示到 Common Language Runtime 原則系統的裝載和組件資料。</param>
        <summary>傳回 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 類別的執行個體，該執行個體建立自一個 XML 型別至另一個 XML 型別的對應。</summary>
        <returns>
          <see cref="T:System.Xml.Serialization.XmlSerializer" /> 類別的執行個體。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromMappings">
      <MemberSignature Language="C#" Value="public static System.Xml.Serialization.XmlSerializer[] FromMappings (System.Xml.Serialization.XmlMapping[] mappings, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Serialization.XmlSerializer[] FromMappings(class System.Xml.Serialization.XmlMapping[] mappings, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.FromMappings(System.Xml.Serialization.XmlMapping[],System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Xml::Serialization::XmlSerializer ^&gt; ^ FromMappings(cli::array &lt;System::Xml::Serialization::XmlMapping ^&gt; ^ mappings, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member FromMappings : System.Xml.Serialization.XmlMapping[] * Type -&gt; System.Xml.Serialization.XmlSerializer[]" Usage="System.Xml.Serialization.XmlSerializer.FromMappings (mappings, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Serialization.XmlSerializer[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mappings" Type="System.Xml.Serialization.XmlMapping[]" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="mappings">
          <see cref="T:System.Xml.Serialization.XmlMapping" /> 物件的陣列。</param>
        <param name="type">還原序列化物件的 <see cref="T:System.Type" />。</param>
        <summary>傳回指定對應的 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 類別執行個體。</summary>
        <returns>
          <see cref="T:System.Xml.Serialization.XmlSerializer" /> 類別的執行個體。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromTypes">
      <MemberSignature Language="C#" Value="public static System.Xml.Serialization.XmlSerializer[] FromTypes (Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Serialization.XmlSerializer[] FromTypes(class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.FromTypes(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromTypes (types As Type()) As XmlSerializer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Xml::Serialization::XmlSerializer ^&gt; ^ FromTypes(cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="static member FromTypes : Type[] -&gt; System.Xml.Serialization.XmlSerializer[]" Usage="System.Xml.Serialization.XmlSerializer.FromTypes types" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Serialization.XmlSerializer[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="types">
          <see cref="T:System.Type" /> 物件的陣列。</param>
        <summary>傳回由型別陣列建立的 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 物件的陣列。</summary>
        <returns>
          <see cref="T:System.Xml.Serialization.XmlSerializer" /> 物件的陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.Serialization.XmlSerializer.FromTypes%2A>方法可讓您有效率地建立陣列<xref:System.Xml.Serialization.XmlSerializer>物件來處理陣列<xref:System.Type>物件。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Xml.Serialization.XmlSerializer.FromTypes%2A>方法傳回的陣列<xref:System.Xml.Serialization.XmlSerializer>物件。 程式碼包含三個類別定義，每個可用來建立陣列<xref:System.Type>物件。  
  
 [!code-cpp[Classic XmlSerializer.FromTypes Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlSerializer.FromTypes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlSerializer.FromTypes Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlSerializer.FromTypes Example/CS/source.cs#1)]
 [!code-vb[Classic XmlSerializer.FromTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlSerializer.FromTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GenerateSerializer">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回包含具型別序列化程式的組件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [XML 序列化程式產生器工具 (Sgen.exe)](~/docs/standard/serialization/xml-serializer-generator-tool-sgen-exe.md)建立類型的 XML 序列化組件中指定的組件，以改善的執行階段效能<xref:System.Xml.Serialization.XmlSerializer>當序列化或還原序列化的物件指定的型別。 使用<xref:System.Xml.Serialization.XmlSerializer.GetXmlSerializerAssemblyName%2A>傳回這類組件的名稱。  
  
 如果您正在散發這類組件做為呼叫 Web 服務用戶端應用程式的一部分，您可以套用<xref:System.Xml.Serialization.XmlSerializerAssemblyAttribute>加入用戶端類型，以指定的位置和名稱的組件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GenerateSerializer">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GenerateSerializer (Type[] types, System.Xml.Serialization.XmlMapping[] mappings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GenerateSerializer(class System.Type[] types, class System.Xml.Serialization.XmlMapping[] mappings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.GenerateSerializer(System.Type[],System.Xml.Serialization.XmlMapping[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GenerateSerializer (types As Type(), mappings As XmlMapping()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GenerateSerializer(cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Xml::Serialization::XmlMapping ^&gt; ^ mappings);" />
      <MemberSignature Language="F#" Value="static member GenerateSerializer : Type[] * System.Xml.Serialization.XmlMapping[] -&gt; System.Reflection.Assembly" Usage="System.Xml.Serialization.XmlSerializer.GenerateSerializer (types, mappings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="mappings" Type="System.Xml.Serialization.XmlMapping[]" />
      </Parameters>
      <Docs>
        <param name="types">型別集合。</param>
        <param name="mappings">
          <see cref="T:System.Xml.Serialization.XmlMapping" /> 物件集合，用於將一個型別轉換為另一個型別。</param>
        <summary>使用指定的對應傳回組件，該組件包含自訂序列化程式，用於序列化或還原序列化指定的型別。</summary>
        <returns>
          <see cref="T:System.Reflection.Assembly" /> 物件，包含所提供型別和對應的序列化程式。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GenerateSerializer">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GenerateSerializer (Type[] types, System.Xml.Serialization.XmlMapping[] mappings, System.CodeDom.Compiler.CompilerParameters parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GenerateSerializer(class System.Type[] types, class System.Xml.Serialization.XmlMapping[] mappings, class System.CodeDom.Compiler.CompilerParameters parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.GenerateSerializer(System.Type[],System.Xml.Serialization.XmlMapping[],System.CodeDom.Compiler.CompilerParameters)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GenerateSerializer (types As Type(), mappings As XmlMapping(), parameters As CompilerParameters) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GenerateSerializer(cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Xml::Serialization::XmlMapping ^&gt; ^ mappings, System::CodeDom::Compiler::CompilerParameters ^ parameters);" />
      <MemberSignature Language="F#" Value="static member GenerateSerializer : Type[] * System.Xml.Serialization.XmlMapping[] * System.CodeDom.Compiler.CompilerParameters -&gt; System.Reflection.Assembly" Usage="System.Xml.Serialization.XmlSerializer.GenerateSerializer (types, mappings, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="mappings" Type="System.Xml.Serialization.XmlMapping[]" />
        <Parameter Name="parameters" Type="System.CodeDom.Compiler.CompilerParameters" />
      </Parameters>
      <Docs>
        <param name="types">型別 <see cref="T:System.Type" /> 的陣列，包含用於序列化和還原序列化資料的物件。</param>
        <param name="mappings">型別 <see cref="T:System.Xml.Serialization.XmlMapping" /> 的陣列，將 XML 資料對應至型別資料。</param>
        <param name="parameters">
          <see cref="T:System.CodeDom.Compiler.CompilerParameters" /> 類別的執行個體，表示用於叫用編譯器的參數。</param>
        <summary>使用指定的對應、編譯器設定和選項傳回組件，該組件包含自訂序列化程式，用於序列化或還原序列化指定的型別。</summary>
        <returns>
          <see cref="T:System.Reflection.Assembly" />，包含 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 的特殊版本。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetXmlSerializerAssemblyName">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回組件名稱，該組件包含一個或多個 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 版本，是為序列化或還原序列化特定型別建立的。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [XML 序列化程式產生器工具 (Sgen.exe)](~/docs/standard/serialization/xml-serializer-generator-tool-sgen-exe.md)建立類型的 XML 序列化組件中指定的組件，以改善的執行階段效能<xref:System.Xml.Serialization.XmlSerializer>當序列化或還原序列化的物件指定的型別。 使用<xref:System.Xml.Serialization.XmlSerializer.GetXmlSerializerAssemblyName%2A>傳回這類組件的名稱。  
  
 如果您正在散發這類組件做為呼叫 Web 服務用戶端應用程式的一部分，您可以套用<xref:System.Xml.Serialization.XmlSerializerAssemblyAttribute>加入用戶端類型，以指定的位置和名稱的組件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetXmlSerializerAssemblyName">
      <MemberSignature Language="C#" Value="public static string GetXmlSerializerAssemblyName (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetXmlSerializerAssemblyName(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.GetXmlSerializerAssemblyName(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetXmlSerializerAssemblyName(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetXmlSerializerAssemblyName : Type -&gt; string" Usage="System.Xml.Serialization.XmlSerializer.GetXmlSerializerAssemblyName type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">正在還原序列化的 <see cref="T:System.Type" />。</param>
        <summary>傳回組件名稱，該組件包含一個或多個 <see cref="T:System.Xml.Serialization.XmlSerializer" /> 版本，是為序列化或還原序列化特定型別建立的。</summary>
        <returns>組件名稱，該組件包含型別的 <see cref="T:System.Xml.Serialization.XmlSerializer" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [XML 序列化程式產生器工具 (Sgen.exe)](~/docs/standard/serialization/xml-serializer-generator-tool-sgen-exe.md)建立類型的 XML 序列化組件中指定的組件，以改善的執行階段效能<xref:System.Xml.Serialization.XmlSerializer>當序列化或還原序列化的物件指定的型別。 使用<xref:System.Xml.Serialization.XmlSerializer.GetXmlSerializerAssemblyName%2A>傳回這類組件的名稱。  
  
 如果您正在散發這類組件做為呼叫 Web 服務用戶端應用程式的一部分，您可以套用<xref:System.Xml.Serialization.XmlSerializerAssemblyAttribute>加入用戶端類型，以指定的位置和名稱的組件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXmlSerializerAssemblyName">
      <MemberSignature Language="C#" Value="public static string GetXmlSerializerAssemblyName (Type type, string defaultNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetXmlSerializerAssemblyName(class System.Type type, string defaultNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.GetXmlSerializerAssemblyName(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetXmlSerializerAssemblyName(Type ^ type, System::String ^ defaultNamespace);" />
      <MemberSignature Language="F#" Value="static member GetXmlSerializerAssemblyName : Type * string -&gt; string" Usage="System.Xml.Serialization.XmlSerializer.GetXmlSerializerAssemblyName (type, defaultNamespace)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="defaultNamespace" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">您所要的 <see cref="T:System.Type" />。</param>
        <param name="defaultNamespace">型別的命名空間。</param>
        <summary>傳回組件名稱，該組件包含指定命名空間中指定型別的序列化程式。</summary>
        <returns>組件名稱，該組件包含特別建置的序列化程式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [XML 序列化程式產生器工具 (Sgen.exe)](~/docs/standard/serialization/xml-serializer-generator-tool-sgen-exe.md)建立類型的 XML 序列化組件中指定的組件，以改善的執行階段效能<xref:System.Xml.Serialization.XmlSerializer>當序列化或還原序列化的物件指定的型別。 使用<xref:System.Xml.Serialization.XmlSerializer.GetXmlSerializerAssemblyName%2A>傳回這類組件的名稱。  
  
 如果您正在散發這類組件做為呼叫 Web 服務用戶端應用程式的一部分，您可以套用<xref:System.Xml.Serialization.XmlSerializerAssemblyAttribute>加入用戶端類型，以指定的位置和名稱的組件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Serialize">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將物件序列化成為 XML 文件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Serialize">
      <MemberSignature Language="C#" Value="public void Serialize (System.IO.Stream stream, object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Serialize(class System.IO.Stream stream, object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.Serialize(System.IO.Stream,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Serialize(System::IO::Stream ^ stream, System::Object ^ o);" />
      <MemberSignature Language="F#" Value="member this.Serialize : System.IO.Stream * obj -&gt; unit" Usage="xmlSerializer.Serialize (stream, o)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="stream">用來寫入 XML 文件的 <see cref="T:System.IO.Stream" />。</param>
        <param name="o">要序列化的 <see cref="T:System.Object" />。</param>
        <summary>序列化指定的 <see cref="T:System.Object" />，並使用指定的 <see cref="T:System.IO.Stream" /> 將 XML 文件寫入檔案。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.Serialization.XmlSerializer.Serialize%2A>方法會將公用欄位和讀取/寫入屬性的物件轉換成 XML。 它不會轉換方法、 索引子、 私用欄位或唯讀屬性。 若要序列化的所有物件的欄位和屬性，公用和私用，使用<xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>。  
  
 在`stream`參數，指定物件衍生自抽象<xref:System.IO.Stream>類別。 類別衍生自<xref:System.IO.Stream>包括：  
  
-   <xref:System.IO.BufferedStream>  
  
-   <xref:System.IO.FileStream>  
  
-   <xref:System.IO.MemoryStream>  
  
-   <xref:System.Net.Sockets.NetworkStream>  
  
-   <xref:System.Security.Cryptography.CryptoStream>  
  
> [!NOTE]
>  <xref:System.Xml.Serialization.XmlSerializer>無法序列化下： 陣列<xref:System.Collections.ArrayList>和陣列<xref:System.Collections.Generic.List%601>。  
  
   
  
## Examples  
 下列範例會序列化物件使用<xref:System.IO.Stream>物件。  
  
 [!code-cpp[Classic XmlSerializer.Serialize2 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlSerializer.Serialize2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlSerializer.Serialize2 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlSerializer.Serialize2 Example/CS/source.cs#1)]
 [!code-vb[Classic XmlSerializer.Serialize2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlSerializer.Serialize2 Example/VB/source.vb#1)]
 [!code-xml[Classic XmlSerializer.Serialize2 Example#1](~/samples/snippets/common/VS_Snippets_Remoting/Classic XmlSerializer.Serialize2 Example/Common/simple.xml#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在序列化期間發生錯誤。 可以使用 <see cref="P:System.Exception.InnerException" /> 屬性取得原始例外狀況。</exception>
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
        <altmember cref="M:System.Xml.Serialization.XmlSerializer.Deserialize(System.IO.Stream)" />
      </Docs>
    </Member>
    <Member MemberName="Serialize">
      <MemberSignature Language="C#" Value="public void Serialize (System.IO.TextWriter textWriter, object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Serialize(class System.IO.TextWriter textWriter, object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.Serialize(System.IO.TextWriter,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Serialize(System::IO::TextWriter ^ textWriter, System::Object ^ o);" />
      <MemberSignature Language="F#" Value="member this.Serialize : System.IO.TextWriter * obj -&gt; unit" Usage="xmlSerializer.Serialize (textWriter, o)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textWriter" Type="System.IO.TextWriter" />
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="textWriter">用來寫入 XML 文件的 <see cref="T:System.IO.TextWriter" />。</param>
        <param name="o">要序列化的 <see cref="T:System.Object" />。</param>
        <summary>序列化指定的 <see cref="T:System.Object" />，並使用指定的 <see cref="T:System.IO.TextWriter" /> 將 XML 文件寫入檔案。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.Serialization.XmlSerializer.Serialize%2A>方法會將公用欄位和讀取/寫入屬性的物件轉換成 XML。 它不會轉換方法、 索引子、 私用欄位或唯讀屬性。 若要序列化為物件的所有欄位和屬性，公用和私用，使用<xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>。  
  
 在`textWriter`參數，指定物件衍生自抽象<xref:System.IO.TextWriter>類別。 類別衍生自<xref:System.IO.TextWriter>包括：  
  
-   <xref:System.IO.StreamWriter>  
  
-   <xref:System.IO.StringWriter>  
  
-   <xref:System.CodeDom.Compiler.IndentedTextWriter>  
  
> [!NOTE]
>  <xref:System.Xml.Serialization.XmlSerializer>無法序列化下： 陣列<xref:System.Collections.ArrayList>和陣列<xref:System.Collections.Generic.List%601>。  
  
   
  
## Examples  
 下列範例會序列化物件使用<xref:System.IO.TextWriter>。  
  
 [!code-cpp[Classic XmlSerializer.Serialize Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlSerializer.Serialize Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlSerializer.Serialize Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlSerializer.Serialize Example/CS/source.cs#1)]
 [!code-vb[Classic XmlSerializer.Serialize Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlSerializer.Serialize Example/VB/source.vb#1)]
 [!code-xml[Classic XmlSerializer.Serialize Example#1](~/samples/snippets/common/VS_Snippets_Remoting/Classic XmlSerializer.Serialize Example/Common/simple.xml#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
      </Docs>
    </Member>
    <Member MemberName="Serialize">
      <MemberSignature Language="C#" Value="protected virtual void Serialize (object o, System.Xml.Serialization.XmlSerializationWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Serialize(object o, class System.Xml.Serialization.XmlSerializationWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.Serialize(System.Object,System.Xml.Serialization.XmlSerializationWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Serialize (o As Object, writer As XmlSerializationWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Serialize(System::Object ^ o, System::Xml::Serialization::XmlSerializationWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member Serialize : obj * System.Xml.Serialization.XmlSerializationWriter -&gt; unit&#xA;override this.Serialize : obj * System.Xml.Serialization.XmlSerializationWriter -&gt; unit" Usage="xmlSerializer.Serialize (o, writer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
        <Parameter Name="writer" Type="System.Xml.Serialization.XmlSerializationWriter" />
      </Parameters>
      <Docs>
        <param name="o">要序列化的 <see cref="T:System.Object" />。</param>
        <param name="writer">用來寫入 XML 文件的 <see cref="T:System.Xml.Serialization.XmlSerializationWriter" />。</param>
        <summary>序列化指定的 <see cref="T:System.Object" />，並使用指定的 <see cref="T:System.Xml.Serialization.XmlSerializationWriter" /> 將 XML 文件寫入檔案。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">當方法在子代類別中未覆寫時，會嘗試存取該方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="Serialize">
      <MemberSignature Language="C#" Value="public void Serialize (System.Xml.XmlWriter xmlWriter, object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Serialize(class System.Xml.XmlWriter xmlWriter, object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.Serialize(System.Xml.XmlWriter,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Serialize(System::Xml::XmlWriter ^ xmlWriter, System::Object ^ o);" />
      <MemberSignature Language="F#" Value="member this.Serialize : System.Xml.XmlWriter * obj -&gt; unit" Usage="xmlSerializer.Serialize (xmlWriter, o)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xmlWriter" Type="System.Xml.XmlWriter" />
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="xmlWriter">用來寫入 XML 文件的 <see cref="T:System.Xml.XmlWriter" />。</param>
        <param name="o">要序列化的 <see cref="T:System.Object" />。</param>
        <summary>序列化指定的 <see cref="T:System.Object" />，並使用指定的 <see cref="T:System.Xml.XmlWriter" /> 將 XML 文件寫入檔案。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.Serialization.XmlSerializer.Serialize%2A>方法會將公用欄位和讀取/寫入屬性的物件轉換成 XML。 它不會轉換方法、 索引子、 私用欄位或唯讀屬性。 若要序列化為物件的所有欄位和屬性，公用和私用，使用<xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>。  
  
 在`xmlWriter`參數，指定物件衍生自抽象<xref:System.Xml.XmlWriter>類別。 <xref:System.Xml.XmlTextWriter>衍生自<xref:System.Xml.XmlWriter>。  
  
> [!NOTE]
>  <xref:System.Xml.Serialization.XmlSerializer>無法序列化下： 陣列<xref:System.Collections.ArrayList>和陣列<xref:System.Collections.Generic.List%601>。  
  
   
  
## Examples  
 下列範例會序列化物件使用<xref:System.Xml.XmlWriter>。  
  
 [!code-cpp[Classic XmlSerializer.Serialize4 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlSerializer.Serialize4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlSerializer.Serialize4 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlSerializer.Serialize4 Example/CS/source.cs#1)]
 [!code-vb[Classic XmlSerializer.Serialize4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlSerializer.Serialize4 Example/VB/source.vb#1)]
 [!code-xml[Classic XmlSerializer.Serialize4 Example#1](~/samples/snippets/common/VS_Snippets_Remoting/Classic XmlSerializer.Serialize4 Example/Common/simple.xml#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在序列化期間發生錯誤。 可以使用 <see cref="P:System.Exception.InnerException" /> 屬性取得原始例外狀況。</exception>
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
        <altmember cref="M:System.Xml.Serialization.XmlSerializer.Deserialize(System.IO.Stream)" />
      </Docs>
    </Member>
    <Member MemberName="Serialize">
      <MemberSignature Language="C#" Value="public void Serialize (System.IO.Stream stream, object o, System.Xml.Serialization.XmlSerializerNamespaces namespaces);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Serialize(class System.IO.Stream stream, object o, class System.Xml.Serialization.XmlSerializerNamespaces namespaces) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.Serialize(System.IO.Stream,System.Object,System.Xml.Serialization.XmlSerializerNamespaces)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Serialize(System::IO::Stream ^ stream, System::Object ^ o, System::Xml::Serialization::XmlSerializerNamespaces ^ namespaces);" />
      <MemberSignature Language="F#" Value="member this.Serialize : System.IO.Stream * obj * System.Xml.Serialization.XmlSerializerNamespaces -&gt; unit" Usage="xmlSerializer.Serialize (stream, o, namespaces)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="o" Type="System.Object" />
        <Parameter Name="namespaces" Type="System.Xml.Serialization.XmlSerializerNamespaces" />
      </Parameters>
      <Docs>
        <param name="stream">用來寫入 XML 文件的 <see cref="T:System.IO.Stream" />。</param>
        <param name="o">要序列化的 <see cref="T:System.Object" />。</param>
        <param name="namespaces">物件所參考的 <see cref="T:System.Xml.Serialization.XmlSerializerNamespaces" />。</param>
        <summary>序列化指定的 <see cref="T:System.Object" />，並使用指定的 <see cref="T:System.IO.Stream" /> 將 XML 文件寫入檔案，以參考指定的命名空間。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Xml.Serialization.XmlSerializer.Serialize%2A>叫用方法、 公用欄位和讀取/寫入屬性的物件轉換成 XML。 方法、 索引子、 私用欄位和唯讀屬性不會序列化。 若要序列化的所有欄位和屬性，公用和私用，使用<xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>。  
  
 使用`stream`參數來指定物件衍生自抽象<xref:System.IO.Stream>類別，其設計目的是要寫入資料流。 類別衍生自<xref:System.IO.Stream>類別包括：  
  
-   <xref:System.IO.BufferedStream>  
  
-   <xref:System.IO.FileStream>  
  
-   <xref:System.IO.MemoryStream>  
  
-   <xref:System.Net.Sockets.NetworkStream>  
  
-   <xref:System.Security.Cryptography.CryptoStream>  
  
> [!NOTE]
>  <xref:System.Xml.Serialization.XmlSerializer>無法序列化下： 陣列<xref:System.Collections.ArrayList>和陣列<xref:System.Collections.Generic.List%601>。  
  
   
  
## Examples  
 下列範例將物件序列化為具有<xref:System.IO.Stream>物件。 此範例也會建立<xref:System.Xml.Serialization.XmlSerializerNamespaces>並將兩個命名空間加入至物件。 定義序列化的物件的類別也屬性具有<xref:System.Xml.Serialization.XmlElementAttribute>屬性來指定每個元素的命名空間。  
  
 [!code-cpp[Classic XmlSerializer.Serialize3 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlSerializer.Serialize3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlSerializer.Serialize3 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlSerializer.Serialize3 Example/CS/source.cs#1)]
 [!code-vb[Classic XmlSerializer.Serialize3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlSerializer.Serialize3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在序列化期間發生錯誤。 可以使用 <see cref="P:System.Exception.InnerException" /> 屬性取得原始例外狀況。</exception>
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
        <altmember cref="M:System.Xml.Serialization.XmlSerializer.Deserialize(System.IO.Stream)" />
      </Docs>
    </Member>
    <Member MemberName="Serialize">
      <MemberSignature Language="C#" Value="public void Serialize (System.IO.TextWriter textWriter, object o, System.Xml.Serialization.XmlSerializerNamespaces namespaces);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Serialize(class System.IO.TextWriter textWriter, object o, class System.Xml.Serialization.XmlSerializerNamespaces namespaces) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.Serialize(System.IO.TextWriter,System.Object,System.Xml.Serialization.XmlSerializerNamespaces)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Serialize(System::IO::TextWriter ^ textWriter, System::Object ^ o, System::Xml::Serialization::XmlSerializerNamespaces ^ namespaces);" />
      <MemberSignature Language="F#" Value="member this.Serialize : System.IO.TextWriter * obj * System.Xml.Serialization.XmlSerializerNamespaces -&gt; unit" Usage="xmlSerializer.Serialize (textWriter, o, namespaces)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textWriter" Type="System.IO.TextWriter" />
        <Parameter Name="o" Type="System.Object" />
        <Parameter Name="namespaces" Type="System.Xml.Serialization.XmlSerializerNamespaces" />
      </Parameters>
      <Docs>
        <param name="textWriter">用來寫入 XML 文件的 <see cref="T:System.IO.TextWriter" />。</param>
        <param name="o">要序列化的 <see cref="T:System.Object" />。</param>
        <param name="namespaces">
          <see cref="T:System.Xml.Serialization.XmlSerializerNamespaces" />，包含產生之 XML 文件的命名空間。</param>
        <summary>將指定的 <see cref="T:System.Object" /> 序列化，使用指定的 <see cref="T:System.IO.TextWriter" /> 將 XML 文件寫入檔案，並參考指定的命名空間。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Xml.Serialization.XmlSerializer.Serialize%2A>叫用方法的公用欄位和讀取/寫入屬性的物件轉換成 XML。 方法、 索引子、 私用欄位和唯讀屬性不會序列化。 若要序列化的所有欄位和屬性，公用和私用，使用<xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>。  
  
 使用`textWriter`參數來指定物件衍生自抽象<xref:System.IO.TextWriter>類別。 類別衍生自<xref:System.IO.TextWriter>類別包括：  
  
-   <xref:System.IO.StreamWriter>  
  
-   <xref:System.IO.StringWriter>  
  
-   <xref:System.CodeDom.Compiler.IndentedTextWriter>  
  
> [!NOTE]
>  <xref:System.Xml.Serialization.XmlSerializer>無法序列化下： 陣列<xref:System.Collections.ArrayList>和陣列<xref:System.Collections.Generic.List%601>。  
  
   
  
## Examples  
 下列範例將物件序列化為具有<xref:System.IO.TextWriter>。 此範例也會建立<xref:System.Xml.Serialization.XmlSerializerNamespaces>物件並將兩個命名空間加入至物件。 定義序列化的物件的類別也屬性具有<xref:System.Xml.Serialization.XmlElementAttribute>屬性來指定每個元素的命名空間。  
  
 [!code-cpp[Classic XmlSerializer.Serialize1 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlSerializer.Serialize1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlSerializer.Serialize1 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlSerializer.Serialize1 Example/CS/source.cs#1)]
 [!code-vb[Classic XmlSerializer.Serialize1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlSerializer.Serialize1 Example/VB/source.vb#1)]
 [!code-xml[Classic XmlSerializer.Serialize1 Example#1](~/samples/snippets/common/VS_Snippets_Remoting/Classic XmlSerializer.Serialize1 Example/Common/simple.xml#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在序列化期間發生錯誤。 可以使用 <see cref="P:System.Exception.InnerException" /> 屬性取得原始例外狀況。</exception>
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
      </Docs>
    </Member>
    <Member MemberName="Serialize">
      <MemberSignature Language="C#" Value="public void Serialize (System.Xml.XmlWriter xmlWriter, object o, System.Xml.Serialization.XmlSerializerNamespaces namespaces);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Serialize(class System.Xml.XmlWriter xmlWriter, object o, class System.Xml.Serialization.XmlSerializerNamespaces namespaces) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.Serialize(System.Xml.XmlWriter,System.Object,System.Xml.Serialization.XmlSerializerNamespaces)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Serialize(System::Xml::XmlWriter ^ xmlWriter, System::Object ^ o, System::Xml::Serialization::XmlSerializerNamespaces ^ namespaces);" />
      <MemberSignature Language="F#" Value="member this.Serialize : System.Xml.XmlWriter * obj * System.Xml.Serialization.XmlSerializerNamespaces -&gt; unit" Usage="xmlSerializer.Serialize (xmlWriter, o, namespaces)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xmlWriter" Type="System.Xml.XmlWriter" />
        <Parameter Name="o" Type="System.Object" />
        <Parameter Name="namespaces" Type="System.Xml.Serialization.XmlSerializerNamespaces" />
      </Parameters>
      <Docs>
        <param name="xmlWriter">用來寫入 XML 文件的 <see cref="T:System.Xml.XmlWriter" />。</param>
        <param name="o">要序列化的 <see cref="T:System.Object" />。</param>
        <param name="namespaces">物件所參考的 <see cref="T:System.Xml.Serialization.XmlSerializerNamespaces" />。</param>
        <summary>將指定的 <see cref="T:System.Object" /> 序列化，使用指定的 <see cref="T:System.Xml.XmlWriter" /> 將 XML 文件寫入檔案，並參考指定的命名空間。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Xml.Serialization.XmlSerializer.Serialize%2A>叫用方法、 公用欄位和讀取/寫入屬性的物件轉換成 XML。 方法、 索引子、 私用欄位和唯讀屬性不會序列化。 若要序列化的所有欄位和屬性，公用和私用，使用<xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>。  
  
 使用`xmlWriter`參數來指定物件衍生自抽象<xref:System.Xml.XmlWriter>類別，其設計目的是要寫入 XML 文件。 <xref:System.Xml.XmlTextWriter>衍生自<xref:System.Xml.XmlWriter>。  
  
> [!NOTE]
>  <xref:System.Xml.Serialization.XmlSerializer>無法序列化下： 陣列<xref:System.Collections.ArrayList>和陣列<xref:System.Collections.Generic.List%601>。  
  
   
  
## Examples  
 下列範例將物件序列化為具有<xref:System.Xml.XmlWriter>。 此範例也會建立<xref:System.Xml.Serialization.XmlSerializerNamespaces>並將兩個命名空間加入至物件。 數個執行個體<xref:System.Xml.Serialization.XmlElementAttribute>類別會套用至指定的每個元素的命名空間的類別成員。  
  
 [!code-cpp[Classic XmlSerializer.Serialize5 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlSerializer.Serialize5 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlSerializer.Serialize5 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlSerializer.Serialize5 Example/CS/source.cs#1)]
 [!code-vb[Classic XmlSerializer.Serialize5 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlSerializer.Serialize5 Example/VB/source.vb#1)]
 [!code-xml[Classic XmlSerializer.Serialize5 Example#1](~/samples/snippets/common/VS_Snippets_Remoting/Classic XmlSerializer.Serialize5 Example/Common/simple.xml#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在序列化期間發生錯誤。 可以使用 <see cref="P:System.Exception.InnerException" /> 屬性取得原始例外狀況。</exception>
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
        <altmember cref="M:System.Xml.Serialization.XmlSerializer.Deserialize(System.IO.Stream)" />
      </Docs>
    </Member>
    <Member MemberName="Serialize">
      <MemberSignature Language="C#" Value="public void Serialize (System.Xml.XmlWriter xmlWriter, object o, System.Xml.Serialization.XmlSerializerNamespaces namespaces, string encodingStyle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Serialize(class System.Xml.XmlWriter xmlWriter, object o, class System.Xml.Serialization.XmlSerializerNamespaces namespaces, string encodingStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.Serialize(System.Xml.XmlWriter,System.Object,System.Xml.Serialization.XmlSerializerNamespaces,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Serialize(System::Xml::XmlWriter ^ xmlWriter, System::Object ^ o, System::Xml::Serialization::XmlSerializerNamespaces ^ namespaces, System::String ^ encodingStyle);" />
      <MemberSignature Language="F#" Value="member this.Serialize : System.Xml.XmlWriter * obj * System.Xml.Serialization.XmlSerializerNamespaces * string -&gt; unit" Usage="xmlSerializer.Serialize (xmlWriter, o, namespaces, encodingStyle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xmlWriter" Type="System.Xml.XmlWriter" />
        <Parameter Name="o" Type="System.Object" />
        <Parameter Name="namespaces" Type="System.Xml.Serialization.XmlSerializerNamespaces" />
        <Parameter Name="encodingStyle" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xmlWriter">用來寫入 XML 文件的 <see cref="T:System.Xml.XmlWriter" />。</param>
        <param name="o">要序列化的物件。</param>
        <param name="namespaces">物件所參考的 <see cref="T:System.Xml.Serialization.XmlSerializerNamespaces" />。</param>
        <param name="encodingStyle">序列化 XML 的編碼樣式。</param>
        <summary>序列化指定的物件，使用指定的 <see cref="T:System.Xml.XmlWriter" /> 將 XML 文件寫入檔案，並參考指定的命名空間和編碼樣式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Xml.Serialization.XmlSerializer.Serialize%2A>叫用方法、 公用欄位和讀取/寫入屬性的物件轉換成 XML。 方法、 索引子、 私用欄位和唯讀屬性不會序列化。 若要序列化的所有欄位和屬性，公用和私用，使用<xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>。  
  
 使用`xmlWriter`參數來指定物件衍生自抽象<xref:System.Xml.XmlWriter>類別，其設計目的是要寫入 XML 文件。 <xref:System.Xml.XmlTextWriter>衍生自<xref:System.Xml.XmlWriter>。  
  
 設定`encodingStyle`參數 」http://schemas.xmlsoap.org/soap/encoding/"如 SOAP 1.1 版編碼; 否則將它設定為"http://www.w3.org/2001/12/soap-encoding"SOAP 1.2 編碼方式。  
  
> [!NOTE]
>  <xref:System.Xml.Serialization.XmlSerializer>無法序列化下： 陣列<xref:System.Collections.ArrayList>和陣列<xref:System.Collections.Generic.List%601>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在序列化期間發生錯誤。 可以使用 <see cref="P:System.Exception.InnerException" /> 屬性取得原始例外狀況。</exception>
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
        <altmember cref="M:System.Xml.Serialization.XmlSerializer.Deserialize(System.IO.Stream)" />
      </Docs>
    </Member>
    <Member MemberName="Serialize">
      <MemberSignature Language="C#" Value="public void Serialize (System.Xml.XmlWriter xmlWriter, object o, System.Xml.Serialization.XmlSerializerNamespaces namespaces, string encodingStyle, string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Serialize(class System.Xml.XmlWriter xmlWriter, object o, class System.Xml.Serialization.XmlSerializerNamespaces namespaces, string encodingStyle, string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Serialization.XmlSerializer.Serialize(System.Xml.XmlWriter,System.Object,System.Xml.Serialization.XmlSerializerNamespaces,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Serialize(System::Xml::XmlWriter ^ xmlWriter, System::Object ^ o, System::Xml::Serialization::XmlSerializerNamespaces ^ namespaces, System::String ^ encodingStyle, System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.Serialize : System.Xml.XmlWriter * obj * System.Xml.Serialization.XmlSerializerNamespaces * string * string -&gt; unit" Usage="xmlSerializer.Serialize (xmlWriter, o, namespaces, encodingStyle, id)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xmlWriter" Type="System.Xml.XmlWriter" />
        <Parameter Name="o" Type="System.Object" />
        <Parameter Name="namespaces" Type="System.Xml.Serialization.XmlSerializerNamespaces" />
        <Parameter Name="encodingStyle" Type="System.String" />
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xmlWriter">用來寫入 XML 文件的 <see cref="T:System.Xml.XmlWriter" />。</param>
        <param name="o">要序列化的物件。</param>
        <param name="namespaces">
          <see langword="XmlSerializaerNamespaces" /> 執行個體，包含要使用的命名空間和前置詞。</param>
        <param name="encodingStyle">文件中使用的編碼方式。</param>
        <param name="id">若為 SOAP 編碼的訊息，則為用於產生 ID 屬性的基底。</param>
        <summary>序列化指定的 <see cref="T:System.Object" />，並使用指定的 <see cref="T:System.Xml.XmlWriter" />、XML 命名空間和編碼方式，將 XML 文件寫入檔案。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *識別碼*參數提供用來建立 SOAP id 的基底的字串。 根據預設，這些是 「 id1"、"id2"等等。 但如果參數設定為"myBase 」 產生的值是"myBaseid1"，"myBaseid2 」，依此類推。 這項功能用來跨整個 SOAP 訊息建立唯一的識別碼值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnknownAttribute">
      <MemberSignature Language="C#" Value="public event System.Xml.Serialization.XmlAttributeEventHandler UnknownAttribute;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.Serialization.XmlAttributeEventHandler UnknownAttribute" />
      <MemberSignature Language="DocId" Value="E:System.Xml.Serialization.XmlSerializer.UnknownAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UnknownAttribute As XmlAttributeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::Serialization::XmlAttributeEventHandler ^ UnknownAttribute;" />
      <MemberSignature Language="F#" Value="member this.UnknownAttribute : System.Xml.Serialization.XmlAttributeEventHandler " Usage="member this.UnknownAttribute : System.Xml.Serialization.XmlAttributeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Serialization.XmlAttributeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當還原序列化期間，<see cref="T:System.Xml.Serialization.XmlSerializer" /> 遭遇未知型別的 XML 屬性時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設，在呼叫之後<xref:System.Xml.Serialization.XmlSerializer.Deserialize%2A>方法，<xref:System.Xml.Serialization.XmlSerializer>會忽略未知類型的 XML 屬性。 不過，您可以使用此事件處理這類節點型別。  
  
 如果在還原序列化的類別執行個體包含傳回陣列的欄位<xref:System.Xml.XmlAttribute>物件和<xref:System.Xml.Serialization.XmlAnyAttributeAttribute>已套用至欄位，<xref:System.Xml.Serialization.XmlSerializer.UnknownAttribute>事件不會發生。 相反地，所有未知的 XML 屬性會收集到的陣列。  
  
   
  
## Examples  
 下列範例會列印任何還原序列化的 XML 文件時遇到未知的屬性的相關資訊。  
  
 [!code-cpp[Classic XmlSerializer.UnknownAttribute Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlSerializer.UnknownAttribute Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlSerializer.UnknownAttribute Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlSerializer.UnknownAttribute Example/CS/source.cs#1)]
 [!code-vb[Classic XmlSerializer.UnknownAttribute Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlSerializer.UnknownAttribute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Serialization.XmlAnyAttributeAttribute" />
        <altmember cref="M:System.Xml.Serialization.XmlSerializer.CanDeserialize(System.Xml.XmlReader)" />
        <altmember cref="M:System.Xml.Serialization.XmlSerializer.Deserialize(System.IO.Stream)" />
        <altmember cref="E:System.Xml.Serialization.XmlSerializer.UnknownNode" />
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
      </Docs>
    </Member>
    <Member MemberName="UnknownElement">
      <MemberSignature Language="C#" Value="public event System.Xml.Serialization.XmlElementEventHandler UnknownElement;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.Serialization.XmlElementEventHandler UnknownElement" />
      <MemberSignature Language="DocId" Value="E:System.Xml.Serialization.XmlSerializer.UnknownElement" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UnknownElement As XmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::Serialization::XmlElementEventHandler ^ UnknownElement;" />
      <MemberSignature Language="F#" Value="member this.UnknownElement : System.Xml.Serialization.XmlElementEventHandler " Usage="member this.UnknownElement : System.Xml.Serialization.XmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Serialization.XmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當還原序列化期間，<see cref="T:System.Xml.Serialization.XmlSerializer" /> 遭遇未知型別的 XML 項目時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設，在呼叫之後<xref:System.Xml.Serialization.XmlSerializer.Deserialize%2A>方法，<xref:System.Xml.Serialization.XmlSerializer>會忽略未知類型的 XML 屬性。 不過，您可以使用此事件處理這類節點型別。  
  
> [!NOTE]
>  如果<xref:System.Xml.Serialization.XmlAnyElementAttribute>套用至傳回陣列的欄位<xref:System.Xml.XmlElement>物件時，所有未知的項目會收集陣列中。 在此情況下，<xref:System.Xml.Serialization.XmlSerializer.UnknownElement>事件不會發生。  
  
   
  
## Examples  
 下列範例會還原序列化的類別，名為`Group`從名為 UnknownElements.xml 檔案。 每當在類別中，沒有對應成員的檔案中找到的項目是<xref:System.Xml.Serialization.XmlSerializer.UnknownElement>就會發生事件。 若要執行範例，將下列 XML 程式碼貼入名為 UnknownElements.xml 的檔案。  
  
```  
<?xml version="1.0" encoding="utf-8"?>  
<Group xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">  
  <GroupName>MyGroup</GroupName>  
  <GroupSize>Large</GroupSize>  
  <GroupNumber>444</GroupNumber>  
  <GroupBase>West</GroupBase>  
</Group>  
```  
  
 [!code-cpp[XmlSerializer.UnknownElement Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/XmlSerializer.UnknownElement Example/CPP/unknownelement.cpp#1)]
 [!code-csharp[XmlSerializer.UnknownElement Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/XmlSerializer.UnknownElement Example/CS/unknownelement.cs#1)]
 [!code-vb[XmlSerializer.UnknownElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/XmlSerializer.UnknownElement Example/VB/unknownelement.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Serialization.XmlAnyElementAttribute" />
        <altmember cref="E:System.Xml.Serialization.XmlSerializer.UnknownNode" />
        <altmember cref="E:System.Xml.Serialization.XmlSerializer.UnknownAttribute" />
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
      </Docs>
    </Member>
    <Member MemberName="UnknownNode">
      <MemberSignature Language="C#" Value="public event System.Xml.Serialization.XmlNodeEventHandler UnknownNode;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.Serialization.XmlNodeEventHandler UnknownNode" />
      <MemberSignature Language="DocId" Value="E:System.Xml.Serialization.XmlSerializer.UnknownNode" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UnknownNode As XmlNodeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::Serialization::XmlNodeEventHandler ^ UnknownNode;" />
      <MemberSignature Language="F#" Value="member this.UnknownNode : System.Xml.Serialization.XmlNodeEventHandler " Usage="member this.UnknownNode : System.Xml.Serialization.XmlNodeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Serialization.XmlNodeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當還原序列化期間，<see cref="T:System.Xml.Serialization.XmlSerializer" /> 遭遇未知型別的 XML 節點時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設，在呼叫之後<xref:System.Xml.Serialization.XmlSerializer.Deserialize%2A>方法，<xref:System.Xml.Serialization.XmlSerializer>忽略未知類型的 XML 節點。 不過，您可以使用此事件處理這類節點型別。  
  
   
  
## Examples  
 下列範例會列印任何遇到未知的節點類型。  
  
 [!code-cpp[Classic XmlSerializer.UnknownNode Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlSerializer.UnknownNode Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlSerializer.UnknownNode Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlSerializer.UnknownNode Example/CS/source.cs#1)]
 [!code-vb[Classic XmlSerializer.UnknownNode Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlSerializer.UnknownNode Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Serialization.XmlAnyElementAttribute" />
        <altmember cref="T:System.Xml.Serialization.XmlAnyAttributeAttribute" />
        <altmember cref="M:System.Xml.Serialization.XmlSerializer.CanDeserialize(System.Xml.XmlReader)" />
        <altmember cref="M:System.Xml.Serialization.XmlSerializer.Deserialize(System.IO.Stream)" />
        <altmember cref="E:System.Xml.Serialization.XmlSerializer.UnknownAttribute" />
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
      </Docs>
    </Member>
    <Member MemberName="UnreferencedObject">
      <MemberSignature Language="C#" Value="public event System.Xml.Serialization.UnreferencedObjectEventHandler UnreferencedObject;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.Serialization.UnreferencedObjectEventHandler UnreferencedObject" />
      <MemberSignature Language="DocId" Value="E:System.Xml.Serialization.XmlSerializer.UnreferencedObject" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UnreferencedObject As UnreferencedObjectEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::Serialization::UnreferencedObjectEventHandler ^ UnreferencedObject;" />
      <MemberSignature Language="F#" Value="member this.UnreferencedObject : System.Xml.Serialization.UnreferencedObjectEventHandler " Usage="member this.UnreferencedObject : System.Xml.Serialization.UnreferencedObjectEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlSerializer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Serialization.UnreferencedObjectEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在 SOAP 編碼的 XML 資料流還原序列化期間，<see cref="T:System.Xml.Serialization.XmlSerializer" /> 遇到未使用 (未參考) 的可辨認型別時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.Serialization.XmlSerializer.UnreferencedObject>事件只會發生時<xref:System.Xml.Serialization.XmlSerializer>用來還原序列化 XML 文件，其中包含符合全球資訊網協會 (www.w3.org) 文件，而 「 簡單物件存取通訊協定 (SOAP) 1.1 」 的第 5 節的 SOAP 訊息。  
  
 符合第 5 節的文件是以特殊格式。 至少，在這種文件會包含 SOAP 訊息的主體。 不過，而不是所有型別定義內嵌在文件中，某些型別定義可以編碼為文件中的最上層元素的參考。 因此，每個項目之參考的主要本文中找到，必須有對應的項目包含類型定義。 若要將建立相互關聯的參考項目類型定義，具有型別定義`id`屬性設為唯一字串識別碼和參考的項目具有`href`屬性必須參考相同的識別碼。  
  
```  
<Group xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" id="id1" n1:GroupName=".NET" GroupNumber="ZDI=" CreationDate="2002-05-02" xmlns:n1="http:'www.cpandl.com">  
    <PosInt xsi:type="xsd:nonNegativeInteger">10000</PosInt>  
    <GroupVehicle href="#id2" />  
  </Group>  
  <Vehicle id="id2" n1:type="Vehicle" xmlns:n1="http://www.w3.org/2001/XMLSchema-instance">  
    <licenseNumber xmlns:q1="http://www.w3.org/2001/XMLSchema" n1:type="q1:string">1234</licenseNumber>  
  </Vehicle>  
```  
  
 <xref:System.Xml.Serialization.XmlSerializer.UnreferencedObject> ，文件中找到的類型定義時，會發生事件，但沒有參數，在主體中的參考它。 發生事件時，您可以藉由檢查擷取的未參考物件的 XML 類型<xref:System.Xml.Serialization.UnreferencedObjectEventArgs.UnreferencedObject%2A>屬性<xref:System.Xml.Serialization.UnreferencedObjectEventArgs>類別。 所傳回之物件的 XML 識別碼<xref:System.Xml.Serialization.UnreferencedObjectEventArgs.UnreferencedId%2A>屬性。  
  
 <xref:System.Xml.Serialization.XmlSerializer.UnreferencedObject>事件不應該與混淆<xref:System.Xml.Serialization.XmlSerializer.UnknownElement>和<xref:System.Xml.Serialization.XmlSerializer.UnknownNode>沒有對應到 XML 節點或項目類型的類別成員時，會發生的事件。  
  
   
  
## Examples  
 下列範例會將<xref:System.Xml.Serialization.UnreferencedObjectEventHandler>至<xref:System.Xml.Serialization.XmlSerializer>。 事件由`Serializer``_``UnreferencedObject`方法。 若要執行此範例，剪下並貼到名為"UnrefObj.xml 」 檔案的下列 XML。  
  
```  
<wrapper>  
  <Group xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" id="id1" n1:GroupName=".NET" xmlns:n1="http://www.cpandl.com">  
   </Group>  
<Vehicle id="id2" n1:type="Vehicle" xmlns:n1="http://www.w3.org/2001/XMLSchema-instance">  
    <licenseNumber xmlns:q1="http://www.w3.org/2001/XMLSchema" n1:type="q1:string">ABCD</licenseNumber>  
  </Vehicle>  
<Vehicle id="id3" n1:type="Vehicle" xmlns:n1="http://www.w3.org/2001/XMLSchema-instance">  
    <licenseNumber xmlns:q1="http://www.w3.org/2001/XMLSchema" n1:type="q1:string">1234</licenseNumber>  
  </Vehicle>  
</wrapper>  
```  
  
 [!code-cpp[UnreferencedObject Event Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/UnreferencedObject Event Example/CPP/unrefobj.cpp#1)]
 [!code-csharp[UnreferencedObject Event Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/UnreferencedObject Event Example/CS/unrefobj.cs#1)]
 [!code-vb[UnreferencedObject Event Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/UnreferencedObject Event Example/VB/unrefobj.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Serialization.XmlAttributes" />
      </Docs>
    </Member>
  </Members>
</Type>