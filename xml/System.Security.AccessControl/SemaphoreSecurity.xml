<Type Name="SemaphoreSecurity" FullName="System.Security.AccessControl.SemaphoreSecurity">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="83fa29ebe41582803f0a783663ba024f0b1d03a6" />
    <Meta Name="ms.sourcegitcommit" Value="0d6aa6694f157a08fe52cd25b4d9d3dcf913e812" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="10/12/2018" />
    <Meta Name="ms.locfileid" Value="49140867" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class SemaphoreSecurity : System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit SemaphoreSecurity extends System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="DocId" Value="T:System.Security.AccessControl.SemaphoreSecurity" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SemaphoreSecurity&#xA;Inherits NativeObjectSecurity" />
  <TypeSignature Language="C++ CLI" Value="public ref class SemaphoreSecurity sealed : System::Security::AccessControl::NativeObjectSecurity" />
  <TypeSignature Language="F#" Value="type SemaphoreSecurity = class&#xA;    inherit NativeObjectSecurity" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.AccessControl</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.AccessControl.NativeObjectSecurity</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示具名號誌 (Semaphore) 的 Windows 存取控制安全性。 這個類別無法被繼承。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Security.AccessControl.SemaphoreSecurity>物件指定為具名的系統號誌的存取權限，也會指定如何稽核存取嘗試。 號誌的存取權限由每個存取規則的規則，以表示<xref:System.Security.AccessControl.SemaphoreAccessRule>物件。 每個稽核規則由<xref:System.Security.AccessControl.SemaphoreAuditRule>物件。  
  
 鏡像處理基礎的 Windows 安全性系統，在其中每個安全性實體的物件具有最多一個判別存取控制清單 (DACL) 控制對受保護的物件，和最多一個系統存取控制清單 (SACL) 指定的權限存取稽核嘗試。 DACL，SACL 會排序清單的指定存取和稽核的使用者和群組的存取控制項目 (ACE)。 A<xref:System.Security.AccessControl.SemaphoreAccessRule>或<xref:System.Security.AccessControl.SemaphoreAuditRule>物件可能代表一個以上的 ACE。  
  
> [!NOTE]
>  A<xref:System.Threading.Semaphore>物件可以代表本機號誌或具名的系統號誌。 Windows 存取控制安全性是有意義，只會針對具名的系統號誌。  
  
 <xref:System.Security.AccessControl.SemaphoreSecurity>， <xref:System.Security.AccessControl.SemaphoreAccessRule>，和<xref:System.Security.AccessControl.SemaphoreAuditRule>類別隱藏實作詳細資料的 Acl 和 Ace。 可讓您略過十七不同 ACE 型別和複雜性的正確維護繼承和傳用的存取權限。 這些物件也可避免下列常見的存取控制錯誤：  
  
-   建立 null DACL 的安全性描述元。 DACL 的 null 參考可讓任何使用者將存取規則加入物件，而可能建立阻斷服務攻擊。 新<xref:System.Security.AccessControl.SemaphoreSecurity>物件一律開頭空白的 DACL，拒絕對所有使用者的所有存取。  
  
-   違反 Ace 的標準順序。 如果在 DACL 中的 ACE 清單不會保留在標準順序，使用者可能會不小心提供存取受保護的物件。 比方說，拒絕的存取權限必須一律會出現之前允許的存取權限。 <xref:System.Security.AccessControl.SemaphoreSecurity> 物件會在內部維護正確的順序。  
  
-   管理安全性描述元旗標，這應該是僅資源管理員的控制之下。  
  
-   建立無效的 ACE 旗標組合。  
  
-   操作繼承的 Ace。 繼承和傳用是由資源管理員，以回應變更您對存取和稽核規則處理的。  
  
-   插入 Acl 中的無意義的 Ace。  
  
 不支援.NET 安全性物件的唯一功能是應避免大部分的應用程式開發人員，如下所示使用模擬的危險活動：  
  
-   通常由資源管理員的低層級工作。  
  
-   新增或移除存取控制項目不會維護標準排序的方式。  
  
 若要修改具名號誌的 Windows 存取控制安全性，請使用<xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType>方法來取得<xref:System.Security.AccessControl.SemaphoreSecurity>物件。 新增和移除規則，以修改安全性物件，然後使用<xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>方法來重新附加它。  
  
> [!IMPORTANT]
>  您所做的變更<xref:System.Security.AccessControl.SemaphoreSecurity>物件不會影響具名號誌的存取層級直到您呼叫<xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>更改的安全性物件指派給具名號誌的方法。  
  
 若要從一個號誌的存取控制安全性複製到另一個中，使用<xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType>方法來取得<xref:System.Security.AccessControl.SemaphoreSecurity>物件，代表存取規則和稽核規則的第一個的號誌，則使用<xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>方法或建構函式可接受<xref:System.Security.AccessControl.SemaphoreSecurity>物件，要將這些規則指派給第二個號誌。  
  
 中的安全性描述元定義語言 (SDDL) 投資的使用者可以使用<xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A>方法來設定具名號誌的存取規則和<xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A>方法，以取得字串，表示 SDDL 格式中的存取規則。 這不是建議用於新的開發。  
  
> [!NOTE]
>  Windows 98 或 Windows Millennium Edition 不支援同步處理物件的安全性。  
  
   
  
## Examples  
 下列程式碼範例示範之間的區隔<xref:System.Security.AccessControl.AccessControlType.Allow>規則和<xref:System.Security.AccessControl.AccessControlType.Deny>規則，並在相容的規則會顯示權限的組合。 此範例會建立<xref:System.Security.AccessControl.SemaphoreSecurity>物件、 將規則，允許和拒絕目前使用者的各種權限，並顯示規則的結果組。 此範例會允許目前使用者的新權限，並顯示結果，顯示新的權限會與現有合併<xref:System.Security.AccessControl.AccessControlType.Allow>規則。  
  
> [!NOTE]
>  此範例不會附加至安全性物件<xref:System.Threading.Semaphore>物件。 附加安全性物件的範例可在<xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType>和<xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>。  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.AddAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.AddAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.AddAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.AddAccessRule/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Security.AccessControl.SemaphoreAccessRule" />
    <altmember cref="T:System.Security.AccessControl.SemaphoreAuditRule" />
    <altmember cref="T:System.Security.AccessControl.SemaphoreRights" />
    <altmember cref="M:System.Threading.Semaphore.GetAccessControl" />
    <altmember cref="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SemaphoreSecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SemaphoreSecurity();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>使用預設值，初始化 <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新<xref:System.Security.AccessControl.SemaphoreSecurity>物件永遠會啟動具有空的判別存取清單 (DACL)，拒絕對所有使用者的所有存取。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Windows 98 或 Windows Millennium Edition 上不支援這個類別。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SemaphoreSecurity (string name, System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.#ctor(System.String,System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, includeSections As AccessControlSections)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SemaphoreSecurity(System::String ^ name, System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberSignature Language="F#" Value="new System.Security.AccessControl.SemaphoreSecurity : string * System.Security.AccessControl.AccessControlSections -&gt; System.Security.AccessControl.SemaphoreSecurity" Usage="new System.Security.AccessControl.SemaphoreSecurity (name, includeSections)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" />
      </Parameters>
      <Docs>
        <param name="name">要擷取其存取控制安全性規則的系統號誌名稱。</param>
        <param name="includeSections">
          <see cref="T:System.Security.AccessControl.AccessControlSections" /> 旗標的組合，指定要擷取的區段。</param>
        <summary>從具有指定名稱的系統號誌，使用指定的存取控制安全性規則區段，初始化 <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個建構函式可讓您取得而不需要第一個建立的具名的系統號誌的存取控制安全性<xref:System.Threading.Semaphore>物件。  
  
 使用具名的系統物件時請務必小心。 如果沒有名為系統物件`name`不號誌，可能會擷取其存取控制安全性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Windows 98 或 Windows Millennium Edition 上不支援這個類別。</exception>
      </Docs>
    </Member>
    <Member MemberName="AccessRightType">
      <MemberSignature Language="C#" Value="public override Type AccessRightType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRightType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.SemaphoreSecurity.AccessRightType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRightType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRightType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessRightType : Type" Usage="System.Security.AccessControl.SemaphoreSecurity.AccessRightType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> 類別用來表示存取權限的列舉型別 (Enumeration)。</summary>
        <value>
          <see cref="T:System.Type" /> 物件，表示 <see cref="T:System.Security.AccessControl.SemaphoreRights" /> 列舉型別。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 衍生自類別<xref:System.Security.AccessControl.ObjectSecurity>類別覆寫<xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A>屬性，並傳回它們用來表示存取權限類型。 當您使用陣列或包含多個類型的安全性物件的集合時，使用這個屬性來判斷要使用每個安全性物件的正確的列舉類型。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AccessRule AccessRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AccessRule AccessRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AccessControlType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AccessRule ^ AccessRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AccessControlType type);" />
      <MemberSignature Language="F#" Value="abstract member AccessRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AccessControlType -&gt; System.Security.AccessControl.AccessRule&#xA;override this.AccessRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AccessControlType -&gt; System.Security.AccessControl.AccessRule" Usage="semaphoreSecurity.AccessRuleFactory (identityReference, accessMask, isInherited, inheritanceFlags, propagationFlags, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AccessRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="type" Type="System.Security.AccessControl.AccessControlType" />
      </Parameters>
      <Docs>
        <param name="identityReference">
          <see cref="T:System.Security.Principal.IdentityReference" />，可識別套用這個規則的使用者或群組。</param>
        <param name="accessMask">
          <see cref="T:System.Security.AccessControl.SemaphoreRights" /> 值的位元組合，指定允許或拒絕的存取權限 (轉型成整數)。</param>
        <param name="isInherited">對於具名號誌沒有意義，因為它們沒有階層架構。</param>
        <param name="inheritanceFlags">對於具名號誌沒有意義，因為它們沒有階層架構。</param>
        <param name="propagationFlags">對於具名號誌沒有意義，因為它們沒有階層架構。</param>
        <param name="type">其中一個 <see cref="T:System.Security.AccessControl.AccessControlType" /> 值，指定允許還是拒絕權限。</param>
        <summary>以指定的存取權限、存取控制和旗標，為指定的使用者建立新的存取控制規則。</summary>
        <returns>
          <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> 物件，表示指定之使用者的指定權限。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要建立存取控制規則的建議的方式是使用的建構函式<xref:System.Security.AccessControl.SemaphoreAccessRule>類別。  
  
> [!NOTE]
>  雖然沒有意義的具名號誌繼承和傳用旗標，就仍然可以指定它們不建議問題，因為它不必要地變得非常複雜的規則，維護工作，例如藉由干擾規則的組合否則，就會相容。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="accessMask" />、<paramref name="inheritanceFlags" />、<paramref name="propagationFlags" /> 或 <paramref name="type" /> 會指定無效的值。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="identityReference" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="accessMask" /> 為零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="identityReference" /> 既不是 <see cref="T:System.Security.Principal.SecurityIdentifier" /> 型別，也不是可以轉換成 <see cref="T:System.Security.Principal.NTAccount" /> 型別的型別 (例如 <see cref="T:System.Security.Principal.SecurityIdentifier" />)。</exception>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleType">
      <MemberSignature Language="C#" Value="public override Type AccessRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.SemaphoreSecurity.AccessRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRuleType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessRuleType : Type" Usage="System.Security.AccessControl.SemaphoreSecurity.AccessRuleType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> 類別用來表示存取規則的型別。</summary>
        <value>
          <see cref="T:System.Type" /> 物件，表示 <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> 類別。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 衍生自類別<xref:System.Security.AccessControl.ObjectSecurity>類別覆寫<xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A>屬性，並傳回它們用來表示存取規則類型。 當您使用陣列或包含多個類型的安全性物件的集合時，使用這個屬性來判斷正確的存取規則型別，若要使用每個安全性物件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAccessRule">
      <MemberSignature Language="C#" Value="public void AddAccessRule (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAccessRule(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.AddAccessRule(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAccessRule (rule As SemaphoreAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAccessRule(System::Security::AccessControl::SemaphoreAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.AddAccessRule : System.Security.AccessControl.SemaphoreAccessRule -&gt; unit" Usage="semaphoreSecurity.AddAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">要加入的存取控制規則。</param>
        <summary>搜尋可合併新規則的相符規則。 如果找不到，就加入新規則。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.AccessControl.SemaphoreSecurity.AddAccessRule%2A>方法會搜尋具有相同的使用者或群組和相同的規則<xref:System.Security.AccessControl.AccessControlType>做為`rule`。 如果找不到，`rule`加入。 如果找到相符的規則是中的權限`rule`會與現有的規則合併。  
  
   
  
## Examples  
 下列程式碼範例示範之間的區隔<xref:System.Security.AccessControl.AccessControlType.Allow>規則和<xref:System.Security.AccessControl.AccessControlType.Deny>規則，並在相容的規則會顯示權限的組合。 此範例會建立<xref:System.Security.AccessControl.SemaphoreSecurity>物件、 將規則，允許和拒絕目前使用者的各種權限，並顯示規則的結果組。 此範例會允許目前使用者的新權限，並顯示結果，顯示新的權限會與現有合併<xref:System.Security.AccessControl.AccessControlType.Allow>規則。  
  
> [!NOTE]
>  此範例不會附加至安全性物件<xref:System.Threading.Semaphore>物件。 附加安全性物件的範例可在<xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType>和<xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>。  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.AddAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.AddAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.AddAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.AddAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="AddAuditRule">
      <MemberSignature Language="C#" Value="public void AddAuditRule (System.Security.AccessControl.SemaphoreAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAuditRule(class System.Security.AccessControl.SemaphoreAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.AddAuditRule(System.Security.AccessControl.SemaphoreAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAuditRule (rule As SemaphoreAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAuditRule(System::Security::AccessControl::SemaphoreAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.AddAuditRule : System.Security.AccessControl.SemaphoreAuditRule -&gt; unit" Usage="semaphoreSecurity.AddAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">要加入的稽核規則。 這個規則指定的使用者會決定搜尋方式。</param>
        <summary>搜尋可合併新規則的稽核規則。 如果找不到，就加入新規則。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.AccessControl.SemaphoreSecurity.AddAuditRule%2A>方法會搜尋具有相同的使用者或群組做為規則`rule`。 如果找不到，`rule`加入。 如果找到相符的規則是中的旗標`rule`會合併到現有的規則。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AuditRule AuditRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AuditRule AuditRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AuditFlags flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AuditRule ^ AuditRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AuditFlags flags);" />
      <MemberSignature Language="F#" Value="abstract member AuditRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AuditFlags -&gt; System.Security.AccessControl.AuditRule&#xA;override this.AuditRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AuditFlags -&gt; System.Security.AccessControl.AuditRule" Usage="semaphoreSecurity.AuditRuleFactory (identityReference, accessMask, isInherited, inheritanceFlags, propagationFlags, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AuditRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="flags" Type="System.Security.AccessControl.AuditFlags" />
      </Parameters>
      <Docs>
        <param name="identityReference">
          <see cref="T:System.Security.Principal.IdentityReference" />，可識別套用這個規則的使用者或群組。</param>
        <param name="accessMask">
          <see cref="T:System.Security.AccessControl.SemaphoreRights" /> 值的位元組合，指定要稽核的存取權限 (轉型成整數)。</param>
        <param name="isInherited">命名為等候控制代碼是沒有意義的，因為它們並未具有階層架構。</param>
        <param name="inheritanceFlags">命名為等候控制代碼是沒有意義的，因為它們並未具有階層架構。</param>
        <param name="propagationFlags">命名為等候控制代碼是沒有意義的，因為它們並未具有階層架構。</param>
        <param name="flags">
          <see cref="T:System.Security.AccessControl.AuditFlags" /> 值的位元組合，指定是否要稽核成功存取、失敗存取或兩者皆稽核。</param>
        <summary>以指定要套用規則的使用者的方式，建立新的稽核規則、要稽核的存取權限以及觸發該稽核規則的結果。</summary>
        <returns>
          <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /> 物件，表示指定之使用者的指定稽核規則。 此方法的傳回型別為基底類別 <see cref="T:System.Security.AccessControl.AuditRule" />，但是傳回值可以安全地轉型為衍生類別。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要建立的稽核規則的建議的方式是使用的建構函式<xref:System.Security.AccessControl.SemaphoreAuditRule>類別。  
  
> [!NOTE]
>  雖然沒有意義的具名號誌繼承和傳用旗標，就仍然可以加以指定。 這不是建議，因為它不必要地變得非常複雜的規則，維護工作，例如藉由干擾的情況下無法相容的規則組合。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="accessMask" />、<paramref name="inheritanceFlags" />、<paramref name="propagationFlags" /> 或 <paramref name="flags" /> 會指定無效的值。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="identityReference" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="accessMask" /> 為零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="identityReference" /> 既不是 <see cref="T:System.Security.Principal.SecurityIdentifier" /> 型別，也不是可以轉換成 <see cref="T:System.Security.Principal.NTAccount" /> 型別的型別 (例如 <see cref="T:System.Security.Principal.SecurityIdentifier" />)。</exception>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleType">
      <MemberSignature Language="C#" Value="public override Type AuditRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AuditRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.SemaphoreSecurity.AuditRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AuditRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AuditRuleType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AuditRuleType : Type" Usage="System.Security.AccessControl.SemaphoreSecurity.AuditRuleType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> 類別用來表示稽核規則的類型。</summary>
        <value>
          <see cref="T:System.Type" /> 物件，表示 <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /> 類別。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 衍生自類別<xref:System.Security.AccessControl.ObjectSecurity>類別覆寫<xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A>屬性，並傳回它們用來表示稽核權限類型。 當您使用陣列或包含多個類型的安全性物件的集合時，使用這個屬性來判斷正確的稽核規則型別，將每個安全性物件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRule">
      <MemberSignature Language="C#" Value="public bool RemoveAccessRule (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAccessRule(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAccessRule (rule As SemaphoreAccessRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAccessRule(System::Security::AccessControl::SemaphoreAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAccessRule : System.Security.AccessControl.SemaphoreAccessRule -&gt; bool" Usage="semaphoreSecurity.RemoveAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" />，其會指定要搜尋的使用者和 <see cref="T:System.Security.AccessControl.AccessControlType" />，以及必須與相符的規則 (如果找到的話) 相容的繼承和傳用旗標集合。 如果找到的話，指定從相容的規則中移除此權限。</param>
        <summary>搜尋具有與指定之規則相同的使用者和 <see cref="T:System.Security.AccessControl.AccessControlType" /> (允許或拒絕) 以及具有相容的繼承和傳用旗標的存取控制規則。如果找到這樣的規則，則會移除指定之存取規則中所包含的權限。</summary>
        <returns>如果找到相容的規則，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前<xref:System.Security.AccessControl.SemaphoreSecurity>擁有相同的使用者和相同的規則中搜尋<xref:System.Security.AccessControl.AccessControlType>的值`rule`。 如果找到任何這類規則，會採取任何動作，且此方法傳回`false`。 如果找不到相符的規則，其繼承和相容性旗標會檢查在指定的旗標與相容性的`rule`。 如果找到不相容的規則，會採取任何動作，且此方法傳回`false`。 如果找到相容的旗標的規則，在指定的權限`rule`移除相容的規則，且此方法傳回`true`。 如果`rule`指定不包含在相容的規則的權限，這些權限方面會採取任何動作。 如果從相容的規則，會移除所有的權限，整個規則會移除從目前<xref:System.Security.AccessControl.SemaphoreSecurity>物件。  
  
> [!IMPORTANT]
>  雖然您可以藉由建立以指定的號誌的存取規則的繼承和傳用旗標<xref:System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory%2A>方法，不建議這麼做。 繼承和傳用不具任何意義的具名號誌，而且它們會使存取規則的維護更為複雜。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule%2A>方法來移除權限<xref:System.Security.AccessControl.AccessControlType.Allow>中的規則<xref:System.Security.AccessControl.SemaphoreSecurity>物件。 它也會示範中的其他權限`rule`都會被忽略。  
  
 此範例會建立<xref:System.Security.AccessControl.SemaphoreSecurity>物件，並新增規則，允許和拒絕目前使用者的各種權限。 權限允許包含<xref:System.Security.AccessControl.SemaphoreRights.Modify>， <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions>，和<xref:System.Security.AccessControl.SemaphoreRights.Synchronize>。 這個範例會建立新的規則，針對目前的使用者，包括<xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions>並<xref:System.Security.AccessControl.SemaphoreRights.TakeOwnership>權限，並使用該規則<xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule%2A>方法來移除<xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions>從<xref:System.Security.AccessControl.AccessControlType.Allow>中的規則<xref:System.Security.AccessControl.SemaphoreSecurity>物件。 多餘<xref:System.Security.AccessControl.SemaphoreRights.TakeOwnership>中以滑鼠右鍵`rule`會被忽略。  
  
> [!NOTE]
>  此範例不會附加至安全性物件<xref:System.Threading.Semaphore>物件。 附加安全性物件的範例可在<xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType>和<xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>。  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleAll (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleAll(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleAll (rule As SemaphoreAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleAll(System::Security::AccessControl::SemaphoreAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAccessRuleAll : System.Security.AccessControl.SemaphoreAccessRule -&gt; unit" Usage="semaphoreSecurity.RemoveAccessRuleAll rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" />，指定要搜尋的使用者和 <see cref="T:System.Security.AccessControl.AccessControlType" />。 忽略根據此規則指定的任何權限。</param>
        <summary>搜尋與指定規則具有相同使用者和 <see cref="T:System.Security.AccessControl.AccessControlType" /> (允許或拒絕) 的所有存取控制規則，如果找到的話，便加以移除。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前<xref:System.Security.AccessControl.SemaphoreSecurity>具有相同的使用者以及相同的規則中搜尋物件<xref:System.Security.AccessControl.AccessControlType>的值`rule`。 所指定的任何權限`rule`執行這項搜尋時，會忽略。 如果找不到任何相符的規則，會不採取任何動作。  
  
   
  
## Examples  
 下列程式碼範例顯示<xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll%2A>方法會移除比對使用者的所有規則和<xref:System.Security.AccessControl.AccessControlType>，略過權限。  
  
 此範例會建立<xref:System.Security.AccessControl.SemaphoreSecurity>物件、 將規則，允許和拒絕目前使用者的各種權限，並接著將合併到額外的權限<xref:System.Security.AccessControl.AccessControlType.Allow>規則。 這個範例會建立新的規則，可讓目前的使用者取得擁有權，並使用該規則，移除<xref:System.Security.AccessControl.AccessControlType.Allow>規則從<xref:System.Security.AccessControl.SemaphoreSecurity>物件。  
  
> [!NOTE]
>  此範例不會附加至安全性物件<xref:System.Threading.Semaphore>物件。 附加安全性物件的範例可在<xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType>和<xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>。  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleSpecific (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleSpecific(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleSpecific (rule As SemaphoreAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleSpecific(System::Security::AccessControl::SemaphoreAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAccessRuleSpecific : System.Security.AccessControl.SemaphoreAccessRule -&gt; unit" Usage="semaphoreSecurity.RemoveAccessRuleSpecific rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">要移除的 <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" />。</param>
        <summary>搜尋與指定規則完全相符的存取控制規則，如果找到的話，便加以移除。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此規則會移除完全符合才`rule`中所有的詳細資訊，包括 旗標。 其他規則具有相同的使用者和<xref:System.Security.AccessControl.AccessControlType>不會受到影響。  
  
> [!IMPORTANT]
>  規則表示一或多個基礎的存取控制項目 (ACE)，以及這些項目分割或修改使用者的存取安全性規則時，視需要結合。 因此，規則可能不再存在中特定的表單時加入，並在此情況下<xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific%2A>方法無法將它移除。  
  
   
  
## Examples  
 下列程式碼範例顯示<xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific%2A>方法需要完全相符，才能移除規則，和規則，以允許和拒絕權限會彼此獨立。  
  
 此範例會建立<xref:System.Security.AccessControl.SemaphoreSecurity>物件、 將規則，允許和拒絕目前使用者的各種權限，並接著將合併到額外的權限<xref:System.Security.AccessControl.AccessControlType.Allow>存取規則。 此範例接著會將傳遞的原始<xref:System.Security.AccessControl.AccessControlType.Allow>規則<xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific%2A>方法，並顯示結果，顯示不會刪除。 此範例接著會建構比對的規則<xref:System.Security.AccessControl.AccessControlType.Allow>中的規則<xref:System.Security.AccessControl.SemaphoreSecurity>物件，並成功使用<xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific%2A>方法來移除規則。  
  
> [!NOTE]
>  此範例不會附加至安全性物件<xref:System.Threading.Semaphore>物件。 附加安全性物件的範例可在<xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType>和<xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>。  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRule">
      <MemberSignature Language="C#" Value="public bool RemoveAuditRule (System.Security.AccessControl.SemaphoreAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAuditRule(class System.Security.AccessControl.SemaphoreAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRule(System.Security.AccessControl.SemaphoreAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAuditRule (rule As SemaphoreAuditRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAuditRule(System::Security::AccessControl::SemaphoreAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAuditRule : System.Security.AccessControl.SemaphoreAuditRule -&gt; bool" Usage="semaphoreSecurity.RemoveAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" />，其會指定要搜尋的使用者，以及必須與相符的規則 (如果找到的話) 相容的繼承和傳用旗標集合。 如果找到的話，指定從相容的規則中移除此權限。</param>
        <summary>搜尋具有與指定之規則相同的使用者以及具有相容的繼承和傳用旗標的稽核控制規則。如果找到了相容的規則，則會移除指定之規則中所包含的權限。</summary>
        <returns>如果找到相容的規則，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前<xref:System.Security.AccessControl.SemaphoreSecurity>會搜尋具有相同的使用者的稽核規則`rule`。 如果找到任何這類規則，會採取任何動作，且此方法傳回`false`。 如果找不到相符的規則，其繼承和相容性旗標會檢查在指定的旗標與相容性的`rule`。 如果找到不相容的規則，會採取任何動作，且此方法傳回`false`。 如果找到相容的旗標的規則，在指定的權限`rule`移除相容的規則，且此方法傳回`true`。 如果`rule`指定不包含在相容的規則的權限，這些權限方面會採取任何動作。 如果從相容的規則，會移除所有的權限，整個規則會移除從目前<xref:System.Security.AccessControl.SemaphoreSecurity>物件。  
  
> [!IMPORTANT]
>  雖然您可以藉由建立以指定的號誌的稽核規則的繼承和傳用旗標<xref:System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory%2A>方法，不建議這麼做。 繼承和傳用不具任何意義的具名號誌，而且它們會使稽核規則的維護更為複雜。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleAll (System.Security.AccessControl.SemaphoreAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleAll(class System.Security.AccessControl.SemaphoreAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleAll(System.Security.AccessControl.SemaphoreAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleAll (rule As SemaphoreAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleAll(System::Security::AccessControl::SemaphoreAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAuditRuleAll : System.Security.AccessControl.SemaphoreAuditRule -&gt; unit" Usage="semaphoreSecurity.RemoveAuditRuleAll rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" />，指定要搜尋的使用者。 忽略根據此規則指定的任何權限。</param>
        <summary>搜尋與所指定規則有相同使用者的所有稽核規則，找到以後將其移除。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前<xref:System.Security.AccessControl.SemaphoreSecurity>稽核規則具有相同的使用者搜尋`rule`。 所指定的任何權限`rule`執行這項搜尋時，會忽略。 會移除所有比對規則。 如果找不到任何相符的規則，會不採取任何動作。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleSpecific (System.Security.AccessControl.SemaphoreAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleSpecific(class System.Security.AccessControl.SemaphoreAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.SemaphoreAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleSpecific (rule As SemaphoreAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleSpecific(System::Security::AccessControl::SemaphoreAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAuditRuleSpecific : System.Security.AccessControl.SemaphoreAuditRule -&gt; unit" Usage="semaphoreSecurity.RemoveAuditRuleSpecific rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">要移除的 <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" />。</param>
        <summary>搜尋與指定規則完全相符的稽核規則，如果找到的話，便加以移除。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此規則會移除完全符合才`rule`中所有的詳細資訊，包括 旗標。 不會影響其他的稽核規則相同的使用者。  
  
> [!IMPORTANT]
>  規則表示一或多個基礎的存取控制項目 (ACE)，以及這些項目分割或修改使用者的稽核安全性規則時，視需要結合。 因此，規則可能不再存在中特定的表單時加入，並在此情況下<xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific%2A>方法無法將它移除。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetAccessRule">
      <MemberSignature Language="C#" Value="public void ResetAccessRule (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetAccessRule(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetAccessRule (rule As SemaphoreAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetAccessRule(System::Security::AccessControl::SemaphoreAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.ResetAccessRule : System.Security.AccessControl.SemaphoreAccessRule -&gt; unit" Usage="semaphoreSecurity.ResetAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">要加入的 <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" />。 這個規則指定的使用者會決定在加入這項規則之前要移除的規則。</param>
        <summary>移除與指定規則具有相同使用者的所有存取控制規則 (不論 <see cref="T:System.Security.AccessControl.AccessControlType" /> 為何)，然後加入指定規則。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果沒有使用者符合指定之規則的存取規則`rule`加入。  
  
   
  
## Examples  
 下列程式碼範例示範如何<xref:System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule%2A>方法會取代為相符的項目中指定之規則的比對使用者的所有規則。  
  
 此範例會建立<xref:System.Security.AccessControl.SemaphoreSecurity>物件，並新增規則，允許和拒絕目前使用者的各種權限。 這個範例會建立新的規則，可讓您目前的使用者完整控制，並使用<xref:System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule%2A>方法，以使用新的規則來取代這兩個現有的規則。  
  
> [!NOTE]
>  此範例不會附加至安全性物件<xref:System.Threading.Semaphore>物件。 附加安全性物件的範例可在<xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType>和<xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>。  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.ResetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.ResetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessRule">
      <MemberSignature Language="C#" Value="public void SetAccessRule (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessRule(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.SetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessRule (rule As SemaphoreAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessRule(System::Security::AccessControl::SemaphoreAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.SetAccessRule : System.Security.AccessControl.SemaphoreAccessRule -&gt; unit" Usage="semaphoreSecurity.SetAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">要加入的 <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" />。 這個規則的使用者和 <see cref="T:System.Security.AccessControl.AccessControlType" /> 會決定在加入這項規則之前要移除的規則。</param>
        <summary>移除與指定規則具有相同使用者和 <see cref="T:System.Security.AccessControl.AccessControlType" /> (允許或拒絕) 的所有存取控制規則，然後加入指定規則。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果指定的規則有<xref:System.Security.AccessControl.AccessControlType.Allow>，這個方法的效果是移除所有<xref:System.Security.AccessControl.AccessControlType.Allow>規則指定的使用者，並取代成指定的規則。 如果指定的規則有<xref:System.Security.AccessControl.AccessControlType.Deny>，則所有<xref:System.Security.AccessControl.AccessControlType.Deny>規則指定的使用者會取代指定的規則。  
  
 如果沒有任何規則的使用者並<xref:System.Security.AccessControl.AccessControlType>符合指定之規則`rule`加入。  
  
   
  
## Examples  
 下列程式碼範例示範如何<xref:System.Security.AccessControl.SemaphoreSecurity.SetAccessRule%2A>方法會移除比對這兩個使用者的所有規則和<xref:System.Security.AccessControl.AccessControlType>的`rule`，以取代`rule`。  
  
 此範例會建立<xref:System.Security.AccessControl.SemaphoreSecurity>物件，並新增規則，允許和拒絕目前使用者的各種權限。 這個範例會建立新的規則，可讓您目前的使用者完整控制，並使用<xref:System.Security.AccessControl.SemaphoreSecurity.SetAccessRule%2A>方法來取代現有允許使用新的規則的規則。 不會影響的規則，拒絕存取。  
  
> [!NOTE]
>  此範例不會附加至安全性物件<xref:System.Threading.Semaphore>物件。 附加安全性物件的範例可在<xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType>和<xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>。  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.SetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.SetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.SetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.SetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAuditRule">
      <MemberSignature Language="C#" Value="public void SetAuditRule (System.Security.AccessControl.SemaphoreAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAuditRule(class System.Security.AccessControl.SemaphoreAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.SetAuditRule(System.Security.AccessControl.SemaphoreAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAuditRule (rule As SemaphoreAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAuditRule(System::Security::AccessControl::SemaphoreAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.SetAuditRule : System.Security.AccessControl.SemaphoreAuditRule -&gt; unit" Usage="semaphoreSecurity.SetAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">要加入的 <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" />。 這個規則指定的使用者會決定在加入這項規則之前要移除的規則。</param>
        <summary>移除與指定規則具有相同使用者的所有稽核規則 (不論 <see cref="T:System.Security.AccessControl.AuditFlags" /> 值為何)，然後加入指定規則。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果沒有使用者符合指定之規則的稽核規則`rule`加入。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
  </Members>
</Type>