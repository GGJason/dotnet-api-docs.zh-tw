<Type Name="SemaphoreSecurity" FullName="System.Security.AccessControl.SemaphoreSecurity">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="02041a0b04c0b45af0a829d8bd9904736588668d" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36532334" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class SemaphoreSecurity : System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit SemaphoreSecurity extends System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="DocId" Value="T:System.Security.AccessControl.SemaphoreSecurity" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SemaphoreSecurity&#xA;Inherits NativeObjectSecurity" />
  <TypeSignature Language="C++ CLI" Value="public ref class SemaphoreSecurity sealed : System::Security::AccessControl::NativeObjectSecurity" />
  <TypeSignature Language="F#" Value="type SemaphoreSecurity = class&#xA;    inherit NativeObjectSecurity" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.AccessControl</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.AccessControl.NativeObjectSecurity</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="ff185-101">表示具名號誌 (Semaphore) 的 Windows 存取控制安全性。</span>
      <span class="sxs-lookup">
        <span data-stu-id="ff185-101">Represents the Windows access control security for a named semaphore.</span>
      </span>
      <span data-ttu-id="ff185-102">這個類別無法被繼承。</span>
      <span class="sxs-lookup">
        <span data-stu-id="ff185-102">This class cannot be inherited.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff185-103">A<xref:System.Security.AccessControl.SemaphoreSecurity>物件指定為具名的系統號誌的存取權限，也會指定如何稽核存取嘗試。</span><span class="sxs-lookup"><span data-stu-id="ff185-103">A <xref:System.Security.AccessControl.SemaphoreSecurity> object specifies access rights for a named system semaphore, and also specifies how access attempts are audited.</span></span> <span data-ttu-id="ff185-104">號誌的存取權限會由每個存取規則的規則，以表示<xref:System.Security.AccessControl.SemaphoreAccessRule>物件。</span><span class="sxs-lookup"><span data-stu-id="ff185-104">Access rights to the semaphore are expressed as rules, with each access rule represented by a <xref:System.Security.AccessControl.SemaphoreAccessRule> object.</span></span> <span data-ttu-id="ff185-105">每個稽核規則由<xref:System.Security.AccessControl.SemaphoreAuditRule>物件。</span><span class="sxs-lookup"><span data-stu-id="ff185-105">Each auditing rule is represented by a <xref:System.Security.AccessControl.SemaphoreAuditRule> object.</span></span>  
  
 <span data-ttu-id="ff185-106">這會反映基礎的 Windows 安全性系統，其中每個安全性實體物件都有最多一個判別存取控制清單 (DACL) 控制存取安全的物件，並最多一個系統存取控制清單 (SACL) 指定的權限稽核嘗試。</span><span class="sxs-lookup"><span data-stu-id="ff185-106">This mirrors the underlying Windows security system, in which each securable object has at most one discretionary access control list (DACL) that controls access to the secured object, and at most one system access control list (SACL) that specifies which access attempts are audited.</span></span> <span data-ttu-id="ff185-107">DACL，SACL 會排序清單的指定存取和稽核使用者和群組的存取控制項目 (ACE)。</span><span class="sxs-lookup"><span data-stu-id="ff185-107">The DACL and SACL are ordered lists of access control entries (ACE) that specify access and auditing for users and groups.</span></span> <span data-ttu-id="ff185-108">A<xref:System.Security.AccessControl.SemaphoreAccessRule>或<xref:System.Security.AccessControl.SemaphoreAuditRule>物件可能代表一個以上的 ACE。</span><span class="sxs-lookup"><span data-stu-id="ff185-108">A <xref:System.Security.AccessControl.SemaphoreAccessRule> or <xref:System.Security.AccessControl.SemaphoreAuditRule> object might represent more than one ACE.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ff185-109">A<xref:System.Threading.Semaphore>物件可代表區域號誌或具名的系統號誌。</span><span class="sxs-lookup"><span data-stu-id="ff185-109">A <xref:System.Threading.Semaphore> object can represent a local semaphore or a named system semaphore.</span></span> <span data-ttu-id="ff185-110">Windows 存取控制安全性是有意義，只會針對具名的系統號誌。</span><span class="sxs-lookup"><span data-stu-id="ff185-110">Windows access control security is meaningful only for named system semaphores.</span></span>  
  
 <span data-ttu-id="ff185-111"><xref:System.Security.AccessControl.SemaphoreSecurity>， <xref:System.Security.AccessControl.SemaphoreAccessRule>，和<xref:System.Security.AccessControl.SemaphoreAuditRule>類別隱藏 Acl 和 Ace 的實作詳細資料。</span><span class="sxs-lookup"><span data-stu-id="ff185-111">The <xref:System.Security.AccessControl.SemaphoreSecurity>, <xref:System.Security.AccessControl.SemaphoreAccessRule>, and <xref:System.Security.AccessControl.SemaphoreAuditRule> classes hide the implementation details of ACLs and ACEs.</span></span> <span data-ttu-id="ff185-112">它們可讓您忽略十七不同的 ACE 類型，並正確地維護繼承和存取權限傳播的複雜性。</span><span class="sxs-lookup"><span data-stu-id="ff185-112">They allow you to ignore the seventeen different ACE types and the complexity of correctly maintaining inheritance and propagation of access rights.</span></span> <span data-ttu-id="ff185-113">這些物件也會設計是為了避免下列常見的存取控制項錯誤：</span><span class="sxs-lookup"><span data-stu-id="ff185-113">These objects are also designed to prevent the following common access control errors:</span></span>  
  
-   <span data-ttu-id="ff185-114">建立與 null 的 DACL 的安全性描述元。</span><span class="sxs-lookup"><span data-stu-id="ff185-114">Creating a security descriptor with a null DACL.</span></span> <span data-ttu-id="ff185-115">DACL 的 null 參考可讓任何使用者新增到物件，也有可能產生的阻絕服務攻擊的存取規則。</span><span class="sxs-lookup"><span data-stu-id="ff185-115">A null reference to a DACL allows any user to add access rules to an object, potentially creating a denial-of-service attack.</span></span> <span data-ttu-id="ff185-116">新<xref:System.Security.AccessControl.SemaphoreSecurity>物件永遠會以空的 DACL，它會拒絕所有使用者的所有存取啟動。</span><span class="sxs-lookup"><span data-stu-id="ff185-116">A new <xref:System.Security.AccessControl.SemaphoreSecurity> object always starts with an empty DACL, which denies all access for all users.</span></span>  
  
-   <span data-ttu-id="ff185-117">違反 Ace 的標準順序。</span><span class="sxs-lookup"><span data-stu-id="ff185-117">Violating the canonical ordering of ACEs.</span></span> <span data-ttu-id="ff185-118">如果 DACL 中的 ACE 清單不會保持在標準順序，使用者可能會不小心指定存取受保護的物件。</span><span class="sxs-lookup"><span data-stu-id="ff185-118">If the ACE list in the DACL is not kept in the canonical order, users might inadvertently be given access to the secured object.</span></span> <span data-ttu-id="ff185-119">比方說，拒絕的存取權限必須永遠出現之前允許的存取權限。</span><span class="sxs-lookup"><span data-stu-id="ff185-119">For example, denied access rights must always appear before allowed access rights.</span></span> <span data-ttu-id="ff185-120"><xref:System.Security.AccessControl.SemaphoreSecurity> 物件會在內部維護正確的順序。</span><span class="sxs-lookup"><span data-stu-id="ff185-120"><xref:System.Security.AccessControl.SemaphoreSecurity> objects maintain the correct order internally.</span></span>  
  
-   <span data-ttu-id="ff185-121">管理安全性描述元旗標，它應該只資源管理員的控制下。</span><span class="sxs-lookup"><span data-stu-id="ff185-121">Manipulating security descriptor flags, which should be under resource manager control only.</span></span>  
  
-   <span data-ttu-id="ff185-122">建立無效的 ACE 旗標組合。</span><span class="sxs-lookup"><span data-stu-id="ff185-122">Creating invalid combinations of ACE flags.</span></span>  
  
-   <span data-ttu-id="ff185-123">管理繼承的 Ace。</span><span class="sxs-lookup"><span data-stu-id="ff185-123">Manipulating inherited ACEs.</span></span> <span data-ttu-id="ff185-124">繼承和傳用是由資源管理員，以回應變更您對存取和稽核規則處理。</span><span class="sxs-lookup"><span data-stu-id="ff185-124">Inheritance and propagation are handled by the resource manager, in response to changes you make to access and audit rules.</span></span>  
  
-   <span data-ttu-id="ff185-125">插入 Acl 無意義的 Ace。</span><span class="sxs-lookup"><span data-stu-id="ff185-125">Inserting meaningless ACEs into ACLs.</span></span>  
  
 <span data-ttu-id="ff185-126">不支援.NET 安全性物件的唯一功能是危險的活動，應避免大部分的應用程式開發人員，如下所示：</span><span class="sxs-lookup"><span data-stu-id="ff185-126">The only capabilities not supported by the .NET security objects are dangerous activities that should be avoided by the majority of application developers, such as the following:</span></span>  
  
-   <span data-ttu-id="ff185-127">通常由資源管理員執行的低階工作。</span><span class="sxs-lookup"><span data-stu-id="ff185-127">Low-level tasks that are normally performed by the resource manager.</span></span>  
  
-   <span data-ttu-id="ff185-128">加入或移除存取控制項目不會維護標準順序的方式。</span><span class="sxs-lookup"><span data-stu-id="ff185-128">Adding or removing access control entries in ways that do not maintain the canonical ordering.</span></span>  
  
 <span data-ttu-id="ff185-129">若要修改 Windows 具名號誌的存取控制安全性，請使用<xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType>方法來取得<xref:System.Security.AccessControl.SemaphoreSecurity>物件。</span><span class="sxs-lookup"><span data-stu-id="ff185-129">To modify Windows access control security for a named semaphore, use the <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> method to get the <xref:System.Security.AccessControl.SemaphoreSecurity> object.</span></span> <span data-ttu-id="ff185-130">加入和移除規則，來修改安全性物件，然後使用<xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>方法來重新附加它。</span><span class="sxs-lookup"><span data-stu-id="ff185-130">Modify the security object by adding and removing rules, and then use the <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType> method to reattach it.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ff185-131">您所做的變更<xref:System.Security.AccessControl.SemaphoreSecurity>物件不會影響具名號誌的存取層級直到您呼叫<xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>將更改的安全性物件指派給具名號誌方法。</span><span class="sxs-lookup"><span data-stu-id="ff185-131">Changes you make to a <xref:System.Security.AccessControl.SemaphoreSecurity> object do not affect the access levels of the named semaphore until you call the <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType> method to assign the altered security object to the named semaphore.</span></span>  
  
 <span data-ttu-id="ff185-132">若要從一個號誌的存取控制安全性複製到另一個中，使用<xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType>方法來取得<xref:System.Security.AccessControl.SemaphoreSecurity>表示第一個號誌的存取和稽核規則的物件，然後使用<xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>方法或接受的建構函式<xref:System.Security.AccessControl.SemaphoreSecurity>物件，這些規則將第二個號誌。</span><span class="sxs-lookup"><span data-stu-id="ff185-132">To copy access control security from one semaphore to another, use the <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> method to get a <xref:System.Security.AccessControl.SemaphoreSecurity> object representing the access and audit rules for the first semaphore, then use the <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType> method, or a constructor that accepts a <xref:System.Security.AccessControl.SemaphoreSecurity> object, to assign those rules to the second semaphore.</span></span>  
  
 <span data-ttu-id="ff185-133">中的安全性描述元定義語言 (SDDL) 投資的使用者可以使用<xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A>方法，以設定具名號誌的存取規則和<xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A>方法，以取得字串，代表 SDDL 格式中的存取規則。</span><span class="sxs-lookup"><span data-stu-id="ff185-133">Users with an investment in the security descriptor definition language (SDDL) can use the <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> method to set access rules for a named semaphore, and the <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> method to obtain a string that represents the access rules in SDDL format.</span></span> <span data-ttu-id="ff185-134">建議您不要開發新項目。</span><span class="sxs-lookup"><span data-stu-id="ff185-134">This is not recommended for new development.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ff185-135">Windows 98 或 Windows Millennium Edition 不支援同步處理物件的安全性。</span><span class="sxs-lookup"><span data-stu-id="ff185-135">Security on synchronization objects is not supported for Windows 98 or Windows Millennium Edition.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ff185-136">下列程式碼範例示範之間的分離<xref:System.Security.AccessControl.AccessControlType.Allow>規則和<xref:System.Security.AccessControl.AccessControlType.Deny>規則，並顯示相容的規則中的權限的組合。</span><span class="sxs-lookup"><span data-stu-id="ff185-136">The following code example demonstrates the separation between <xref:System.Security.AccessControl.AccessControlType.Allow> rules and <xref:System.Security.AccessControl.AccessControlType.Deny> rules, and shows the combination of rights in compatible rules.</span></span> <span data-ttu-id="ff185-137">此範例會建立<xref:System.Security.AccessControl.SemaphoreSecurity>物件、 將規則，允許和拒絕各種權限目前的使用者，並顯示規則的結果組。</span><span class="sxs-lookup"><span data-stu-id="ff185-137">The example creates a <xref:System.Security.AccessControl.SemaphoreSecurity> object, adds rules that allow and deny various rights for the current user, and displays the resulting pair of rules.</span></span> <span data-ttu-id="ff185-138">此範例會允許新的權限為目前的使用者，並顯示結果，顯示新的權限，系統會合併與現有<xref:System.Security.AccessControl.AccessControlType.Allow>規則。</span><span class="sxs-lookup"><span data-stu-id="ff185-138">The example then allows new rights for the current user and displays the result, showing that the new rights are merged with the existing <xref:System.Security.AccessControl.AccessControlType.Allow> rule.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ff185-139">此範例不會附加安全性物件至<xref:System.Threading.Semaphore>物件。</span><span class="sxs-lookup"><span data-stu-id="ff185-139">This example does not attach the security object to a <xref:System.Threading.Semaphore> object.</span></span> <span data-ttu-id="ff185-140">中可以找到附加安全性物件的範例<xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType>和<xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ff185-140">Examples that attach security objects can be found in <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> and <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.AddAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.AddAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.AddAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.AddAccessRule/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Security.AccessControl.SemaphoreAccessRule" />
    <altmember cref="T:System.Security.AccessControl.SemaphoreAuditRule" />
    <altmember cref="T:System.Security.AccessControl.SemaphoreRights" />
    <altmember cref="M:System.Threading.Semaphore.GetAccessControl" />
    <altmember cref="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ff185-141">初始化 <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-141">Initializes a new instance of the <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SemaphoreSecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SemaphoreSecurity();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ff185-142">使用預設值，初始化 <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-142">Initializes a new instance of the <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> class with default values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff185-143">新<xref:System.Security.AccessControl.SemaphoreSecurity>物件一律開頭空白的判別存取清單 (DACL)，它會拒絕所有使用者的所有存取。</span><span class="sxs-lookup"><span data-stu-id="ff185-143">A new <xref:System.Security.AccessControl.SemaphoreSecurity> object always starts with an empty discretionary access list (DACL), which denies all access for all users.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ff185-144">Windows 98 或 Windows Millennium Edition 上不支援這個類別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-144">This class is not supported on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SemaphoreSecurity (string name, System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.#ctor(System.String,System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, includeSections As AccessControlSections)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SemaphoreSecurity(System::String ^ name, System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberSignature Language="F#" Value="new System.Security.AccessControl.SemaphoreSecurity : string * System.Security.AccessControl.AccessControlSections -&gt; System.Security.AccessControl.SemaphoreSecurity" Usage="new System.Security.AccessControl.SemaphoreSecurity (name, includeSections)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="ff185-145">要擷取其存取控制安全性規則的系統號誌名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-145">The name of the system semaphore whose access control security rules are to be retrieved.</span>
          </span>
        </param>
        <param name="includeSections">
          <span data-ttu-id="ff185-146">
            <see cref="T:System.Security.AccessControl.AccessControlSections" /> 旗標的組合，指定要擷取的區段。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-146">A combination of <see cref="T:System.Security.AccessControl.AccessControlSections" /> flags specifying the sections to retrieve.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ff185-147">從具有指定名稱的系統號誌，使用指定的存取控制安全性規則區段，初始化 <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-147">Initializes a new instance of the <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> class with the specified sections of the access control security rules from the system semaphore with the specified name.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff185-148">這個建構函式可讓您取得具名的系統號誌的存取控制安全性，而不會先建立<xref:System.Threading.Semaphore>物件。</span><span class="sxs-lookup"><span data-stu-id="ff185-148">This constructor allows you to obtain the access control security for a named system semaphore without first creating a <xref:System.Threading.Semaphore> object.</span></span>  
  
 <span data-ttu-id="ff185-149">使用具名的系統物件時請務必小心。</span><span class="sxs-lookup"><span data-stu-id="ff185-149">Caution must be exercised when working with named system objects.</span></span> <span data-ttu-id="ff185-150">如果是名為系統物件`name`無法信號，可能會擷取其存取控制安全性。</span><span class="sxs-lookup"><span data-stu-id="ff185-150">If there is a system object named `name` that is not a semaphore, its control access security might be retrieved.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ff185-151">Windows 98 或 Windows Millennium Edition 上不支援這個類別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-151">This class is not supported on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="AccessRightType">
      <MemberSignature Language="C#" Value="public override Type AccessRightType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRightType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.SemaphoreSecurity.AccessRightType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRightType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRightType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessRightType : Type" Usage="System.Security.AccessControl.SemaphoreSecurity.AccessRightType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ff185-152">取得 <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> 類別用來表示存取權限的列舉型別 (Enumeration)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-152">Gets the enumeration that the <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> class uses to represent access rights.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ff185-153">
            <see cref="T:System.Type" /> 物件，表示 <see cref="T:System.Security.AccessControl.SemaphoreRights" /> 列舉型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-153">A <see cref="T:System.Type" /> object representing the <see cref="T:System.Security.AccessControl.SemaphoreRights" /> enumeration.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff185-154">類別衍生自<xref:System.Security.AccessControl.ObjectSecurity>類別覆寫<xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A>屬性，並傳回它們以表示的存取權限的類型。</span><span class="sxs-lookup"><span data-stu-id="ff185-154">Classes that derive from the <xref:System.Security.AccessControl.ObjectSecurity> class override the <xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A> property and return the type they use to represent access rights.</span></span> <span data-ttu-id="ff185-155">當您使用陣列或包含多個類型的安全性物件的集合時，使用這個屬性來判斷要用於每個安全性物件的正確的列舉類型。</span><span class="sxs-lookup"><span data-stu-id="ff185-155">When you work with arrays or collections that contain multiple types of security objects, use this property to determine the correct enumeration type to use with each security object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AccessRule AccessRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AccessRule AccessRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AccessControlType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AccessRule ^ AccessRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AccessControlType type);" />
      <MemberSignature Language="F#" Value="abstract member AccessRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AccessControlType -&gt; System.Security.AccessControl.AccessRule&#xA;override this.AccessRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AccessControlType -&gt; System.Security.AccessControl.AccessRule" Usage="semaphoreSecurity.AccessRuleFactory (identityReference, accessMask, isInherited, inheritanceFlags, propagationFlags, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AccessRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="type" Type="System.Security.AccessControl.AccessControlType" />
      </Parameters>
      <Docs>
        <param name="identityReference">
          <span data-ttu-id="ff185-156">
            <see cref="T:System.Security.Principal.IdentityReference" />，可識別套用這個規則的使用者或群組。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-156">An <see cref="T:System.Security.Principal.IdentityReference" /> that identifies the user or group the rule applies to.</span>
          </span>
        </param>
        <param name="accessMask">
          <span data-ttu-id="ff185-157">
            <see cref="T:System.Security.AccessControl.SemaphoreRights" /> 值的位元組合，指定允許或拒絕的存取權限 (轉型成整數)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-157">A bitwise combination of <see cref="T:System.Security.AccessControl.SemaphoreRights" /> values specifying the access rights to allow or deny, cast to an integer.</span>
          </span>
        </param>
        <param name="isInherited">
          <span data-ttu-id="ff185-158">對於具名號誌沒有意義，因為它們沒有階層架構。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-158">Meaningless for named semaphores, because they have no hierarchy.</span>
          </span>
        </param>
        <param name="inheritanceFlags">
          <span data-ttu-id="ff185-159">對於具名號誌沒有意義，因為它們沒有階層架構。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-159">Meaningless for named semaphores, because they have no hierarchy.</span>
          </span>
        </param>
        <param name="propagationFlags">
          <span data-ttu-id="ff185-160">對於具名號誌沒有意義，因為它們沒有階層架構。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-160">Meaningless for named semaphores, because they have no hierarchy.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="ff185-161">其中一個 <see cref="T:System.Security.AccessControl.AccessControlType" /> 值，指定允許還是拒絕權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-161">One of the <see cref="T:System.Security.AccessControl.AccessControlType" /> values specifying whether the rights are allowed or denied.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ff185-162">以指定的存取權限、存取控制和旗標，為指定的使用者建立新的存取控制規則。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-162">Creates a new access control rule for the specified user, with the specified access rights, access control, and flags.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ff185-163">
            <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> 物件，表示指定之使用者的指定權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-163">A <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> object representing the specified rights for the specified user.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff185-164">建立存取控制規則的建議的方式是使用的建構函式<xref:System.Security.AccessControl.SemaphoreAccessRule>類別。</span><span class="sxs-lookup"><span data-stu-id="ff185-164">The recommended way to create access control rules is to use the constructors of the <xref:System.Security.AccessControl.SemaphoreAccessRule> class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ff185-165">雖然繼承和傳播旗標是無意義的具名號誌，就仍然可以指定這是不建議使用，因為它不必要地變得非常複雜的維護的規則，例如藉由干擾規則組合否則，將相容。</span><span class="sxs-lookup"><span data-stu-id="ff185-165">Although inheritance and propagation flags are meaningless for named semaphores, it is still possible to specify them This is not recommended, because it needlessly complicates the maintenance of rules, for example by interfering with the combination of rules that would otherwise be compatible.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ff185-166">
            <paramref name="accessMask" />、<paramref name="inheritanceFlags" />、<paramref name="propagationFlags" /> 或 <paramref name="type" /> 會指定無效的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-166">
              <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" />, or <paramref name="type" /> specifies an invalid value.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ff185-167">
            <paramref name="identityReference" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-167">
              <paramref name="identityReference" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ff185-168">-或-  <paramref name="accessMask" /> 為零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-168">-or-  <paramref name="accessMask" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ff185-169">
            <paramref name="identityReference" /> 既不是 <see cref="T:System.Security.Principal.SecurityIdentifier" /> 型別，也不是可以轉換成 <see cref="T:System.Security.Principal.NTAccount" /> 型別的型別 (例如 <see cref="T:System.Security.Principal.SecurityIdentifier" />)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-169">
              <paramref name="identityReference" /> is neither of type <see cref="T:System.Security.Principal.SecurityIdentifier" />, nor of a type such as <see cref="T:System.Security.Principal.NTAccount" /> that can be converted to type <see cref="T:System.Security.Principal.SecurityIdentifier" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleType">
      <MemberSignature Language="C#" Value="public override Type AccessRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.SemaphoreSecurity.AccessRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRuleType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessRuleType : Type" Usage="System.Security.AccessControl.SemaphoreSecurity.AccessRuleType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ff185-170">取得 <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> 類別用來表示存取規則的型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-170">Gets the type that the <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> class uses to represent access rules.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ff185-171">
            <see cref="T:System.Type" /> 物件，表示 <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> 類別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-171">A <see cref="T:System.Type" /> object representing the <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> class.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff185-172">類別衍生自<xref:System.Security.AccessControl.ObjectSecurity>類別覆寫<xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A>屬性，並傳回它們以表示存取規則的類型。</span><span class="sxs-lookup"><span data-stu-id="ff185-172">Classes that derive from the <xref:System.Security.AccessControl.ObjectSecurity> class override the <xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A> property and return the type they use to represent access rules.</span></span> <span data-ttu-id="ff185-173">當您使用陣列或包含多個類型的安全性物件的集合時，使用這個屬性來判斷用於每個安全性物件的正確的存取規則類型。</span><span class="sxs-lookup"><span data-stu-id="ff185-173">When you work with arrays or collections that contain multiple types of security objects, use this property to determine the correct access rule type to use with each security object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAccessRule">
      <MemberSignature Language="C#" Value="public void AddAccessRule (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAccessRule(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.AddAccessRule(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAccessRule (rule As SemaphoreAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAccessRule(System::Security::AccessControl::SemaphoreAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.AddAccessRule : System.Security.AccessControl.SemaphoreAccessRule -&gt; unit" Usage="semaphoreSecurity.AddAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <span data-ttu-id="ff185-174">要加入的存取控制規則。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-174">The access control rule to add.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ff185-175">搜尋可合併新規則的相符規則。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-175">Searches for a matching rule with which the new rule can be merged.</span>
          </span>
          <span data-ttu-id="ff185-176">如果找不到，就加入新規則。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-176">If none are found, adds the new rule.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff185-177"><xref:System.Security.AccessControl.SemaphoreSecurity.AddAccessRule%2A>方法會搜尋具有相同的使用者或群組及相同的規則<xref:System.Security.AccessControl.AccessControlType>為`rule`。</span><span class="sxs-lookup"><span data-stu-id="ff185-177">The <xref:System.Security.AccessControl.SemaphoreSecurity.AddAccessRule%2A> method searches for rules with the same user or group and the same <xref:System.Security.AccessControl.AccessControlType> as `rule`.</span></span> <span data-ttu-id="ff185-178">如果找不到，`rule`加入。</span><span class="sxs-lookup"><span data-stu-id="ff185-178">If none are found, `rule` is added.</span></span> <span data-ttu-id="ff185-179">如果找到相符的規則是中的權限`rule`會合併與現有的規則。</span><span class="sxs-lookup"><span data-stu-id="ff185-179">If a matching rule is found, the rights in `rule` are merged with the existing rule.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ff185-180">下列程式碼範例示範之間的分離<xref:System.Security.AccessControl.AccessControlType.Allow>規則和<xref:System.Security.AccessControl.AccessControlType.Deny>規則，並顯示相容的規則中的權限的組合。</span><span class="sxs-lookup"><span data-stu-id="ff185-180">The following code example demonstrates the separation between <xref:System.Security.AccessControl.AccessControlType.Allow> rules and <xref:System.Security.AccessControl.AccessControlType.Deny> rules, and shows the combination of rights in compatible rules.</span></span> <span data-ttu-id="ff185-181">此範例會建立<xref:System.Security.AccessControl.SemaphoreSecurity>物件、 將規則，允許和拒絕各種權限目前的使用者，並顯示規則的結果組。</span><span class="sxs-lookup"><span data-stu-id="ff185-181">The example creates a <xref:System.Security.AccessControl.SemaphoreSecurity> object, adds rules that allow and deny various rights for the current user, and displays the resulting pair of rules.</span></span> <span data-ttu-id="ff185-182">此範例會允許新的權限為目前的使用者，並顯示結果，顯示新的權限，系統會合併與現有<xref:System.Security.AccessControl.AccessControlType.Allow>規則。</span><span class="sxs-lookup"><span data-stu-id="ff185-182">The example then allows new rights for the current user and displays the result, showing that the new rights are merged with the existing <xref:System.Security.AccessControl.AccessControlType.Allow> rule.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ff185-183">此範例不會附加安全性物件至<xref:System.Threading.Semaphore>物件。</span><span class="sxs-lookup"><span data-stu-id="ff185-183">This example does not attach the security object to a <xref:System.Threading.Semaphore> object.</span></span> <span data-ttu-id="ff185-184">中可以找到附加安全性物件的範例<xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType>和<xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ff185-184">Examples that attach security objects can be found in <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> and <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.AddAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.AddAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.AddAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.AddAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ff185-185">
            <paramref name="rule" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-185">
              <paramref name="rule" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="AddAuditRule">
      <MemberSignature Language="C#" Value="public void AddAuditRule (System.Security.AccessControl.SemaphoreAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAuditRule(class System.Security.AccessControl.SemaphoreAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.AddAuditRule(System.Security.AccessControl.SemaphoreAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAuditRule (rule As SemaphoreAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAuditRule(System::Security::AccessControl::SemaphoreAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.AddAuditRule : System.Security.AccessControl.SemaphoreAuditRule -&gt; unit" Usage="semaphoreSecurity.AddAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <span data-ttu-id="ff185-186">要加入的稽核規則。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-186">The audit rule to add.</span>
          </span>
          <span data-ttu-id="ff185-187">這個規則指定的使用者會決定搜尋方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-187">The user specified by this rule determines the search.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ff185-188">搜尋可合併新規則的稽核規則。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-188">Searches for an audit rule with which the new rule can be merged.</span>
          </span>
          <span data-ttu-id="ff185-189">如果找不到，就加入新規則。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-189">If none are found, adds the new rule.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff185-190"><xref:System.Security.AccessControl.SemaphoreSecurity.AddAuditRule%2A>方法具有相同的使用者或群組做為規則會搜尋`rule`。</span><span class="sxs-lookup"><span data-stu-id="ff185-190">The <xref:System.Security.AccessControl.SemaphoreSecurity.AddAuditRule%2A> method searches for rules with the same user or group as `rule`.</span></span> <span data-ttu-id="ff185-191">如果找不到，`rule`加入。</span><span class="sxs-lookup"><span data-stu-id="ff185-191">If none are found, `rule` is added.</span></span> <span data-ttu-id="ff185-192">如果找到相符的規則是中的旗標`rule`會合併到現有的規則。</span><span class="sxs-lookup"><span data-stu-id="ff185-192">If a matching rule is found, the flags in `rule` are merged into the existing rule.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AuditRule AuditRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AuditRule AuditRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AuditFlags flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AuditRule ^ AuditRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AuditFlags flags);" />
      <MemberSignature Language="F#" Value="abstract member AuditRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AuditFlags -&gt; System.Security.AccessControl.AuditRule&#xA;override this.AuditRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AuditFlags -&gt; System.Security.AccessControl.AuditRule" Usage="semaphoreSecurity.AuditRuleFactory (identityReference, accessMask, isInherited, inheritanceFlags, propagationFlags, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AuditRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="flags" Type="System.Security.AccessControl.AuditFlags" />
      </Parameters>
      <Docs>
        <param name="identityReference">
          <span data-ttu-id="ff185-193">
            <see cref="T:System.Security.Principal.IdentityReference" />，可識別套用這個規則的使用者或群組。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-193">An <see cref="T:System.Security.Principal.IdentityReference" /> that identifies the user or group the rule applies to.</span>
          </span>
        </param>
        <param name="accessMask">
          <span data-ttu-id="ff185-194">
            <see cref="T:System.Security.AccessControl.SemaphoreRights" /> 值的位元組合，指定要稽核的存取權限 (轉型成整數)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-194">A bitwise combination of <see cref="T:System.Security.AccessControl.SemaphoreRights" /> values specifying the access rights to audit, cast to an integer.</span>
          </span>
        </param>
        <param name="isInherited">
          <span data-ttu-id="ff185-195">命名為等候控制代碼是沒有意義的，因為它們並未具有階層架構。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-195">Meaningless for named wait handles, because they have no hierarchy.</span>
          </span>
        </param>
        <param name="inheritanceFlags">
          <span data-ttu-id="ff185-196">命名為等候控制代碼是沒有意義的，因為它們並未具有階層架構。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-196">Meaningless for named wait handles, because they have no hierarchy.</span>
          </span>
        </param>
        <param name="propagationFlags">
          <span data-ttu-id="ff185-197">命名為等候控制代碼是沒有意義的，因為它們並未具有階層架構。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-197">Meaningless for named wait handles, because they have no hierarchy.</span>
          </span>
        </param>
        <param name="flags">
          <span data-ttu-id="ff185-198">
            <see cref="T:System.Security.AccessControl.AuditFlags" /> 值的位元組合，指定是否要稽核成功存取、失敗存取或兩者皆稽核。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-198">A bitwise combination of <see cref="T:System.Security.AccessControl.AuditFlags" /> values that specify whether to audit successful access, failed access, or both.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ff185-199">以指定要套用規則的使用者的方式，建立新的稽核規則、要稽核的存取權限以及觸發該稽核規則的結果。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-199">Creates a new audit rule, specifying the user the rule applies to, the access rights to audit, and the outcome that triggers the audit rule.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ff185-200">
            <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /> 物件，表示指定之使用者的指定稽核規則。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-200">A <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /> object representing the specified audit rule for the specified user.</span>
          </span>
          <span data-ttu-id="ff185-201">此方法的傳回型別為基底類別 <see cref="T:System.Security.AccessControl.AuditRule" />，但是傳回值可以安全地轉型為衍生類別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-201">The return type of the method is the base class, <see cref="T:System.Security.AccessControl.AuditRule" />, but the return value can be cast safely to the derived class.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff185-202">若要建立的稽核規則的建議的方式是使用的建構函式<xref:System.Security.AccessControl.SemaphoreAuditRule>類別。</span><span class="sxs-lookup"><span data-stu-id="ff185-202">The recommended way to create audit rules is to use the constructors of the <xref:System.Security.AccessControl.SemaphoreAuditRule> class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ff185-203">雖然繼承和傳播旗標是無意義的具名號誌，就仍然可以指定它們。</span><span class="sxs-lookup"><span data-stu-id="ff185-203">Although inheritance and propagation flags are meaningless for named semaphores, it is still possible to specify them.</span></span> <span data-ttu-id="ff185-204">這不是建議，因為它不必要地變得非常複雜的維護的規則，例如藉由干擾原本是相容的規則的組合。</span><span class="sxs-lookup"><span data-stu-id="ff185-204">This is not recommended, because it needlessly complicates the maintenance of rules, for example by interfering with the combination of rules that would otherwise be compatible.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ff185-205">
            <paramref name="accessMask" />、<paramref name="inheritanceFlags" />、<paramref name="propagationFlags" /> 或 <paramref name="flags" /> 會指定無效的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-205">
              <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" />, or <paramref name="flags" /> specifies an invalid value.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ff185-206">
            <paramref name="identityReference" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-206">
              <paramref name="identityReference" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ff185-207">-或-  <paramref name="accessMask" /> 為零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-207">-or-  <paramref name="accessMask" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ff185-208">
            <paramref name="identityReference" /> 既不是 <see cref="T:System.Security.Principal.SecurityIdentifier" /> 型別，也不是可以轉換成 <see cref="T:System.Security.Principal.NTAccount" /> 型別的型別 (例如 <see cref="T:System.Security.Principal.SecurityIdentifier" />)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-208">
              <paramref name="identityReference" /> is neither of type <see cref="T:System.Security.Principal.SecurityIdentifier" />, nor of a type such as <see cref="T:System.Security.Principal.NTAccount" /> that can be converted to type <see cref="T:System.Security.Principal.SecurityIdentifier" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleType">
      <MemberSignature Language="C#" Value="public override Type AuditRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AuditRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.SemaphoreSecurity.AuditRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AuditRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AuditRuleType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AuditRuleType : Type" Usage="System.Security.AccessControl.SemaphoreSecurity.AuditRuleType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ff185-209">取得 <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> 類別用來表示稽核規則的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-209">Gets the type that the <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> class uses to represent audit rules.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ff185-210">
            <see cref="T:System.Type" /> 物件，表示 <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /> 類別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-210">A <see cref="T:System.Type" /> object representing the <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /> class.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff185-211">類別衍生自<xref:System.Security.AccessControl.ObjectSecurity>類別覆寫<xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A>屬性和傳回類型，用以代表稽核權限。</span><span class="sxs-lookup"><span data-stu-id="ff185-211">Classes that derive from the <xref:System.Security.AccessControl.ObjectSecurity> class override the <xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A> property and return the type they use to represent audit rights.</span></span> <span data-ttu-id="ff185-212">當您使用陣列或包含多個類型的安全性物件的集合時，使用這個屬性來判斷用於每個安全性物件的正確的稽核規則類型。</span><span class="sxs-lookup"><span data-stu-id="ff185-212">When you work with arrays or collections that contain multiple types of security objects, use this property to determine the correct audit rule type to use with each security object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRule">
      <MemberSignature Language="C#" Value="public bool RemoveAccessRule (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAccessRule(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAccessRule (rule As SemaphoreAccessRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAccessRule(System::Security::AccessControl::SemaphoreAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAccessRule : System.Security.AccessControl.SemaphoreAccessRule -&gt; bool" Usage="semaphoreSecurity.RemoveAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <span data-ttu-id="ff185-213">
            <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" />，其會指定要搜尋的使用者和 <see cref="T:System.Security.AccessControl.AccessControlType" />，以及必須與相符的規則 (如果找到的話) 相容的繼承和傳用旗標集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-213">A <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> that specifies the user and <see cref="T:System.Security.AccessControl.AccessControlType" /> to search for, and a set of inheritance and propagation flags that a matching rule, if found, must be compatible with.</span>
          </span>
          <span data-ttu-id="ff185-214">如果找到的話，指定從相容的規則中移除此權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-214">Specifies the rights to remove from the compatible rule, if found.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ff185-215">搜尋具有與指定之規則相同的使用者和 <see cref="T:System.Security.AccessControl.AccessControlType" /> (允許或拒絕) 以及具有相容的繼承和傳用旗標的存取控制規則。如果找到這樣的規則，則會移除指定之存取規則中所包含的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-215">Searches for an access control rule with the same user and <see cref="T:System.Security.AccessControl.AccessControlType" /> (allow or deny) as the specified rule, and with compatible inheritance and propagation flags; if such a rule is found, the rights contained in the specified access rule are removed from it.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ff185-216">如果找到相容的規則，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-216">
              <see langword="true" /> if a compatible rule is found; otherwise <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff185-217">目前<xref:System.Security.AccessControl.SemaphoreSecurity>擁有相同的使用者和相同的規則會搜尋<xref:System.Security.AccessControl.AccessControlType>視為`rule`。</span><span class="sxs-lookup"><span data-stu-id="ff185-217">The current <xref:System.Security.AccessControl.SemaphoreSecurity> is searched for a rule that has the same user and the same <xref:System.Security.AccessControl.AccessControlType> value as `rule`.</span></span> <span data-ttu-id="ff185-218">如果找到任何這類規則，會採取任何動作，而且方法會傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="ff185-218">If no such rule is found, no action is taken, and the method returns `false`.</span></span> <span data-ttu-id="ff185-219">如果找到比對規則，其繼承和相容性旗標會檢查在指定的旗標與相容性的`rule`。</span><span class="sxs-lookup"><span data-stu-id="ff185-219">If matching rules are found, their inheritance and compatibility flags are checked for compatibility with the flags specified in `rule`.</span></span> <span data-ttu-id="ff185-220">如果找到不相容的規則，會採取任何動作，而且方法會傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="ff185-220">If no compatible rule is found, no action is taken, and the method returns `false`.</span></span> <span data-ttu-id="ff185-221">如果找到具有相容的旗標的規則，在指定的權限`rule`移除了相容的規則，而且方法會傳回`true`。</span><span class="sxs-lookup"><span data-stu-id="ff185-221">If a rule with compatible flags is found, the rights specified in `rule` are removed from the compatible rule, and the method returns `true`.</span></span> <span data-ttu-id="ff185-222">如果`rule`指定不相容的規則中包含的權限，就會採取任何動作，與這些權限。</span><span class="sxs-lookup"><span data-stu-id="ff185-222">If `rule` specifies rights not contained in the compatible rule, no action is taken with respect to those rights.</span></span> <span data-ttu-id="ff185-223">如果從相容的規則會移除所有的權限，整個規則會移除從目前<xref:System.Security.AccessControl.SemaphoreSecurity>物件。</span><span class="sxs-lookup"><span data-stu-id="ff185-223">If all rights are removed from the compatible rule, the entire rule is removed from the current <xref:System.Security.AccessControl.SemaphoreSecurity> object.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ff185-224">雖然您可以藉由建立它們與指定的號誌的存取規則的繼承和傳播旗標<xref:System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory%2A>，這不建議使用方法。</span><span class="sxs-lookup"><span data-stu-id="ff185-224">Although you can specify inheritance and propagation flags for semaphore access rules, by creating them with the <xref:System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory%2A> method, this is not recommended.</span></span> <span data-ttu-id="ff185-225">繼承和傳播的具名號誌，無意義，請存取規則的維護更為複雜。</span><span class="sxs-lookup"><span data-stu-id="ff185-225">Inheritance and propagation have no meaning for named semaphores, and they make the maintenance of access rules more complicated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ff185-226">下列程式碼範例示範如何使用<xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule%2A>方法中移除的權限從<xref:System.Security.AccessControl.AccessControlType.Allow>規則中<xref:System.Security.AccessControl.SemaphoreSecurity>物件。</span><span class="sxs-lookup"><span data-stu-id="ff185-226">The following code example demonstrates the use of the <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule%2A> method to remove rights from an <xref:System.Security.AccessControl.AccessControlType.Allow> rule in a <xref:System.Security.AccessControl.SemaphoreSecurity> object.</span></span> <span data-ttu-id="ff185-227">它也會顯示中的其他權限`rule`都會被忽略。</span><span class="sxs-lookup"><span data-stu-id="ff185-227">It also shows that other rights in `rule` are ignored.</span></span>  
  
 <span data-ttu-id="ff185-228">此範例會建立<xref:System.Security.AccessControl.SemaphoreSecurity>物件並將加入規則，允許和拒絕目前使用者的各種權限。</span><span class="sxs-lookup"><span data-stu-id="ff185-228">The example creates a <xref:System.Security.AccessControl.SemaphoreSecurity> object and adds rules that allow and deny various rights for the current user.</span></span> <span data-ttu-id="ff185-229">權限允許包含<xref:System.Security.AccessControl.SemaphoreRights.Modify>， <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions>，和<xref:System.Security.AccessControl.SemaphoreRights.Synchronize>。</span><span class="sxs-lookup"><span data-stu-id="ff185-229">The rights allowed include <xref:System.Security.AccessControl.SemaphoreRights.Modify>, <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions>, and <xref:System.Security.AccessControl.SemaphoreRights.Synchronize>.</span></span> <span data-ttu-id="ff185-230">這個範例會建立新的規則，目前的使用者，包括<xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions>和<xref:System.Security.AccessControl.SemaphoreRights.TakeOwnership>權限，並使用與該規則<xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule%2A>方法移除<xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions>從<xref:System.Security.AccessControl.AccessControlType.Allow>規則中<xref:System.Security.AccessControl.SemaphoreSecurity>物件。</span><span class="sxs-lookup"><span data-stu-id="ff185-230">The example then creates a new rule for the current user, including <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions> and <xref:System.Security.AccessControl.SemaphoreRights.TakeOwnership> rights, and uses that rule with the <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule%2A> method to remove <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions> from the <xref:System.Security.AccessControl.AccessControlType.Allow> rule in the <xref:System.Security.AccessControl.SemaphoreSecurity> object.</span></span> <span data-ttu-id="ff185-231">多餘<xref:System.Security.AccessControl.SemaphoreRights.TakeOwnership>中由左至右`rule`會被忽略。</span><span class="sxs-lookup"><span data-stu-id="ff185-231">The extraneous <xref:System.Security.AccessControl.SemaphoreRights.TakeOwnership> right in `rule` is ignored.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ff185-232">此範例不會附加安全性物件至<xref:System.Threading.Semaphore>物件。</span><span class="sxs-lookup"><span data-stu-id="ff185-232">This example does not attach the security object to a <xref:System.Threading.Semaphore> object.</span></span> <span data-ttu-id="ff185-233">中可以找到附加安全性物件的範例<xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType>和<xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ff185-233">Examples that attach security objects can be found in <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> and <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ff185-234">
            <paramref name="rule" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-234">
              <paramref name="rule" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleAll (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleAll(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleAll (rule As SemaphoreAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleAll(System::Security::AccessControl::SemaphoreAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAccessRuleAll : System.Security.AccessControl.SemaphoreAccessRule -&gt; unit" Usage="semaphoreSecurity.RemoveAccessRuleAll rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <span data-ttu-id="ff185-235">
            <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" />，指定要搜尋的使用者和 <see cref="T:System.Security.AccessControl.AccessControlType" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-235">A <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> that specifies the user and <see cref="T:System.Security.AccessControl.AccessControlType" /> to search for.</span>
          </span>
          <span data-ttu-id="ff185-236">忽略根據此規則指定的任何權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-236">Any rights specified by this rule are ignored.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ff185-237">搜尋與指定規則具有相同使用者和 <see cref="T:System.Security.AccessControl.AccessControlType" /> (允許或拒絕) 的所有存取控制規則，如果找到的話，便加以移除。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-237">Searches for all access control rules with the same user and <see cref="T:System.Security.AccessControl.AccessControlType" /> (allow or deny) as the specified rule and, if found, removes them.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff185-238">目前<xref:System.Security.AccessControl.SemaphoreSecurity>具備相同的使用者和相同的規則搜尋物件<xref:System.Security.AccessControl.AccessControlType>視為`rule`。</span><span class="sxs-lookup"><span data-stu-id="ff185-238">The current <xref:System.Security.AccessControl.SemaphoreSecurity> object is searched for rules that have the same user and the same <xref:System.Security.AccessControl.AccessControlType> value as `rule`.</span></span> <span data-ttu-id="ff185-239">指定的任何權限`rule`時執行這項搜尋將會被忽略。</span><span class="sxs-lookup"><span data-stu-id="ff185-239">Any rights specified by `rule` are ignored when performing this search.</span></span> <span data-ttu-id="ff185-240">如果找不到任何對應的規則，會不採取任何動作。</span><span class="sxs-lookup"><span data-stu-id="ff185-240">If no matching rules are found, no action is taken.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ff185-241">下列程式碼範例顯示<xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll%2A>方法移除符合使用者的所有規則和<xref:System.Security.AccessControl.AccessControlType>，略過權限。</span><span class="sxs-lookup"><span data-stu-id="ff185-241">The following code example shows that the <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll%2A> method removes all rules that match user and <xref:System.Security.AccessControl.AccessControlType>, ignoring rights.</span></span>  
  
 <span data-ttu-id="ff185-242">此範例會建立<xref:System.Security.AccessControl.SemaphoreSecurity>物件、 將規則，允許和拒絕各種權限目前的使用者，並接著將合併到其他的權限<xref:System.Security.AccessControl.AccessControlType.Allow>規則。</span><span class="sxs-lookup"><span data-stu-id="ff185-242">The example creates a <xref:System.Security.AccessControl.SemaphoreSecurity> object, adds rules that allow and deny various rights for the current user, and then merges additional rights into the <xref:System.Security.AccessControl.AccessControlType.Allow> rule.</span></span> <span data-ttu-id="ff185-243">這個範例會建立新的規則，可讓目前的使用者取得擁有權，並使用該規則，移除<xref:System.Security.AccessControl.AccessControlType.Allow>規則從<xref:System.Security.AccessControl.SemaphoreSecurity>物件。</span><span class="sxs-lookup"><span data-stu-id="ff185-243">The example then creates a new rule that allows the current user to take ownership, and uses that rule to remove the <xref:System.Security.AccessControl.AccessControlType.Allow> rule from the <xref:System.Security.AccessControl.SemaphoreSecurity> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ff185-244">此範例不會附加安全性物件至<xref:System.Threading.Semaphore>物件。</span><span class="sxs-lookup"><span data-stu-id="ff185-244">This example does not attach the security object to a <xref:System.Threading.Semaphore> object.</span></span> <span data-ttu-id="ff185-245">中可以找到附加安全性物件的範例<xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType>和<xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ff185-245">Examples that attach security objects can be found in <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> and <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ff185-246">
            <paramref name="rule" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-246">
              <paramref name="rule" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleSpecific (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleSpecific(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleSpecific (rule As SemaphoreAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleSpecific(System::Security::AccessControl::SemaphoreAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAccessRuleSpecific : System.Security.AccessControl.SemaphoreAccessRule -&gt; unit" Usage="semaphoreSecurity.RemoveAccessRuleSpecific rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <span data-ttu-id="ff185-247">要移除的 <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-247">The <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> to remove.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ff185-248">搜尋與指定規則完全相符的存取控制規則，如果找到的話，便加以移除。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-248">Searches for an access control rule that exactly matches the specified rule and, if found, removes it.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff185-249">此規則會移除它完全符合時，才`rule`中所有詳細資料，包括旗標。</span><span class="sxs-lookup"><span data-stu-id="ff185-249">The rule is removed only if it exactly matches `rule` in all details, including flags.</span></span> <span data-ttu-id="ff185-250">其他規則具有相同的使用者和<xref:System.Security.AccessControl.AccessControlType>不會受到影響。</span><span class="sxs-lookup"><span data-stu-id="ff185-250">Other rules with the same user and <xref:System.Security.AccessControl.AccessControlType> are not affected.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ff185-251">規則表示一或多個基礎存取控制項目 (ACE)，而且這些項目分割或修改使用者存取安全性規則時，視需要結合。</span><span class="sxs-lookup"><span data-stu-id="ff185-251">A rule represents one or more underlying access control entries (ACE), and these entries are split or combined as necessary when you modify the access security rules for a user.</span></span> <span data-ttu-id="ff185-252">因此，規則不再存在於在特定的表單時加入，然後在此情況下<xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific%2A>方法無法將其移除。</span><span class="sxs-lookup"><span data-stu-id="ff185-252">Thus, a rule might no longer exist in the specific form it had when it was added, and in that case the <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific%2A> method cannot remove it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ff185-253">下列程式碼範例顯示<xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific%2A>方法需要完全相符，才能移除規則，與規則，以允許和拒絕權限會彼此獨立。</span><span class="sxs-lookup"><span data-stu-id="ff185-253">The following code example shows that the <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific%2A> method requires an exact match in order to remove a rule, and that rules to allow and deny rights are independent of each other.</span></span>  
  
 <span data-ttu-id="ff185-254">此範例會建立<xref:System.Security.AccessControl.SemaphoreSecurity>物件、 將規則，允許和拒絕各種權限目前的使用者，並接著將合併到其他的權限<xref:System.Security.AccessControl.AccessControlType.Allow>存取規則。</span><span class="sxs-lookup"><span data-stu-id="ff185-254">The example creates a <xref:System.Security.AccessControl.SemaphoreSecurity> object, adds rules that allow and deny various rights for the current user, and then merges additional rights into the <xref:System.Security.AccessControl.AccessControlType.Allow> access rule.</span></span> <span data-ttu-id="ff185-255">此範例接著會將傳遞的原始<xref:System.Security.AccessControl.AccessControlType.Allow>規則<xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific%2A>方法，並顯示結果，並顯示不會刪除。</span><span class="sxs-lookup"><span data-stu-id="ff185-255">The example then passes the original <xref:System.Security.AccessControl.AccessControlType.Allow> rule to the <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific%2A> method, and displays the results, showing that nothing is deleted.</span></span> <span data-ttu-id="ff185-256">此範例接著會建構規則符合<xref:System.Security.AccessControl.AccessControlType.Allow>規則中<xref:System.Security.AccessControl.SemaphoreSecurity>物件，並已成功使用<xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific%2A>方法來移除規則。</span><span class="sxs-lookup"><span data-stu-id="ff185-256">The example then constructs a rule that matches the <xref:System.Security.AccessControl.AccessControlType.Allow> rule in the <xref:System.Security.AccessControl.SemaphoreSecurity> object, and successfully uses the <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific%2A> method to remove the rule.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ff185-257">此範例不會附加安全性物件至<xref:System.Threading.Semaphore>物件。</span><span class="sxs-lookup"><span data-stu-id="ff185-257">This example does not attach the security object to a <xref:System.Threading.Semaphore> object.</span></span> <span data-ttu-id="ff185-258">中可以找到附加安全性物件的範例<xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType>和<xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ff185-258">Examples that attach security objects can be found in <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> and <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ff185-259">
            <paramref name="rule" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-259">
              <paramref name="rule" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRule">
      <MemberSignature Language="C#" Value="public bool RemoveAuditRule (System.Security.AccessControl.SemaphoreAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAuditRule(class System.Security.AccessControl.SemaphoreAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRule(System.Security.AccessControl.SemaphoreAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAuditRule (rule As SemaphoreAuditRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAuditRule(System::Security::AccessControl::SemaphoreAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAuditRule : System.Security.AccessControl.SemaphoreAuditRule -&gt; bool" Usage="semaphoreSecurity.RemoveAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <span data-ttu-id="ff185-260">
            <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" />，其會指定要搜尋的使用者，以及必須與相符的規則 (如果找到的話) 相容的繼承和傳用旗標集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-260">A <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /> that specifies the user to search for, and a set of inheritance and propagation flags that a matching rule, if found, must be compatible with.</span>
          </span>
          <span data-ttu-id="ff185-261">如果找到的話，指定從相容的規則中移除此權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-261">Specifies the rights to remove from the compatible rule, if found.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ff185-262">搜尋具有與指定之規則相同的使用者以及具有相容的繼承和傳用旗標的稽核控制規則。如果找到了相容的規則，則會移除指定之規則中所包含的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-262">Searches for an audit control rule with the same user as the specified rule, and with compatible inheritance and propagation flags; if a compatible rule is found, the rights contained in the specified rule are removed from it.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ff185-263">如果找到相容的規則，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-263">
              <see langword="true" /> if a compatible rule is found; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff185-264">目前<xref:System.Security.AccessControl.SemaphoreSecurity>搜尋具有相同的使用者的稽核規則`rule`。</span><span class="sxs-lookup"><span data-stu-id="ff185-264">The current <xref:System.Security.AccessControl.SemaphoreSecurity> is searched for an audit rule that has the same user as `rule`.</span></span> <span data-ttu-id="ff185-265">如果找到任何這類規則，會採取任何動作，而且方法會傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="ff185-265">If no such rule is found, no action is taken, and the method returns `false`.</span></span> <span data-ttu-id="ff185-266">如果找到比對規則，其繼承和相容性旗標會檢查在指定的旗標與相容性的`rule`。</span><span class="sxs-lookup"><span data-stu-id="ff185-266">If matching rules are found, their inheritance and compatibility flags are checked for compatibility with the flags specified in `rule`.</span></span> <span data-ttu-id="ff185-267">如果找到不相容的規則，會採取任何動作，而且方法會傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="ff185-267">If no compatible rule is found, no action is taken, and the method returns `false`.</span></span> <span data-ttu-id="ff185-268">如果找到具有相容的旗標的規則，在指定的權限`rule`移除了相容的規則，而且方法會傳回`true`。</span><span class="sxs-lookup"><span data-stu-id="ff185-268">If a rule with compatible flags is found, the rights specified in `rule` are removed from the compatible rule, and the method returns `true`.</span></span> <span data-ttu-id="ff185-269">如果`rule`指定不相容的規則中包含的權限，就會採取任何動作，與這些權限。</span><span class="sxs-lookup"><span data-stu-id="ff185-269">If `rule` specifies rights not contained in the compatible rule, no action is taken with respect to those rights.</span></span> <span data-ttu-id="ff185-270">如果從相容的規則會移除所有的權限，整個規則會移除從目前<xref:System.Security.AccessControl.SemaphoreSecurity>物件。</span><span class="sxs-lookup"><span data-stu-id="ff185-270">If all rights are removed from the compatible rule, the entire rule is removed from the current <xref:System.Security.AccessControl.SemaphoreSecurity> object.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ff185-271">雖然您可以藉由建立它們與指定的號誌的稽核規則的繼承和傳播旗標<xref:System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory%2A>，這不建議使用方法。</span><span class="sxs-lookup"><span data-stu-id="ff185-271">Although you can specify inheritance and propagation flags for semaphore audit rules, by creating them with the <xref:System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory%2A> method, this is not recommended.</span></span> <span data-ttu-id="ff185-272">繼承和傳播的具名號誌，無意義，請稽核規則的維護更為複雜。</span><span class="sxs-lookup"><span data-stu-id="ff185-272">Inheritance and propagation have no meaning for named semaphores, and they make the maintenance of audit rules more complicated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ff185-273">
            <paramref name="rule" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-273">
              <paramref name="rule" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleAll (System.Security.AccessControl.SemaphoreAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleAll(class System.Security.AccessControl.SemaphoreAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleAll(System.Security.AccessControl.SemaphoreAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleAll (rule As SemaphoreAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleAll(System::Security::AccessControl::SemaphoreAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAuditRuleAll : System.Security.AccessControl.SemaphoreAuditRule -&gt; unit" Usage="semaphoreSecurity.RemoveAuditRuleAll rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <span data-ttu-id="ff185-274">
            <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" />，指定要搜尋的使用者。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-274">A <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /> that specifies the user to search for.</span>
          </span>
          <span data-ttu-id="ff185-275">忽略根據此規則指定的任何權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-275">Any rights specified by this rule are ignored.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ff185-276">搜尋與所指定規則有相同使用者的所有稽核規則，找到以後將其移除。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-276">Searches for all audit rules with the same user as the specified rule and, if found, removes them.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff185-277">目前<xref:System.Security.AccessControl.SemaphoreSecurity>搜尋中是否有具有相同的使用者的稽核規則`rule`。</span><span class="sxs-lookup"><span data-stu-id="ff185-277">The current <xref:System.Security.AccessControl.SemaphoreSecurity> is searched for audit rules that have the same user as `rule`.</span></span> <span data-ttu-id="ff185-278">指定的任何權限`rule`時執行這項搜尋將會被忽略。</span><span class="sxs-lookup"><span data-stu-id="ff185-278">Any rights specified by `rule` are ignored when performing this search.</span></span> <span data-ttu-id="ff185-279">會移除所有比對規則。</span><span class="sxs-lookup"><span data-stu-id="ff185-279">All matching rules are removed.</span></span> <span data-ttu-id="ff185-280">如果找不到任何對應的規則，會不採取任何動作。</span><span class="sxs-lookup"><span data-stu-id="ff185-280">If no matching rules are found, no action is taken.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ff185-281">
            <paramref name="rule" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-281">
              <paramref name="rule" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleSpecific (System.Security.AccessControl.SemaphoreAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleSpecific(class System.Security.AccessControl.SemaphoreAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.SemaphoreAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleSpecific (rule As SemaphoreAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleSpecific(System::Security::AccessControl::SemaphoreAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAuditRuleSpecific : System.Security.AccessControl.SemaphoreAuditRule -&gt; unit" Usage="semaphoreSecurity.RemoveAuditRuleSpecific rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <span data-ttu-id="ff185-282">要移除的 <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-282">The <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /> to remove.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ff185-283">搜尋與指定規則完全相符的稽核規則，如果找到的話，便加以移除。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-283">Searches for an audit rule that exactly matches the specified rule and, if found, removes it.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff185-284">此規則會移除它完全符合時，才`rule`中所有詳細資料，包括旗標。</span><span class="sxs-lookup"><span data-stu-id="ff185-284">The rule is removed only if it exactly matches `rule` in all details, including flags.</span></span> <span data-ttu-id="ff185-285">不會影響同一個使用者的其他稽核規則。</span><span class="sxs-lookup"><span data-stu-id="ff185-285">Other audit rules for the same user are not affected.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ff185-286">規則表示一或多個基礎存取控制項目 (ACE)，而且這些項目分割或修改使用者的安全性稽核規則時，視需要結合。</span><span class="sxs-lookup"><span data-stu-id="ff185-286">A rule represents one or more underlying access control entries (ACE), and these entries are split or combined as necessary when you modify the audit security rules for a user.</span></span> <span data-ttu-id="ff185-287">因此，規則不再存在於在特定的表單時加入，然後在此情況下<xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific%2A>方法無法將其移除。</span><span class="sxs-lookup"><span data-stu-id="ff185-287">Thus, a rule might no longer exist in the specific form it had when it was added, and in that case the <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific%2A> method cannot remove it.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ff185-288">
            <paramref name="rule" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-288">
              <paramref name="rule" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ResetAccessRule">
      <MemberSignature Language="C#" Value="public void ResetAccessRule (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetAccessRule(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetAccessRule (rule As SemaphoreAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetAccessRule(System::Security::AccessControl::SemaphoreAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.ResetAccessRule : System.Security.AccessControl.SemaphoreAccessRule -&gt; unit" Usage="semaphoreSecurity.ResetAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <span data-ttu-id="ff185-289">要加入的 <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-289">The <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> to add.</span>
          </span>
          <span data-ttu-id="ff185-290">這個規則指定的使用者會決定在加入這項規則之前要移除的規則。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-290">The user specified by this rule determines the rules to remove before this rule is added.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ff185-291">移除與指定規則具有相同使用者的所有存取控制規則 (不論 <see cref="T:System.Security.AccessControl.AccessControlType" /> 為何)，然後加入指定規則。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-291">Removes all access control rules with the same user as the specified rule, regardless of <see cref="T:System.Security.AccessControl.AccessControlType" />, and then adds the specified rule.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff185-292">如果沒有使用者符合指定之規則的存取規則`rule`加入。</span><span class="sxs-lookup"><span data-stu-id="ff185-292">If there are no access rules whose user matches the specified rule, `rule` is added.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ff185-293">下列程式碼範例示範如何<xref:System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule%2A>方法會取代為指定的比對的規則比對使用者的所有規則。</span><span class="sxs-lookup"><span data-stu-id="ff185-293">The following code example shows how the <xref:System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule%2A> method replaces all rules for the matching user with the rule specified for the match.</span></span>  
  
 <span data-ttu-id="ff185-294">此範例會建立<xref:System.Security.AccessControl.SemaphoreSecurity>物件並將加入規則，允許和拒絕目前使用者的各種權限。</span><span class="sxs-lookup"><span data-stu-id="ff185-294">The example creates a <xref:System.Security.AccessControl.SemaphoreSecurity> object and adds rules that allow and deny various rights for the current user.</span></span> <span data-ttu-id="ff185-295">這個範例會建立新的規則，可讓您目前的使用者完整控制，並使用<xref:System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule%2A>方法，以使用新的規則來取代這兩個現有的規則。</span><span class="sxs-lookup"><span data-stu-id="ff185-295">The example then creates a new rule that allows the current user full control, and uses the <xref:System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule%2A> method to replace both of the existing rules with the new rule.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ff185-296">此範例不會附加安全性物件至<xref:System.Threading.Semaphore>物件。</span><span class="sxs-lookup"><span data-stu-id="ff185-296">This example does not attach the security object to a <xref:System.Threading.Semaphore> object.</span></span> <span data-ttu-id="ff185-297">中可以找到附加安全性物件的範例<xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType>和<xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ff185-297">Examples that attach security objects can be found in <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> and <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.ResetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.ResetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ff185-298">
            <paramref name="rule" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-298">
              <paramref name="rule" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessRule">
      <MemberSignature Language="C#" Value="public void SetAccessRule (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessRule(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.SetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessRule (rule As SemaphoreAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessRule(System::Security::AccessControl::SemaphoreAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.SetAccessRule : System.Security.AccessControl.SemaphoreAccessRule -&gt; unit" Usage="semaphoreSecurity.SetAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <span data-ttu-id="ff185-299">要加入的 <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-299">The <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> to add.</span>
          </span>
          <span data-ttu-id="ff185-300">這個規則的使用者和 <see cref="T:System.Security.AccessControl.AccessControlType" /> 會決定在加入這項規則之前要移除的規則。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-300">The user and <see cref="T:System.Security.AccessControl.AccessControlType" /> of this rule determine the rules to remove before this rule is added.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ff185-301">移除與指定規則具有相同使用者和 <see cref="T:System.Security.AccessControl.AccessControlType" /> (允許或拒絕) 的所有存取控制規則，然後加入指定規則。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-301">Removes all access control rules with the same user and <see cref="T:System.Security.AccessControl.AccessControlType" /> (allow or deny) as the specified rule, and then adds the specified rule.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff185-302">如果指定的規則有<xref:System.Security.AccessControl.AccessControlType.Allow>，這個方法的效果是要移除所有<xref:System.Security.AccessControl.AccessControlType.Allow>規則所指定的使用者，將其取代為指定的規則。</span><span class="sxs-lookup"><span data-stu-id="ff185-302">If the specified rule has <xref:System.Security.AccessControl.AccessControlType.Allow>, the effect of this method is to remove all <xref:System.Security.AccessControl.AccessControlType.Allow> rules for the specified user, replacing them with the specified rule.</span></span> <span data-ttu-id="ff185-303">如果指定的規則有<xref:System.Security.AccessControl.AccessControlType.Deny>，則所有<xref:System.Security.AccessControl.AccessControlType.Deny>規則指定的使用者都取代成指定的規則。</span><span class="sxs-lookup"><span data-stu-id="ff185-303">If the specified rule has <xref:System.Security.AccessControl.AccessControlType.Deny>, all <xref:System.Security.AccessControl.AccessControlType.Deny> rules for the specified user are replaced with the specified rule.</span></span>  
  
 <span data-ttu-id="ff185-304">如果沒有規則的使用者和<xref:System.Security.AccessControl.AccessControlType>符合指定之規則`rule`加入。</span><span class="sxs-lookup"><span data-stu-id="ff185-304">If there are no rules whose user and <xref:System.Security.AccessControl.AccessControlType> match the specified rule, `rule` is added.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ff185-305">下列程式碼範例示範如何<xref:System.Security.AccessControl.SemaphoreSecurity.SetAccessRule%2A>方法移除符合這兩個使用者的所有規則和<xref:System.Security.AccessControl.AccessControlType>的`rule`，取代它們與`rule`。</span><span class="sxs-lookup"><span data-stu-id="ff185-305">The following code example shows how the <xref:System.Security.AccessControl.SemaphoreSecurity.SetAccessRule%2A> method removes all rules that match both the user and the <xref:System.Security.AccessControl.AccessControlType> of `rule`, replacing them with `rule`.</span></span>  
  
 <span data-ttu-id="ff185-306">此範例會建立<xref:System.Security.AccessControl.SemaphoreSecurity>物件並將加入規則，允許和拒絕目前使用者的各種權限。</span><span class="sxs-lookup"><span data-stu-id="ff185-306">The example creates a <xref:System.Security.AccessControl.SemaphoreSecurity> object and adds rules that allow and deny various rights for the current user.</span></span> <span data-ttu-id="ff185-307">這個範例會建立新的規則，可讓您目前的使用者完整控制，並使用<xref:System.Security.AccessControl.SemaphoreSecurity.SetAccessRule%2A>方法來取代現有允許使用新的規則的規則。</span><span class="sxs-lookup"><span data-stu-id="ff185-307">The example then creates a new rule that allows the current user full control, and uses the <xref:System.Security.AccessControl.SemaphoreSecurity.SetAccessRule%2A> method to replace the existing Allow rule with the new rule.</span></span> <span data-ttu-id="ff185-308">不受影響的規則，拒絕存取。</span><span class="sxs-lookup"><span data-stu-id="ff185-308">The rule that denies access is not affected.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ff185-309">此範例不會附加安全性物件至<xref:System.Threading.Semaphore>物件。</span><span class="sxs-lookup"><span data-stu-id="ff185-309">This example does not attach the security object to a <xref:System.Threading.Semaphore> object.</span></span> <span data-ttu-id="ff185-310">中可以找到附加安全性物件的範例<xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType>和<xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ff185-310">Examples that attach security objects can be found in <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> and <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.SetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.SetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.SetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.SetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ff185-311">
            <paramref name="rule" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-311">
              <paramref name="rule" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetAuditRule">
      <MemberSignature Language="C#" Value="public void SetAuditRule (System.Security.AccessControl.SemaphoreAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAuditRule(class System.Security.AccessControl.SemaphoreAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.SetAuditRule(System.Security.AccessControl.SemaphoreAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAuditRule (rule As SemaphoreAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAuditRule(System::Security::AccessControl::SemaphoreAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.SetAuditRule : System.Security.AccessControl.SemaphoreAuditRule -&gt; unit" Usage="semaphoreSecurity.SetAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <span data-ttu-id="ff185-312">要加入的 <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-312">The <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /> to add.</span>
          </span>
          <span data-ttu-id="ff185-313">這個規則指定的使用者會決定在加入這項規則之前要移除的規則。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-313">The user specified by this rule determines the rules to remove before this rule is added.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ff185-314">移除與指定規則具有相同使用者的所有稽核規則 (不論 <see cref="T:System.Security.AccessControl.AuditFlags" /> 值為何)，然後加入指定規則。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-314">Removes all audit rules with the same user as the specified rule, regardless of the <see cref="T:System.Security.AccessControl.AuditFlags" /> value, and then adds the specified rule.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff185-315">如果沒有使用者符合指定之規則的稽核規則`rule`加入。</span><span class="sxs-lookup"><span data-stu-id="ff185-315">If there are no audit rules whose user matches the specified rule, `rule` is added.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ff185-316">
            <paramref name="rule" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff185-316">
              <paramref name="rule" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
  </Members>
</Type>