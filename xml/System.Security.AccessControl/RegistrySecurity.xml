<Type Name="RegistrySecurity" FullName="System.Security.AccessControl.RegistrySecurity">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9bc6f7493d7a9e1de154cf46db0d9c5021e7a5d9" /><Meta Name="ms.sourcegitcommit" Value="220917117f9d774aaa482439aa7324e39dc1f5b6" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="02/25/2019" /><Meta Name="ms.locfileid" Value="56763817" /></Metadata><TypeSignature Language="C#" Value="public sealed class RegistrySecurity : System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit RegistrySecurity extends System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="DocId" Value="T:System.Security.AccessControl.RegistrySecurity" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class RegistrySecurity&#xA;Inherits NativeObjectSecurity" />
  <TypeSignature Language="C++ CLI" Value="public ref class RegistrySecurity sealed : System::Security::AccessControl::NativeObjectSecurity" />
  <TypeSignature Language="F#" Value="type RegistrySecurity = class&#xA;    inherit NativeObjectSecurity" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.AccessControl.NativeObjectSecurity</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示登錄機碼的 Windows 存取控制 (Access Control) 安全性。 這個類別無法被繼承。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Security.AccessControl.RegistrySecurity>物件指定登錄機碼的存取權限，也會指定如何稽核存取嘗試。 登錄機碼的存取權限由每個存取規則的規則，以表示<xref:System.Security.AccessControl.RegistryAccessRule>物件。 每個稽核規則由<xref:System.Security.AccessControl.RegistryAuditRule>物件。  
  
 鏡像處理基礎的 Windows 安全性系統，在其中每個安全性實體的物件具有最多一個判別存取控制清單 (DACL) 控制對受保護的物件，和最多一個系統存取控制清單 (SACL) 指定的權限存取稽核嘗試。 DACL，SACL 會排序清單的指定存取和稽核的使用者和群組的存取控制項目 (ACE)。 A<xref:System.Security.AccessControl.RegistryAccessRule>或<xref:System.Security.AccessControl.RegistryAuditRule>物件可能代表一個以上的 ACE。  
  
> [!NOTE]
>  Windows 存取控制安全性只能套用到登錄機碼。 它無法套用至個別的索引鍵/值組儲存在索引鍵。  
  
 <xref:System.Security.AccessControl.RegistrySecurity>， <xref:System.Security.AccessControl.RegistryAccessRule>，和<xref:System.Security.AccessControl.RegistryAuditRule>類別隱藏實作詳細資料的 Acl 和 Ace。 可讓您略過十七不同 ACE 型別和複雜性的正確維護繼承和傳用的存取權限。 這些物件也可避免下列常見的存取控制錯誤：  
  
-   建立 null DACL 的安全性描述元。 DACL 的 null 參考可讓任何使用者將存取規則加入物件，而可能建立阻斷服務攻擊。 新<xref:System.Security.AccessControl.RegistrySecurity>物件一律開頭空白的 DACL，拒絕對所有使用者的所有存取。  
  
-   違反 Ace 的標準順序。 如果在 DACL 中的 ACE 清單不會保留在標準順序，使用者可能會不小心提供存取受保護的物件。 比方說，拒絕的存取權限必須一律會出現之前允許的存取權限。 <xref:System.Security.AccessControl.RegistrySecurity> 物件會在內部維護正確的順序。  
  
-   管理安全性描述元旗標，這應該是僅資源管理員的控制之下。  
  
-   建立無效的 ACE 旗標組合。  
  
-   操作繼承的 Ace。 繼承和傳用是由資源管理員，以回應變更您對存取和稽核規則處理的。  
  
-   插入 Acl 中的無意義的 Ace。  
  
 不支援.NET 安全性物件的唯一功能是應避免大部分的應用程式開發人員，如下所示使用模擬的危險活動：  
  
-   通常由資源管理員的低層級工作。  
  
-   新增或移除存取控制項目不會維護標準排序的方式。  
  
 若要修改 Windows 登錄機碼的存取控制安全性，請使用<xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType>方法來取得<xref:System.Security.AccessControl.RegistrySecurity>物件。 新增和移除規則，以修改安全性物件，然後使用<xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>方法來重新附加它。  
  
> [!IMPORTANT]
>  您所做的變更<xref:System.Security.AccessControl.RegistrySecurity>物件不會影響登錄機碼的存取層級直到您呼叫<xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>將更改的安全性物件指派到登錄機碼的方法。  
  
 若要從一個登錄機碼的存取控制安全性複製到另一個中，使用<xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType>方法來取得<xref:System.Security.AccessControl.RegistrySecurity>代表第一個登錄機碼的存取和稽核規則的物件，然後使用<xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>方法來指派這些規則以第二個登錄機碼。 您也可以指派規則給第二個登錄機碼與<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A?displayProperty=nameWithType>或是<xref:Microsoft.Win32.RegistryKey.CreateSubKey%2A?displayProperty=nameWithType>採用方法<xref:System.Security.AccessControl.RegistrySecurity>物件參數。  
  
 中的安全性描述元定義語言 (SDDL) 投資的使用者可以使用<xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A>方法，以設定登錄機碼的存取規則和<xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A>方法，以取得字串，表示 SDDL 格式中的存取規則。 這不是建議用於新的開發。  
  
   
  
## Examples  
 本節包含兩個程式碼範例。 第一個範例顯示如何相容的規則合併時新增和移除和第二個顯示繼承和傳用旗標會影響的新增和刪除的規則。  
  
 範例 1  
  
 下列程式碼範例示範如何<xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A>方法會將權限移除相容的規則，以及如何<xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A>方法就會合併相容規則的權限。  
  
 此範例會建立<xref:System.Security.AccessControl.RegistrySecurity>物件，並將規則，可讓目前的使用者加入<xref:System.Security.AccessControl.RegistryRights.ReadKey?displayProperty=nameWithType>權限。 這個範例會建立一個規則，會授與使用者<xref:System.Security.AccessControl.RegistryRights.SetValue?displayProperty=nameWithType>、 具有相同的繼承和傳用權限，做為第一個規則，並使用<xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A>方法來移除這個新的規則，從<xref:System.Security.AccessControl.RegistrySecurity>物件。 <xref:System.Security.AccessControl.RegistryRights.SetValue> 是的構成部分<xref:System.Security.AccessControl.RegistryRights.ReadKey>，因此它移除相容的規則。 中的規則<xref:System.Security.AccessControl.RegistrySecurity>物件會出現，其中顯示剩餘的構成<xref:System.Security.AccessControl.RegistryRights.ReadKey>。  
  
 範例程式碼會接著呼叫<xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A>方法來合併<xref:System.Security.AccessControl.RegistryRights.SetValue>回中的規則以滑鼠右鍵<xref:System.Security.AccessControl.RegistrySecurity>物件。  
  
> [!NOTE]
>  此範例不會附加至安全性物件<xref:Microsoft.Win32.RegistryKey>物件。 在本節中的第二個範例附加安全性物件，並因此執行的範例<xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType>和<xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>。  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRule/VB/source.vb#1)]  
  
 範例 2  
  
 下列程式碼範例示範如何使用繼承和傳用的存取規則。 此範例會建立<xref:System.Security.AccessControl.RegistrySecurity>物件，然後建立並加入兩個規則，具有<xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit>旗標。 第一項規則有任何傳用旗標，而第二個<xref:System.Security.AccessControl.PropagationFlags.NoPropagateInherit>和<xref:System.Security.AccessControl.PropagationFlags.InheritOnly>。  
  
 此程式會顯示在規則<xref:System.Security.AccessControl.RegistrySecurity>物件，然後使用<xref:System.Security.AccessControl.RegistrySecurity>物件來建立子機碼。 該程式建立的子系子機碼和孫系子機碼，然後顯示每一個子機碼的安全性。 最後，程式會刪除測試索引鍵。  
  
 [!code-csharp[System.Security.AccessControl.RegistryAccessRule.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistryAccessRule.ctor2/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistryAccessRule.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistryAccessRule.ctor2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RegistrySecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RegistrySecurity();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>使用預設值，初始化 <see cref="T:System.Security.AccessControl.RegistrySecurity" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新<xref:System.Security.AccessControl.RegistrySecurity>物件永遠會啟動具有空的判別存取清單 (DACL)，拒絕對所有使用者的所有存取。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessRightType">
      <MemberSignature Language="C#" Value="public override Type AccessRightType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRightType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.RegistrySecurity.AccessRightType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRightType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRightType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessRightType : Type" Usage="System.Security.AccessControl.RegistrySecurity.AccessRightType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Security.AccessControl.RegistrySecurity" /> 類別用來表示存取權限的列舉型別。</summary>
        <value><see cref="T:System.Type" /> 物件，表示 <see cref="T:System.Security.AccessControl.RegistryRights" /> 列舉型別。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 衍生自類別<xref:System.Security.AccessControl.ObjectSecurity>類別覆寫<xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A>屬性，並傳回它們用來表示存取權限類型。 當您使用陣列或包含多個類型的安全性物件的集合時，使用這個屬性來判斷要使用每個安全性物件的正確的列舉類型。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AccessRule AccessRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AccessRule AccessRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AccessControlType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AccessRule ^ AccessRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AccessControlType type);" />
      <MemberSignature Language="F#" Value="override this.AccessRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AccessControlType -&gt; System.Security.AccessControl.AccessRule" Usage="registrySecurity.AccessRuleFactory (identityReference, accessMask, isInherited, inheritanceFlags, propagationFlags, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AccessRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="type" Type="System.Security.AccessControl.AccessControlType" />
      </Parameters>
      <Docs>
        <param name="identityReference"><see cref="T:System.Security.Principal.IdentityReference" />，可識別套用這個規則的使用者或群組。</param>
        <param name="accessMask"><see cref="T:System.Security.AccessControl.RegistryRights" /> 值的位元組合，指定允許或拒絕的存取權限 (轉型成整數)。</param>
        <param name="isInherited">布林值，指定規則是否是繼承的。</param>
        <param name="inheritanceFlags"><see cref="T:System.Security.AccessControl.InheritanceFlags" /> 值的位元組合，指定子機碼如何繼承規則。</param>
        <param name="propagationFlags"><see cref="T:System.Security.AccessControl.PropagationFlags" /> 值的位元組合，這些值會修改子機碼繼承規則的方式。 如果 <paramref name="inheritanceFlags" /> 的值為 <see cref="F:System.Security.AccessControl.InheritanceFlags.None" />，則沒有意義。</param>
        <param name="type">其中一個 <see cref="T:System.Security.AccessControl.AccessControlType" /> 值，指定允許還是拒絕權限。</param>
        <summary>以指定的存取權限、存取控制和旗標，為指定的使用者建立新的存取控制規則。</summary>
        <returns><see cref="T:System.Security.AccessControl.RegistryAccessRule" /> 物件，表示指定之使用者的指定權限。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要建立存取控制規則的建議的方式是使用的建構函式<xref:System.Security.AccessControl.RegistryAccessRule>類別。  
  
> [!NOTE]
>  雖然您可以指定<xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit?displayProperty=nameWithType>旗標，請在此情況下沒有意義。 子機碼中的名稱/值組的存取控制的目的，不是個別物件。 名稱/值組的存取權限是由子機碼的權限控制。 此外，因為所有子機碼是容器 （也就是它們可以包含其他子機碼），它們不會受到<xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit>旗標。 最後，指定<xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit>旗標不必要地變得非常複雜的維護的規則，因為它會干擾一般相容規則的組合。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="accessMask" />、<paramref name="inheritanceFlags" />、<paramref name="propagationFlags" /> 或 <paramref name="type" /> 會指定無效的值。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="identityReference" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="accessMask" /> 為零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="identityReference" /> 既不是 <see cref="T:System.Security.Principal.SecurityIdentifier" /> 型別，也不是可以轉換成 <see cref="T:System.Security.Principal.NTAccount" /> 型別的型別 (例如 <see cref="T:System.Security.Principal.SecurityIdentifier" />)。</exception>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleType">
      <MemberSignature Language="C#" Value="public override Type AccessRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.RegistrySecurity.AccessRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRuleType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessRuleType : Type" Usage="System.Security.AccessControl.RegistrySecurity.AccessRuleType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Security.AccessControl.RegistrySecurity" /> 類別用來表示存取規則的型別。</summary>
        <value><see cref="T:System.Type" /> 物件，表示 <see cref="T:System.Security.AccessControl.RegistryAccessRule" /> 類別。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 衍生自類別<xref:System.Security.AccessControl.ObjectSecurity>類別覆寫<xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A>屬性，並傳回它們用來表示存取規則類型。 當您使用陣列或包含多個類型的安全性物件的集合時，使用這個屬性來判斷正確的存取規則型別，若要使用每個安全性物件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAccessRule">
      <MemberSignature Language="C#" Value="public void AddAccessRule (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAccessRule(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.AddAccessRule(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAccessRule (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAccessRule(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.AddAccessRule : System.Security.AccessControl.RegistryAccessRule -&gt; unit" Usage="registrySecurity.AddAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">要加入的存取控制規則。</param>
        <summary>搜尋可合併新規則的相符存取控制。 如果找不到，就加入新規則。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A>方法會搜尋具有相同的使用者或群組和相同的規則<xref:System.Security.AccessControl.AccessControlType>做為`rule`。 如果找不到，`rule`加入。 如果找到相符的規則是中的權限`rule`會與現有的規則合併。  
  
 無法合併規則，如果它們有不同的繼承旗標。 比方說，如果使用者允許讀取權限，但沒有繼承旗標，並<xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A>用來新增規則，讓使用者寫入存取子機碼的繼承 (<xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit?displayProperty=nameWithType>)，無法合併兩個規則。  
  
 使用不同的規則<xref:System.Security.AccessControl.AccessControlType>值永遠不會合併。  
  
 規則的最經濟實惠的方式表達權限。 例如，如果使用者具有<xref:System.Security.AccessControl.RegistryRights.QueryValues>，<xref:System.Security.AccessControl.RegistryRights.Notify>並<xref:System.Security.AccessControl.RegistryRights.ReadPermissions>權限，而且您新增規則，允許<xref:System.Security.AccessControl.RegistryRights.EnumerateSubKeys>權限，使用者擁有的所有構成部分<xref:System.Security.AccessControl.RegistryRights.ReadKey>權限。 如果您查詢使用者的權限，您會看到一個規則，其中包含<xref:System.Security.AccessControl.RegistryRights.ReadKey>權限。 同樣地，如果您移除<xref:System.Security.AccessControl.RegistryRights.EnumerateSubKeys>權限的其他要素<xref:System.Security.AccessControl.RegistryRights.ReadKey>權限將會重新出現。  
  
   
  
## Examples  
 下列程式碼範例會建立登錄存取規則，並將它們加入至<xref:System.Security.AccessControl.RegistrySecurity>物件，顯示如何允許和拒絕權限的規則會有所區隔，而相容的規則相同的類型會合併。  
  
> [!NOTE]
>  此範例不會附加至安全性物件<xref:Microsoft.Win32.RegistryKey>物件。 附加安全性物件的範例可在<xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType>和<xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>。  
  
 程式碼範例示範繼承和傳用旗標，可在<xref:System.Security.AccessControl.RegistryAccessRule>類別。  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.AddAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.AddAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.AddAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.AddAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="AddAuditRule">
      <MemberSignature Language="C#" Value="public void AddAuditRule (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAuditRule(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.AddAuditRule(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAuditRule (rule As RegistryAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAuditRule(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.AddAuditRule : System.Security.AccessControl.RegistryAuditRule -&gt; unit" Usage="registrySecurity.AddAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">要加入的稽核規則。 這個規則指定的使用者會決定搜尋方式。</param>
        <summary>搜尋可合併新規則的稽核規則。 如果找不到，就加入新規則。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.AccessControl.RegistrySecurity.AddAuditRule%2A>方法會搜尋具有相同的使用者或群組做為規則`rule`。 如果找不到，`rule`加入。 如果找到相符的規則是中的旗標`rule`會合併到現有的規則。  
  
 無法合併規則，如果它們有不同的繼承旗標。 如果要寫入的機碼的嘗試失敗，例如稽核特定的使用者，但沒有繼承旗標，和<xref:System.Security.AccessControl.RegistrySecurity.AddAuditRule%2A>用來新增規則，指定相同的使用者，但具有繼承的稽核失敗的嘗試，若要變更權限子機碼 (<xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit?displayProperty=nameWithType>)，無法合併兩個規則。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AuditRule AuditRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AuditRule AuditRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AuditFlags flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AuditRule ^ AuditRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AuditFlags flags);" />
      <MemberSignature Language="F#" Value="override this.AuditRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AuditFlags -&gt; System.Security.AccessControl.AuditRule" Usage="registrySecurity.AuditRuleFactory (identityReference, accessMask, isInherited, inheritanceFlags, propagationFlags, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AuditRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="flags" Type="System.Security.AccessControl.AuditFlags" />
      </Parameters>
      <Docs>
        <param name="identityReference"><see cref="T:System.Security.Principal.IdentityReference" />，可識別套用這個規則的使用者或群組。</param>
        <param name="accessMask"><see cref="T:System.Security.AccessControl.RegistryRights" /> 值的位元組合，指定要稽核的存取權限 (轉型成整數)。</param>
        <param name="isInherited">布林值，指定規則是否是繼承的。</param>
        <param name="inheritanceFlags"><see cref="T:System.Security.AccessControl.InheritanceFlags" /> 值的位元組合，指定子機碼如何繼承規則。</param>
        <param name="propagationFlags"><see cref="T:System.Security.AccessControl.PropagationFlags" /> 值的位元組合，這些值會修改子機碼繼承規則的方式。 如果 <paramref name="inheritanceFlags" /> 的值為 <see cref="F:System.Security.AccessControl.InheritanceFlags.None" />，則沒有意義。</param>
        <param name="flags"><see cref="T:System.Security.AccessControl.AuditFlags" /> 值的位元組合，指定是否要稽核成功存取、失敗存取或兩者皆稽核。</param>
        <summary>建立新的稽核規則，指定套用該規則的使用者、要稽核的存取權限、規則的繼承和傳用，以及觸發規則的結果。</summary>
        <returns><see cref="T:System.Security.AccessControl.RegistryAuditRule" /> 物件，表示指定之使用者的指定稽核規則，而且具有指定的旗標。 此方法的傳回型別為基底類別 <see cref="T:System.Security.AccessControl.AuditRule" />，但是傳回值可以安全地轉型為衍生類別。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要建立的稽核規則的建議的方式是使用的建構函式<xref:System.Security.AccessControl.RegistryAuditRule>類別。  
  
> [!NOTE]
>  雖然您可以指定<xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit?displayProperty=nameWithType>旗標，請在此情況下沒有意義。 基於稽核控制的目的，子機碼中的名稱/值組不是個別的物件。 名稱/值組的稽核權限是由子機碼的權限控制。 此外，因為所有子機碼是容器 （也就是它們可以包含其他子機碼），它們不會受到<xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit>旗標。 最後，指定<xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit>旗標不必要地變得非常複雜的維護的規則，因為它會干擾一般相容規則的組合。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="accessMask" />、<paramref name="inheritanceFlags" />、<paramref name="propagationFlags" /> 或 <paramref name="flags" /> 會指定無效的值。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="identityReference" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="accessMask" /> 為零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="identityReference" /> 既不是 <see cref="T:System.Security.Principal.SecurityIdentifier" /> 型別，也不是可以轉換成 <see cref="T:System.Security.Principal.NTAccount" /> 型別的型別 (例如 <see cref="T:System.Security.Principal.SecurityIdentifier" />)。</exception>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleType">
      <MemberSignature Language="C#" Value="public override Type AuditRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AuditRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.RegistrySecurity.AuditRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AuditRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AuditRuleType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AuditRuleType : Type" Usage="System.Security.AccessControl.RegistrySecurity.AuditRuleType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Security.AccessControl.RegistrySecurity" /> 類別用來表示稽核規則的類型。</summary>
        <value><see cref="T:System.Type" /> 物件，表示 <see cref="T:System.Security.AccessControl.RegistryAuditRule" /> 類別。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 衍生自類別<xref:System.Security.AccessControl.ObjectSecurity>類別覆寫<xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A>屬性，並傳回它們用來表示稽核權限類型。 當您使用陣列或包含多個類型的安全性物件的集合時，使用這個屬性來判斷正確的稽核規則型別，將每個安全性物件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRule">
      <MemberSignature Language="C#" Value="public bool RemoveAccessRule (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAccessRule(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAccessRule (rule As RegistryAccessRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAccessRule(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAccessRule : System.Security.AccessControl.RegistryAccessRule -&gt; bool" Usage="registrySecurity.RemoveAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule"><see cref="T:System.Security.AccessControl.RegistryAccessRule" />，其會指定要搜尋的使用者和 <see cref="T:System.Security.AccessControl.AccessControlType" />，以及必須與相符的規則 (如果找到的話) 相容的繼承和傳用旗標集合。 如果找到的話，指定從相容的規則中移除此權限。</param>
        <summary>搜尋具有與指定之存取規則相同的使用者和 <see cref="T:System.Security.AccessControl.AccessControlType" /> (允許或拒絕) 以及具有相容的繼承和傳用旗標的存取控制規則。如果找到這樣的規則，則會移除指定之存取規則中所包含的權限。</summary>
        <returns>如果找到相容的規則，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前<xref:System.Security.AccessControl.RegistrySecurity>擁有相同的使用者和相同的規則中搜尋<xref:System.Security.AccessControl.AccessControlType>的值`rule`。 如果找到任何這類規則，會採取任何動作，且此方法傳回`false`。 如果找不到相符的規則，其繼承和相容性旗標會檢查在指定的旗標與相容性的`rule`。 如果找到不相容的規則，會採取任何動作，且此方法傳回`false`。 如果找到相容的旗標的規則，在指定的權限`rule`移除相容的規則，且此方法傳回`true`。 如果`rule`指定不包含在相容的規則的權限，這些權限方面會採取任何動作。 如果從相容的規則，會移除所有的權限，整個規則會移除從目前<xref:System.Security.AccessControl.RegistrySecurity>物件。  
  
   
  
## Examples  
 下列程式碼範例示範如何<xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A>方法會將權限移除相容的規則，以及如何<xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A>方法就會合併相容規則的權限。  
  
 此範例會建立<xref:System.Security.AccessControl.RegistrySecurity>物件，並將規則，可讓目前的使用者加入<xref:System.Security.AccessControl.RegistryRights.ReadKey?displayProperty=nameWithType>權限。 這個範例會建立一個規則，會授與使用者<xref:System.Security.AccessControl.RegistryRights.SetValue?displayProperty=nameWithType>、 具有相同的繼承和傳用權限，做為第一個規則，並使用<xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A>方法來移除這個新的規則，從<xref:System.Security.AccessControl.RegistrySecurity>物件。 <xref:System.Security.AccessControl.RegistryRights.SetValue> 是的構成部分<xref:System.Security.AccessControl.RegistryRights.ReadKey>，因此它移除相容的規則。 中的規則<xref:System.Security.AccessControl.RegistrySecurity>物件會出現，其中顯示剩餘的構成<xref:System.Security.AccessControl.RegistryRights.ReadKey>。  
  
 範例程式碼會接著呼叫<xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A>方法來合併<xref:System.Security.AccessControl.RegistryRights.SetValue>回中的規則以滑鼠右鍵<xref:System.Security.AccessControl.RegistrySecurity>物件。  
  
> [!NOTE]
>  此範例不會附加至安全性物件<xref:Microsoft.Win32.RegistryKey>物件。 在本節中的第二個範例附加安全性物件，並因此執行的範例<xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>。  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleAll (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleAll(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleAll (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleAll(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAccessRuleAll : System.Security.AccessControl.RegistryAccessRule -&gt; unit" Usage="registrySecurity.RemoveAccessRuleAll rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule"><see cref="T:System.Security.AccessControl.RegistryAccessRule" />，指定要搜尋的使用者和 <see cref="T:System.Security.AccessControl.AccessControlType" />。 這個規則所指定的任何權限、繼承旗標或傳用旗標都會被忽略。</param>
        <summary>搜尋與指定規則具有相同使用者和 <see cref="T:System.Security.AccessControl.AccessControlType" /> (允許或拒絕) 的所有存取控制規則，如果找到的話，便加以移除。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前<xref:System.Security.AccessControl.RegistrySecurity>具有相同的使用者以及相同的規則中搜尋<xref:System.Security.AccessControl.AccessControlType>的值`rule`。 任何權限、 繼承旗標或指定的傳用旗標`rule`執行這項搜尋時，會忽略。 如果找不到任何相符的規則，會不採取任何動作。  
  
 例如，如果使用者有多個規則，允許以不同的繼承和傳用旗標的各種權限，您可以移除所有這些規則建立<xref:System.Security.AccessControl.RegistryAccessRule>物件，指定使用者和<xref:System.Security.AccessControl.AccessControlType.Allow?displayProperty=nameWithType>、 以任何任意的權限和旗標並傳遞至該規則<xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll%2A>方法。  
  
   
  
## Examples  
 下列程式碼範例顯示<xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll%2A>方法會移除比對使用者的所有規則和<xref:System.Security.AccessControl.AccessControlType>，略過權限和旗標。  
  
 此範例會建立<xref:System.Security.AccessControl.RegistrySecurity>物件，並新增規則，允許和拒絕目前的使用者，使用不同的繼承和傳用旗標的各種權限。 這個範例會建立新的規則，可讓目前的使用者取得擁有權，並將傳遞至該規則<xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll%2A>方法以移除 允許存取的兩個規則。  
  
> [!NOTE]
>  此範例不會附加至安全性物件<xref:Microsoft.Win32.RegistryKey>物件。 請參閱<xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType>方法和<xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>方法。  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleSpecific (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleSpecific(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleSpecific (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleSpecific(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAccessRuleSpecific : System.Security.AccessControl.RegistryAccessRule -&gt; unit" Usage="registrySecurity.RemoveAccessRuleSpecific rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">要移除的 <see cref="T:System.Security.AccessControl.RegistryAccessRule" />。</param>
        <summary>搜尋與指定規則完全相符的存取控制規則，如果找到的話，便加以移除。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此規則會移除完全符合才`rule`中所有的詳細資訊，包括 旗標。 其他規則具有相同的使用者和<xref:System.Security.AccessControl.AccessControlType>不會受到影響。  
  
> [!IMPORTANT]
>  規則表示一或多個基礎的存取控制項目 (ACE)，以及這些項目分割或修改使用者的存取安全性規則時，視需要結合。 因此，規則可能不再存在中特定的表單時加入，並在此情況下<xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific%2A>方法無法將它移除。  
  
   
  
## Examples  
 下列程式碼範例顯示<xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific%2A>方法移除規則，只有當它完全符合。  
  
 此範例會建立兩個規則可讓不同的權限。 規則會有相容的繼承和傳用旗標，因此當加入第二個規則合併的第一個。 此範例會呼叫<xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific%2A>方法，並指定第一個規則，但因為合併的規則沒有符合任何規則。 此範例接著會呼叫<xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A>從合併的規則，然後最後呼叫的方法來移除第二個規則<xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific%2A>方法來移除第一個規則。  
  
> [!NOTE]
>  此範例不會附加至安全性物件<xref:Microsoft.Win32.RegistryKey>物件。 請參閱<xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType>方法和<xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>方法。  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRule">
      <MemberSignature Language="C#" Value="public bool RemoveAuditRule (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAuditRule(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAuditRule(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAuditRule (rule As RegistryAuditRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAuditRule(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAuditRule : System.Security.AccessControl.RegistryAuditRule -&gt; bool" Usage="registrySecurity.RemoveAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule"><see cref="T:System.Security.AccessControl.RegistryAuditRule" />，其會指定要搜尋的使用者，以及必須與相符的規則 (如果找到的話) 相容的繼承和傳用旗標集合。 如果找到的話，指定從相容的規則中移除此權限。</param>
        <summary>搜尋具有與指定之規則相同的使用者以及具有相容的繼承和傳用旗標的稽核控制規則。如果找到了相容的規則，則會移除指定之規則中所包含的權限。</summary>
        <returns>如果找到相容的規則，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前<xref:System.Security.AccessControl.RegistrySecurity>會搜尋具有相同的使用者的稽核規則`rule`。 如果找到任何這類規則，會採取任何動作，且此方法傳回`false`。 如果找不到相符的規則，其繼承和相容性旗標會檢查在指定的旗標與相容性的`rule`。 如果找到不相容的規則，會採取任何動作，且此方法傳回`false`。 如果找到相容的旗標的規則，在指定的權限`rule`移除相容的規則，且此方法傳回`true`。 如果`rule`指定不包含在相容的規則的權限，這些權限方面會採取任何動作。 如果從相容的規則，會移除所有的權限，整個規則會移除從目前<xref:System.Security.AccessControl.RegistrySecurity>物件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleAll (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleAll(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleAll (rule As RegistryAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleAll(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAuditRuleAll : System.Security.AccessControl.RegistryAuditRule -&gt; unit" Usage="registrySecurity.RemoveAuditRuleAll rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule"><see cref="T:System.Security.AccessControl.RegistryAuditRule" />，指定要搜尋的使用者。 這個規則所指定的任何權限、繼承旗標或傳用旗標都會被忽略。</param>
        <summary>搜尋與所指定規則有相同使用者的所有稽核規則，找到以後將其移除。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前<xref:System.Security.AccessControl.RegistrySecurity>稽核規則具有相同的使用者搜尋`rule`。 任何權限、 繼承旗標或指定的傳用旗標`rule`執行這項搜尋時，會忽略。 如果找不到任何相符的規則，會不採取任何動作。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleSpecific (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleSpecific(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleSpecific (rule As RegistryAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleSpecific(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAuditRuleSpecific : System.Security.AccessControl.RegistryAuditRule -&gt; unit" Usage="registrySecurity.RemoveAuditRuleSpecific rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">要移除的 <see cref="T:System.Security.AccessControl.RegistryAuditRule" />。</param>
        <summary>搜尋與指定規則完全相符的稽核規則，如果找到的話，便加以移除。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此規則會移除完全符合才`rule`中所有的詳細資訊，包括 旗標。 不會影響其他的稽核規則相同的使用者。  
  
> [!IMPORTANT]
>  規則表示一或多個基礎的存取控制項目 (ACE)，以及這些項目分割或修改使用者的稽核安全性規則時，視需要結合。 因此，規則可能不再存在中特定的表單時加入，並在此情況下<xref:System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific%2A>方法無法將它移除。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetAccessRule">
      <MemberSignature Language="C#" Value="public void ResetAccessRule (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetAccessRule(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.ResetAccessRule(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetAccessRule (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetAccessRule(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.ResetAccessRule : System.Security.AccessControl.RegistryAccessRule -&gt; unit" Usage="registrySecurity.ResetAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">要加入的 <see cref="T:System.Security.AccessControl.RegistryAccessRule" />。 這個規則指定的使用者會決定在加入這項規則之前要移除的規則。</param>
        <summary>移除與指定規則具有相同使用者的所有存取控制規則 (不論 <see cref="T:System.Security.AccessControl.AccessControlType" /> 為何)，然後加入指定規則。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果沒有使用者符合指定之規則的存取規則`rule`加入。  
  
   
  
## Examples  
 下列程式碼範例示範如何<xref:System.Security.AccessControl.RegistrySecurity.ResetAccessRule%2A>方法會取代為相符的項目中指定之規則的比對使用者的所有規則。  
  
 此範例會建立<xref:System.Security.AccessControl.RegistrySecurity>物件，並新增規則，允許和拒絕目前的使用者，使用不同的繼承和傳用旗標的各種權限。 這個範例會建立新的規則，可讓目前使用者只能讀取機碼，並使用<xref:System.Security.AccessControl.RegistrySecurity.ResetAccessRule%2A>方法，以移除使用者的所有規則和它們取代成新的規則。  
  
> [!NOTE]
>  此範例不會附加至安全性物件<xref:Microsoft.Win32.RegistryKey>物件。 請參閱<xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType>方法和<xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>方法。  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.ResetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.ResetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.ResetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.ResetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAccessRule">
      <MemberSignature Language="C#" Value="public void SetAccessRule (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessRule(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.SetAccessRule(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessRule (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessRule(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.SetAccessRule : System.Security.AccessControl.RegistryAccessRule -&gt; unit" Usage="registrySecurity.SetAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">要加入的 <see cref="T:System.Security.AccessControl.RegistryAccessRule" />。 這個規則的使用者和 <see cref="T:System.Security.AccessControl.AccessControlType" /> 會決定在加入這項規則之前要移除的規則。</param>
        <summary>移除與指定規則具有相同使用者和 <see cref="T:System.Security.AccessControl.AccessControlType" /> (允許或拒絕) 的所有存取控制規則，然後加入指定規則。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果指定的規則有<xref:System.Security.AccessControl.AccessControlType.Allow>，這個方法的效果是移除所有<xref:System.Security.AccessControl.AccessControlType.Allow>規則指定的使用者，並取代成指定的規則。 如果指定的規則有<xref:System.Security.AccessControl.AccessControlType.Deny>，則所有<xref:System.Security.AccessControl.AccessControlType.Deny>規則指定的使用者會取代指定的規則。  
  
 如果沒有任何規則的使用者並<xref:System.Security.AccessControl.AccessControlType>符合指定之規則`rule`加入。  
  
   
  
## Examples  
 下列程式碼範例顯示<xref:System.Security.AccessControl.RegistrySecurity.SetAccessRule%2A>方法會移除比對這兩個使用者的所有規則而<xref:System.Security.AccessControl.AccessControlType>的`rule`，而忽略權限和旗標，並取代它們與`rule`。  
  
 此範例會建立<xref:System.Security.AccessControl.RegistrySecurity>物件，並新增規則，允許和拒絕目前的使用者，使用不同的繼承和傳用旗標的各種權限。 這個範例會建立新的規則，可讓目前使用者只能讀取機碼，並使用<xref:System.Security.AccessControl.RegistrySecurity.SetAccessRule%2A>方法，以移除 允許存取的兩個規則，並將其取代為新的規則。 不會影響的規則，拒絕存取。  
  
> [!NOTE]
>  此範例不會附加至安全性物件<xref:Microsoft.Win32.RegistryKey>物件。 請參閱<xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType>方法和<xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>方法。  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.SetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.SetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.SetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.SetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAuditRule">
      <MemberSignature Language="C#" Value="public void SetAuditRule (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAuditRule(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.SetAuditRule(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAuditRule (rule As RegistryAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAuditRule(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.SetAuditRule : System.Security.AccessControl.RegistryAuditRule -&gt; unit" Usage="registrySecurity.SetAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">要加入的 <see cref="T:System.Security.AccessControl.RegistryAuditRule" />。 這個規則指定的使用者會決定在加入這項規則之前要移除的規則。</param>
        <summary>移除與指定規則具有相同使用者的所有稽核規則 (不論 <see cref="T:System.Security.AccessControl.AuditFlags" /> 值為何)，然後加入指定規則。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果沒有使用者符合指定之規則的稽核規則`rule`加入。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
  </Members>
</Type>