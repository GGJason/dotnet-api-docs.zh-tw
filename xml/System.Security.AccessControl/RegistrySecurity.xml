<Type Name="RegistrySecurity" FullName="System.Security.AccessControl.RegistrySecurity">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e52f3b248c05ba047d59c24d923733a12bfa7839" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30490732" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class RegistrySecurity : System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit RegistrySecurity extends System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="DocId" Value="T:System.Security.AccessControl.RegistrySecurity" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class RegistrySecurity&#xA;Inherits NativeObjectSecurity" />
  <TypeSignature Language="C++ CLI" Value="public ref class RegistrySecurity sealed : System::Security::AccessControl::NativeObjectSecurity" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.AccessControl.NativeObjectSecurity</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="76de9-101">表示登錄機碼的 Windows 存取控制 (Access Control) 安全性。</span>
      <span class="sxs-lookup">
        <span data-stu-id="76de9-101">Represents the Windows access control security for a registry key.</span>
      </span>
      <span data-ttu-id="76de9-102">這個類別無法被繼承。</span>
      <span class="sxs-lookup">
        <span data-stu-id="76de9-102">This class cannot be inherited.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="76de9-103">A<xref:System.Security.AccessControl.RegistrySecurity>物件指定的登錄機碼的存取權限，也會指定如何稽核存取嘗試。</span><span class="sxs-lookup"><span data-stu-id="76de9-103">A <xref:System.Security.AccessControl.RegistrySecurity> object specifies access rights for a registry key, and also specifies how access attempts are audited.</span></span> <span data-ttu-id="76de9-104">登錄機碼的存取權限會由每個存取規則的規則，以表示<xref:System.Security.AccessControl.RegistryAccessRule>物件。</span><span class="sxs-lookup"><span data-stu-id="76de9-104">Access rights to the registry key are expressed as rules, with each access rule represented by a <xref:System.Security.AccessControl.RegistryAccessRule> object.</span></span> <span data-ttu-id="76de9-105">每個稽核規則由<xref:System.Security.AccessControl.RegistryAuditRule>物件。</span><span class="sxs-lookup"><span data-stu-id="76de9-105">Each auditing rule is represented by a <xref:System.Security.AccessControl.RegistryAuditRule> object.</span></span>  
  
 <span data-ttu-id="76de9-106">這會反映基礎的 Windows 安全性系統，其中每個安全性實體物件都有最多一個判別存取控制清單 (DACL) 控制存取安全的物件，並最多一個系統存取控制清單 (SACL) 指定的權限稽核嘗試。</span><span class="sxs-lookup"><span data-stu-id="76de9-106">This mirrors the underlying Windows security system, in which each securable object has at most one discretionary access control list (DACL) that controls access to the secured object, and at most one system access control list (SACL) that specifies which access attempts are audited.</span></span> <span data-ttu-id="76de9-107">DACL，SACL 會排序清單的指定存取和稽核使用者和群組的存取控制項目 (ACE)。</span><span class="sxs-lookup"><span data-stu-id="76de9-107">The DACL and SACL are ordered lists of access control entries (ACE) that specify access and auditing for users and groups.</span></span> <span data-ttu-id="76de9-108">A<xref:System.Security.AccessControl.RegistryAccessRule>或<xref:System.Security.AccessControl.RegistryAuditRule>物件可能代表一個以上的 ACE。</span><span class="sxs-lookup"><span data-stu-id="76de9-108">A <xref:System.Security.AccessControl.RegistryAccessRule> or <xref:System.Security.AccessControl.RegistryAuditRule> object might represent more than one ACE.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="76de9-109">Windows 存取控制安全性只能套用到登錄機碼。</span><span class="sxs-lookup"><span data-stu-id="76de9-109">Windows access control security can only be applied to registry keys.</span></span> <span data-ttu-id="76de9-110">它無法套用至個別的索引鍵/值組儲存在索引鍵。</span><span class="sxs-lookup"><span data-stu-id="76de9-110">It cannot be applied to individual key/value pairs stored in a key.</span></span>  
  
 <span data-ttu-id="76de9-111"><xref:System.Security.AccessControl.RegistrySecurity>， <xref:System.Security.AccessControl.RegistryAccessRule>，和<xref:System.Security.AccessControl.RegistryAuditRule>類別隱藏 Acl 和 Ace 的實作詳細資料。</span><span class="sxs-lookup"><span data-stu-id="76de9-111">The <xref:System.Security.AccessControl.RegistrySecurity>, <xref:System.Security.AccessControl.RegistryAccessRule>, and <xref:System.Security.AccessControl.RegistryAuditRule> classes hide the implementation details of ACLs and ACEs.</span></span> <span data-ttu-id="76de9-112">它們可讓您忽略十七不同的 ACE 類型，並正確地維護繼承和存取權限傳播的複雜性。</span><span class="sxs-lookup"><span data-stu-id="76de9-112">They allow you to ignore the seventeen different ACE types and the complexity of correctly maintaining inheritance and propagation of access rights.</span></span> <span data-ttu-id="76de9-113">這些物件也會設計是為了避免下列常見的存取控制項錯誤：</span><span class="sxs-lookup"><span data-stu-id="76de9-113">These objects are also designed to prevent the following common access control errors:</span></span>  
  
-   <span data-ttu-id="76de9-114">建立與 null 的 DACL 的安全性描述元。</span><span class="sxs-lookup"><span data-stu-id="76de9-114">Creating a security descriptor with a null DACL.</span></span> <span data-ttu-id="76de9-115">DACL 的 null 參考可讓任何使用者新增到物件，也有可能產生的阻絕服務攻擊的存取規則。</span><span class="sxs-lookup"><span data-stu-id="76de9-115">A null reference to a DACL allows any user to add access rules to an object, potentially creating a denial-of-service attack.</span></span> <span data-ttu-id="76de9-116">新<xref:System.Security.AccessControl.RegistrySecurity>物件永遠會以空的 DACL，它會拒絕所有使用者的所有存取啟動。</span><span class="sxs-lookup"><span data-stu-id="76de9-116">A new <xref:System.Security.AccessControl.RegistrySecurity> object always starts with an empty DACL, which denies all access for all users.</span></span>  
  
-   <span data-ttu-id="76de9-117">違反 Ace 的標準順序。</span><span class="sxs-lookup"><span data-stu-id="76de9-117">Violating the canonical ordering of ACEs.</span></span> <span data-ttu-id="76de9-118">如果 DACL 中的 ACE 清單不會保持在標準順序，使用者可能會不小心指定存取受保護的物件。</span><span class="sxs-lookup"><span data-stu-id="76de9-118">If the ACE list in the DACL is not kept in the canonical order, users might inadvertently be given access to the secured object.</span></span> <span data-ttu-id="76de9-119">比方說，拒絕的存取權限必須永遠出現之前允許的存取權限。</span><span class="sxs-lookup"><span data-stu-id="76de9-119">For example, denied access rights must always appear before allowed access rights.</span></span> <span data-ttu-id="76de9-120"><xref:System.Security.AccessControl.RegistrySecurity> 物件會在內部維護正確的順序。</span><span class="sxs-lookup"><span data-stu-id="76de9-120"><xref:System.Security.AccessControl.RegistrySecurity> objects maintain the correct order internally.</span></span>  
  
-   <span data-ttu-id="76de9-121">管理安全性描述元旗標，它應該只資源管理員的控制下。</span><span class="sxs-lookup"><span data-stu-id="76de9-121">Manipulating security descriptor flags, which should be under resource manager control only.</span></span>  
  
-   <span data-ttu-id="76de9-122">建立無效的 ACE 旗標組合。</span><span class="sxs-lookup"><span data-stu-id="76de9-122">Creating invalid combinations of ACE flags.</span></span>  
  
-   <span data-ttu-id="76de9-123">管理繼承的 Ace。</span><span class="sxs-lookup"><span data-stu-id="76de9-123">Manipulating inherited ACEs.</span></span> <span data-ttu-id="76de9-124">繼承和傳用是由資源管理員，以回應變更您對存取和稽核規則處理。</span><span class="sxs-lookup"><span data-stu-id="76de9-124">Inheritance and propagation are handled by the resource manager, in response to changes you make to access and audit rules.</span></span>  
  
-   <span data-ttu-id="76de9-125">插入 Acl 無意義的 Ace。</span><span class="sxs-lookup"><span data-stu-id="76de9-125">Inserting meaningless ACEs into ACLs.</span></span>  
  
 <span data-ttu-id="76de9-126">不支援.NET 安全性物件的唯一功能是危險的活動，應避免大部分的應用程式開發人員，如下所示：</span><span class="sxs-lookup"><span data-stu-id="76de9-126">The only capabilities not supported by the .NET security objects are dangerous activities that should be avoided by the majority of application developers, such as the following:</span></span>  
  
-   <span data-ttu-id="76de9-127">通常由資源管理員執行的低階工作。</span><span class="sxs-lookup"><span data-stu-id="76de9-127">Low-level tasks that are normally performed by the resource manager.</span></span>  
  
-   <span data-ttu-id="76de9-128">加入或移除存取控制項目不會維護標準順序的方式。</span><span class="sxs-lookup"><span data-stu-id="76de9-128">Adding or removing access control entries in ways that do not maintain the canonical ordering.</span></span>  
  
 <span data-ttu-id="76de9-129">若要修改 Windows 登錄機碼的存取控制安全性，請使用<xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType>方法來取得<xref:System.Security.AccessControl.RegistrySecurity>物件。</span><span class="sxs-lookup"><span data-stu-id="76de9-129">To modify Windows access control security for a registry key, use the <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> method to get the <xref:System.Security.AccessControl.RegistrySecurity> object.</span></span> <span data-ttu-id="76de9-130">加入和移除規則，來修改安全性物件，然後使用<xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>方法來重新附加它。</span><span class="sxs-lookup"><span data-stu-id="76de9-130">Modify the security object by adding and removing rules, and then use the <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> method to reattach it.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="76de9-131">您所做的變更<xref:System.Security.AccessControl.RegistrySecurity>物件不會影響登錄機碼的存取層級直到您呼叫<xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>將登錄機碼變更後的安全性物件的方法。</span><span class="sxs-lookup"><span data-stu-id="76de9-131">Changes you make to a <xref:System.Security.AccessControl.RegistrySecurity> object do not affect the access levels of the registry key until you call the <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> method to assign the altered security object to the registry key.</span></span>  
  
 <span data-ttu-id="76de9-132">若要從一個登錄機碼的存取控制安全性複製到另一個中，使用<xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType>方法來取得<xref:System.Security.AccessControl.RegistrySecurity>表示第一個登錄機碼的存取和稽核規則的物件，然後使用<xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>將這些規則來指派方法第二個登錄機碼。</span><span class="sxs-lookup"><span data-stu-id="76de9-132">To copy access control security from one registry key to another, use the <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> method to get a <xref:System.Security.AccessControl.RegistrySecurity> object representing the access and audit rules for the first registry key, and then use the <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> method to assign those rules to the second registry key.</span></span> <span data-ttu-id="76de9-133">您也可以指派規則給第二個登錄機碼<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A?displayProperty=nameWithType>或<xref:Microsoft.Win32.RegistryKey.CreateSubKey%2A?displayProperty=nameWithType>採用方法<xref:System.Security.AccessControl.RegistrySecurity>物件參數。</span><span class="sxs-lookup"><span data-stu-id="76de9-133">You can also assign the rules to a second registry key with an <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A?displayProperty=nameWithType> or <xref:Microsoft.Win32.RegistryKey.CreateSubKey%2A?displayProperty=nameWithType> method that takes a <xref:System.Security.AccessControl.RegistrySecurity> object parameter.</span></span>  
  
 <span data-ttu-id="76de9-134">中的安全性描述元定義語言 (SDDL) 投資的使用者可以使用<xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A>方法，以設定的登錄機碼的存取規則和<xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A>方法，以取得字串，代表 SDDL 格式中的存取規則。</span><span class="sxs-lookup"><span data-stu-id="76de9-134">Users with an investment in the security descriptor definition language (SDDL) can use the <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> method to set access rules for a registry key, and the <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> method to obtain a string that represents the access rules in SDDL format.</span></span> <span data-ttu-id="76de9-135">建議您不要開發新項目。</span><span class="sxs-lookup"><span data-stu-id="76de9-135">This is not recommended for new development.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="76de9-136">本節包含兩個程式碼範例。</span><span class="sxs-lookup"><span data-stu-id="76de9-136">This section contains two code examples.</span></span> <span data-ttu-id="76de9-137">第一個範例顯示如何相容的規則合併時加入和移除和第二個顯示繼承和傳播旗標會影響的新增和刪除的規則。</span><span class="sxs-lookup"><span data-stu-id="76de9-137">The first example shows how compatible rules merge when added and removed, and the second shows how inheritance and propagation flags affect the addition and deletion of rules.</span></span>  
  
 <span data-ttu-id="76de9-138">範例 1</span><span class="sxs-lookup"><span data-stu-id="76de9-138">Example 1</span></span>  
  
 <span data-ttu-id="76de9-139">下列程式碼範例示範如何<xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A>方法會將權限移除相容的規則，以及如何<xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A>方法就會合併相容規則的權限。</span><span class="sxs-lookup"><span data-stu-id="76de9-139">The following code example shows how the <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> method removes rights from a compatible rule, and how the <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> method merges rights with compatible rules.</span></span>  
  
 <span data-ttu-id="76de9-140">此範例會建立<xref:System.Security.AccessControl.RegistrySecurity>物件，並加入規則，可讓目前使用者<xref:System.Security.AccessControl.RegistryRights.ReadKey?displayProperty=nameWithType>權限。</span><span class="sxs-lookup"><span data-stu-id="76de9-140">The example creates a <xref:System.Security.AccessControl.RegistrySecurity> object and adds a rule that allows the current user <xref:System.Security.AccessControl.RegistryRights.ReadKey?displayProperty=nameWithType> rights.</span></span> <span data-ttu-id="76de9-141">這個範例會建立一個規則，會授與使用者<xref:System.Security.AccessControl.RegistryRights.SetValue?displayProperty=nameWithType>使用相同的繼承和傳播權限做為第一個規則，並使用<xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A>方法來移除此新的規則從<xref:System.Security.AccessControl.RegistrySecurity>物件。</span><span class="sxs-lookup"><span data-stu-id="76de9-141">The example then creates a rule that grants the user <xref:System.Security.AccessControl.RegistryRights.SetValue?displayProperty=nameWithType>, with the same inheritance and propagation rights as the first rule, and uses the <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> method to remove this new rule from the <xref:System.Security.AccessControl.RegistrySecurity> object.</span></span> <span data-ttu-id="76de9-142"><xref:System.Security.AccessControl.RegistryRights.SetValue> 是的構成部分<xref:System.Security.AccessControl.RegistryRights.ReadKey>，因此它會移除從相容的規則。</span><span class="sxs-lookup"><span data-stu-id="76de9-142"><xref:System.Security.AccessControl.RegistryRights.SetValue> is a constituent of <xref:System.Security.AccessControl.RegistryRights.ReadKey>, so it is removed from the compatible rule.</span></span> <span data-ttu-id="76de9-143">中的規則<xref:System.Security.AccessControl.RegistrySecurity>物件會出現，其中顯示剩餘的構成<xref:System.Security.AccessControl.RegistryRights.ReadKey>。</span><span class="sxs-lookup"><span data-stu-id="76de9-143">The rules in the <xref:System.Security.AccessControl.RegistrySecurity> object are displayed, showing the remaining constituents of <xref:System.Security.AccessControl.RegistryRights.ReadKey>.</span></span>  
  
 <span data-ttu-id="76de9-144">範例程式碼接著呼叫<xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A>方法，將合併<xref:System.Security.AccessControl.RegistryRights.SetValue>回規則中以滑鼠右鍵<xref:System.Security.AccessControl.RegistrySecurity>物件。</span><span class="sxs-lookup"><span data-stu-id="76de9-144">The example code then calls the <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> method to merge the <xref:System.Security.AccessControl.RegistryRights.SetValue> right back into the rule in the <xref:System.Security.AccessControl.RegistrySecurity> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="76de9-145">此範例不會附加安全性物件至<xref:Microsoft.Win32.RegistryKey>物件。</span><span class="sxs-lookup"><span data-stu-id="76de9-145">This example does not attach the security object to a <xref:Microsoft.Win32.RegistryKey> object.</span></span> <span data-ttu-id="76de9-146">此節中的第二個範例附加安全性物件，並因此做範例<xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType>和<xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="76de9-146">The second example in this section attaches a security object, and so do the examples in <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> and <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRule/VB/source.vb#1)]  
  
 <span data-ttu-id="76de9-147">範例 2</span><span class="sxs-lookup"><span data-stu-id="76de9-147">Example 2</span></span>  
  
 <span data-ttu-id="76de9-148">下列程式碼範例示範繼承和傳播的存取規則。</span><span class="sxs-lookup"><span data-stu-id="76de9-148">The following code example demonstrates access rules with inheritance and propagation.</span></span> <span data-ttu-id="76de9-149">此範例會建立<xref:System.Security.AccessControl.RegistrySecurity>物件，然後建立並加入兩個規則，具有<xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit>旗標。</span><span class="sxs-lookup"><span data-stu-id="76de9-149">The example creates a <xref:System.Security.AccessControl.RegistrySecurity> object, then creates and adds two rules that have the <xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit> flag.</span></span> <span data-ttu-id="76de9-150">第一個規則包含沒有傳播旗標，而第二個則包含<xref:System.Security.AccessControl.PropagationFlags.NoPropagateInherit>和<xref:System.Security.AccessControl.PropagationFlags.InheritOnly>。</span><span class="sxs-lookup"><span data-stu-id="76de9-150">The first rule has no propagation flags, while the second has <xref:System.Security.AccessControl.PropagationFlags.NoPropagateInherit> and <xref:System.Security.AccessControl.PropagationFlags.InheritOnly>.</span></span>  
  
 <span data-ttu-id="76de9-151">程式會顯示在規則<xref:System.Security.AccessControl.RegistrySecurity>物件，然後使用<xref:System.Security.AccessControl.RegistrySecurity>物件以建立子機碼。</span><span class="sxs-lookup"><span data-stu-id="76de9-151">The program displays the rules in the <xref:System.Security.AccessControl.RegistrySecurity> object, and then uses the <xref:System.Security.AccessControl.RegistrySecurity> object to create a subkey.</span></span> <span data-ttu-id="76de9-152">程式建立子系子機碼和孫系子機碼，然後顯示每一個子機碼的安全性。</span><span class="sxs-lookup"><span data-stu-id="76de9-152">The program creates a child subkey and a grandchild subkey, then displays the security for each subkey.</span></span> <span data-ttu-id="76de9-153">最後，程式會刪除測試金鑰。</span><span class="sxs-lookup"><span data-stu-id="76de9-153">Finally, the program deletes the test keys.</span></span>  
  
 [!code-csharp[System.Security.AccessControl.RegistryAccessRule.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistryAccessRule.ctor2/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistryAccessRule.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistryAccessRule.ctor2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RegistrySecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RegistrySecurity();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="76de9-154">使用預設值，初始化 <see cref="T:System.Security.AccessControl.RegistrySecurity" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-154">Initializes a new instance of the <see cref="T:System.Security.AccessControl.RegistrySecurity" /> class with default values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="76de9-155">新<xref:System.Security.AccessControl.RegistrySecurity>物件一律開頭空白的判別存取清單 (DACL)，它會拒絕所有使用者的所有存取。</span><span class="sxs-lookup"><span data-stu-id="76de9-155">A new <xref:System.Security.AccessControl.RegistrySecurity> object always starts with an empty discretionary access list (DACL), which denies all access for all users.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessRightType">
      <MemberSignature Language="C#" Value="public override Type AccessRightType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRightType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.RegistrySecurity.AccessRightType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRightType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRightType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="76de9-156">取得 <see cref="T:System.Security.AccessControl.RegistrySecurity" /> 類別用來表示存取權限的列舉型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-156">Gets the enumeration type that the <see cref="T:System.Security.AccessControl.RegistrySecurity" /> class uses to represent access rights.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="76de9-157">
            <see cref="T:System.Type" /> 物件，表示 <see cref="T:System.Security.AccessControl.RegistryRights" /> 列舉型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-157">A <see cref="T:System.Type" /> object representing the <see cref="T:System.Security.AccessControl.RegistryRights" /> enumeration.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="76de9-158">類別衍生自<xref:System.Security.AccessControl.ObjectSecurity>類別覆寫<xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A>屬性，並傳回它們以表示的存取權限的類型。</span><span class="sxs-lookup"><span data-stu-id="76de9-158">Classes that derive from the <xref:System.Security.AccessControl.ObjectSecurity> class override the <xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A> property and return the type they use to represent access rights.</span></span> <span data-ttu-id="76de9-159">當您使用陣列或包含多個類型的安全性物件的集合時，使用這個屬性來判斷要用於每個安全性物件的正確的列舉類型。</span><span class="sxs-lookup"><span data-stu-id="76de9-159">When you work with arrays or collections that contain multiple types of security objects, use this property to determine the correct enumeration type to use with each security object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AccessRule AccessRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AccessRule AccessRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AccessControlType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AccessRule ^ AccessRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AccessControlType type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AccessRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="type" Type="System.Security.AccessControl.AccessControlType" />
      </Parameters>
      <Docs>
        <param name="identityReference">
          <span data-ttu-id="76de9-160">
            <see cref="T:System.Security.Principal.IdentityReference" />，可識別套用這個規則的使用者或群組。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-160">An <see cref="T:System.Security.Principal.IdentityReference" /> that identifies the user or group the rule applies to.</span>
          </span>
        </param>
        <param name="accessMask">
          <span data-ttu-id="76de9-161">
            <see cref="T:System.Security.AccessControl.RegistryRights" /> 值的位元組合，指定允許或拒絕的存取權限 (轉型成整數)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-161">A bitwise combination of <see cref="T:System.Security.AccessControl.RegistryRights" /> values specifying the access rights to allow or deny, cast to an integer.</span>
          </span>
        </param>
        <param name="isInherited">
          <span data-ttu-id="76de9-162">布林值，指定規則是否是繼承的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-162">A Boolean value specifying whether the rule is inherited.</span>
          </span>
        </param>
        <param name="inheritanceFlags">
          <span data-ttu-id="76de9-163">
            <see cref="T:System.Security.AccessControl.InheritanceFlags" /> 值的位元組合，指定子機碼如何繼承規則。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-163">A bitwise combination of <see cref="T:System.Security.AccessControl.InheritanceFlags" /> values specifying how the rule is inherited by subkeys.</span>
          </span>
        </param>
        <param name="propagationFlags">
          <span data-ttu-id="76de9-164">
            <see cref="T:System.Security.AccessControl.PropagationFlags" /> 值的位元組合，這些值會修改子機碼繼承規則的方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-164">A bitwise combination of <see cref="T:System.Security.AccessControl.PropagationFlags" /> values that modify the way the rule is inherited by subkeys.</span>
          </span>
          <span data-ttu-id="76de9-165">如果 <c>inheritanceFlags</c> 的值為 <see cref="F:System.Security.AccessControl.InheritanceFlags.None" />，則沒有意義。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-165">Meaningless if the value of <c>inheritanceFlags</c> is <see cref="F:System.Security.AccessControl.InheritanceFlags.None" />.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="76de9-166">其中一個 <see cref="T:System.Security.AccessControl.AccessControlType" /> 值，指定允許還是拒絕權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-166">One of the <see cref="T:System.Security.AccessControl.AccessControlType" /> values specifying whether the rights are allowed or denied.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="76de9-167">以指定的存取權限、存取控制和旗標，為指定的使用者建立新的存取控制規則。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-167">Creates a new access control rule for the specified user, with the specified access rights, access control, and flags.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="76de9-168">
            <see cref="T:System.Security.AccessControl.RegistryAccessRule" /> 物件，表示指定之使用者的指定權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-168">A <see cref="T:System.Security.AccessControl.RegistryAccessRule" /> object representing the specified rights for the specified user.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="76de9-169">建立存取控制規則的建議的方式是使用的建構函式<xref:System.Security.AccessControl.RegistryAccessRule>類別。</span><span class="sxs-lookup"><span data-stu-id="76de9-169">The recommended way to create access control rules is to use the constructors of the <xref:System.Security.AccessControl.RegistryAccessRule> class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="76de9-170">雖然您可以指定<xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit?displayProperty=nameWithType>旗標，請在此情況下沒有點。</span><span class="sxs-lookup"><span data-stu-id="76de9-170">Although you can specify the <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit?displayProperty=nameWithType> flag, there is no point in doing so.</span></span> <span data-ttu-id="76de9-171">存取控制項目的子機碼中的名稱/值組不是個別的物件。</span><span class="sxs-lookup"><span data-stu-id="76de9-171">For the purposes of access control, the name/value pairs in a subkey are not separate objects.</span></span> <span data-ttu-id="76de9-172">名稱/值組的存取權限是由子機碼的權限控制。</span><span class="sxs-lookup"><span data-stu-id="76de9-172">The access rights to name/value pairs are controlled by the rights of the subkey.</span></span> <span data-ttu-id="76de9-173">此外，因為所有子機碼是容器 （也就是它們可以包含其他子機碼），它們不會影響<xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit>旗標。</span><span class="sxs-lookup"><span data-stu-id="76de9-173">Furthermore, since all subkeys are containers (that is, they can contain other subkeys), they are not affected by the <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> flag.</span></span> <span data-ttu-id="76de9-174">最後，指定<xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit>旗標不必要地變得非常複雜的維護的規則，因為它會干擾一般相容規則的組合。</span><span class="sxs-lookup"><span data-stu-id="76de9-174">Finally, specifying the <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> flag needlessly complicates the maintenance of rules, because it interferes with the normal combination of compatible rules.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="76de9-175">
            <paramref name="accessMask" />、<paramref name="inheritanceFlags" />、<paramref name="propagationFlags" /> 或 <paramref name="type" /> 會指定無效的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-175">
              <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" />, or <paramref name="type" /> specifies an invalid value.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="76de9-176">
            <paramref name="identityReference" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-176">
              <paramref name="identityReference" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="76de9-177">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-177">-or-</span>
          </span>
          <span data-ttu-id="76de9-178">
            <paramref name="accessMask" /> 為零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-178">
              <paramref name="accessMask" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="76de9-179">
            <paramref name="identityReference" /> 既不是 <see cref="T:System.Security.Principal.SecurityIdentifier" /> 型別，也不是可以轉換成 <see cref="T:System.Security.Principal.NTAccount" /> 型別的型別 (例如 <see cref="T:System.Security.Principal.SecurityIdentifier" />)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-179">
              <paramref name="identityReference" /> is neither of type <see cref="T:System.Security.Principal.SecurityIdentifier" />, nor of a type such as <see cref="T:System.Security.Principal.NTAccount" /> that can be converted to type <see cref="T:System.Security.Principal.SecurityIdentifier" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleType">
      <MemberSignature Language="C#" Value="public override Type AccessRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.RegistrySecurity.AccessRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRuleType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="76de9-180">取得 <see cref="T:System.Security.AccessControl.RegistrySecurity" /> 類別用來表示存取規則的型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-180">Gets the type that the <see cref="T:System.Security.AccessControl.RegistrySecurity" /> class uses to represent access rules.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="76de9-181">
            <see cref="T:System.Type" /> 物件，表示 <see cref="T:System.Security.AccessControl.RegistryAccessRule" /> 類別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-181">A <see cref="T:System.Type" /> object representing the <see cref="T:System.Security.AccessControl.RegistryAccessRule" /> class.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="76de9-182">類別衍生自<xref:System.Security.AccessControl.ObjectSecurity>類別覆寫<xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A>屬性，並傳回它們以表示存取規則的類型。</span><span class="sxs-lookup"><span data-stu-id="76de9-182">Classes that derive from the <xref:System.Security.AccessControl.ObjectSecurity> class override the <xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A> property and return the type they use to represent access rules.</span></span> <span data-ttu-id="76de9-183">當您使用陣列或包含多個類型的安全性物件的集合時，使用這個屬性來判斷用於每個安全性物件的正確的存取規則類型。</span><span class="sxs-lookup"><span data-stu-id="76de9-183">When you work with arrays or collections that contain multiple types of security objects, use this property to determine the correct access rule type to use with each security object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAccessRule">
      <MemberSignature Language="C#" Value="public void AddAccessRule (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAccessRule(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.AddAccessRule(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAccessRule (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAccessRule(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <span data-ttu-id="76de9-184">要加入的存取控制規則。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-184">The access control rule to add.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="76de9-185">搜尋可合併新規則的相符存取控制。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-185">Searches for a matching access control with which the new rule can be merged.</span>
          </span>
          <span data-ttu-id="76de9-186">如果找不到，就加入新規則。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-186">If none are found, adds the new rule.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="76de9-187"><xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A>方法會搜尋具有相同的使用者或群組及相同的規則<xref:System.Security.AccessControl.AccessControlType>為`rule`。</span><span class="sxs-lookup"><span data-stu-id="76de9-187">The <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> method searches for rules with the same user or group and the same <xref:System.Security.AccessControl.AccessControlType> as `rule`.</span></span> <span data-ttu-id="76de9-188">如果找不到，`rule`加入。</span><span class="sxs-lookup"><span data-stu-id="76de9-188">If none are found, `rule` is added.</span></span> <span data-ttu-id="76de9-189">如果找到相符的規則是中的權限`rule`會合併與現有的規則。</span><span class="sxs-lookup"><span data-stu-id="76de9-189">If a matching rule is found, the rights in `rule` are merged with the existing rule.</span></span>  
  
 <span data-ttu-id="76de9-190">如果它們有不同的繼承旗標，無法合併的規則。</span><span class="sxs-lookup"><span data-stu-id="76de9-190">Rules cannot be merged if they have different inheritance flags.</span></span> <span data-ttu-id="76de9-191">例如，如果允許任何的繼承旗標的讀取權限的使用者和<xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A>用來新增規則，讓使用者寫入權限，與子機碼的繼承 (<xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit?displayProperty=nameWithType>)，無法合併兩個規則。</span><span class="sxs-lookup"><span data-stu-id="76de9-191">For example, if a user is allowed read access with no inheritance flags, and <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> is used to add a rule giving the user write access with inheritance for subkeys (<xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit?displayProperty=nameWithType>), the two rules cannot be merged.</span></span>  
  
 <span data-ttu-id="76de9-192">使用不同的規則<xref:System.Security.AccessControl.AccessControlType>值永遠不會合併。</span><span class="sxs-lookup"><span data-stu-id="76de9-192">Rules with different <xref:System.Security.AccessControl.AccessControlType> values are never merged.</span></span>  
  
 <span data-ttu-id="76de9-193">規則的最經濟的方式來表達權限。</span><span class="sxs-lookup"><span data-stu-id="76de9-193">Rules express rights in the most economical way.</span></span> <span data-ttu-id="76de9-194">例如，如果使用者具有<xref:System.Security.AccessControl.RegistryRights.QueryValues>，<xref:System.Security.AccessControl.RegistryRights.Notify>和<xref:System.Security.AccessControl.RegistryRights.ReadPermissions>權限，而且您將加入規則，允許<xref:System.Security.AccessControl.RegistryRights.EnumerateSubKeys>權限，使用者擁有所有的構成部分<xref:System.Security.AccessControl.RegistryRights.ReadKey>權限。</span><span class="sxs-lookup"><span data-stu-id="76de9-194">For example, if a user has <xref:System.Security.AccessControl.RegistryRights.QueryValues>, <xref:System.Security.AccessControl.RegistryRights.Notify> and <xref:System.Security.AccessControl.RegistryRights.ReadPermissions> rights, and you add a rule allowing <xref:System.Security.AccessControl.RegistryRights.EnumerateSubKeys> rights, the user has all the constituent parts of <xref:System.Security.AccessControl.RegistryRights.ReadKey> rights.</span></span> <span data-ttu-id="76de9-195">如果您查詢的使用者權限，您會看到一個規則，其中包含<xref:System.Security.AccessControl.RegistryRights.ReadKey>權限。</span><span class="sxs-lookup"><span data-stu-id="76de9-195">If you query the user's rights, you will see a rule containing <xref:System.Security.AccessControl.RegistryRights.ReadKey> rights.</span></span> <span data-ttu-id="76de9-196">同樣地，如果您移除<xref:System.Security.AccessControl.RegistryRights.EnumerateSubKeys>權限的其他結構成分<xref:System.Security.AccessControl.RegistryRights.ReadKey>權限就會再次出現。</span><span class="sxs-lookup"><span data-stu-id="76de9-196">Similarly, if you remove <xref:System.Security.AccessControl.RegistryRights.EnumerateSubKeys> rights, the other constituents of <xref:System.Security.AccessControl.RegistryRights.ReadKey> rights will reappear.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="76de9-197">下列程式碼範例會建立登錄存取規則，並將它們加入至<xref:System.Security.AccessControl.RegistrySecurity>顯示方式的規則，允許和拒絕權限會有所區隔，同時在同一個相容的規則類型的物件，會合併。</span><span class="sxs-lookup"><span data-stu-id="76de9-197">The following code example creates registry access rules and adds them to a <xref:System.Security.AccessControl.RegistrySecurity> object, showing how rules that allow and deny rights remain separate, while compatible rules of the same kind are merged.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="76de9-198">此範例不會附加安全性物件至<xref:Microsoft.Win32.RegistryKey>物件。</span><span class="sxs-lookup"><span data-stu-id="76de9-198">This example does not attach the security object to a <xref:Microsoft.Win32.RegistryKey> object.</span></span> <span data-ttu-id="76de9-199">中可以找到附加安全性物件的範例<xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType>和<xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="76de9-199">Examples that attach security objects can be found in <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> and <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="76de9-200">程式碼範例示範繼承和傳播旗標位在<xref:System.Security.AccessControl.RegistryAccessRule>類別。</span><span class="sxs-lookup"><span data-stu-id="76de9-200">A code example that demonstrates inheritance and propagation flags can be found in the <xref:System.Security.AccessControl.RegistryAccessRule> class.</span></span>  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.AddAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.AddAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.AddAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.AddAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="76de9-201">
            <paramref name="rule" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-201">
              <paramref name="rule" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="AddAuditRule">
      <MemberSignature Language="C#" Value="public void AddAuditRule (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAuditRule(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.AddAuditRule(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAuditRule (rule As RegistryAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAuditRule(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <span data-ttu-id="76de9-202">要加入的稽核規則。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-202">The audit rule to add.</span>
          </span>
          <span data-ttu-id="76de9-203">這個規則指定的使用者會決定搜尋方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-203">The user specified by this rule determines the search.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="76de9-204">搜尋可合併新規則的稽核規則。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-204">Searches for an audit rule with which the new rule can be merged.</span>
          </span>
          <span data-ttu-id="76de9-205">如果找不到，就加入新規則。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-205">If none are found, adds the new rule.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="76de9-206"><xref:System.Security.AccessControl.RegistrySecurity.AddAuditRule%2A>方法具有相同的使用者或群組做為規則會搜尋`rule`。</span><span class="sxs-lookup"><span data-stu-id="76de9-206">The <xref:System.Security.AccessControl.RegistrySecurity.AddAuditRule%2A> method searches for rules with the same user or group as `rule`.</span></span> <span data-ttu-id="76de9-207">如果找不到，`rule`加入。</span><span class="sxs-lookup"><span data-stu-id="76de9-207">If none are found, `rule` is added.</span></span> <span data-ttu-id="76de9-208">如果找到相符的規則是中的旗標`rule`會合併到現有的規則。</span><span class="sxs-lookup"><span data-stu-id="76de9-208">If a matching rule is found, the flags in `rule` are merged into the existing rule.</span></span>  
  
 <span data-ttu-id="76de9-209">如果它們有不同的繼承旗標，無法合併的規則。</span><span class="sxs-lookup"><span data-stu-id="76de9-209">Rules cannot be merged if they have different inheritance flags.</span></span> <span data-ttu-id="76de9-210">比方說，如果嘗試寫入機碼的失敗會稽核特定的使用者，但沒有繼承旗標，和<xref:System.Security.AccessControl.RegistrySecurity.AddAuditRule%2A>用來新增規則，指定相同的使用者，但使用的繼承稽核變更的權限的嘗試失敗子機碼 (<xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit?displayProperty=nameWithType>)，無法合併兩個規則。</span><span class="sxs-lookup"><span data-stu-id="76de9-210">For example, if failed attempts to write to a key are audited for a particular user, with no inheritance flags, and <xref:System.Security.AccessControl.RegistrySecurity.AddAuditRule%2A> is used to add a rule specifying that failed attempts to change permissions are to be audited for the same user, but with inheritance for subkeys (<xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit?displayProperty=nameWithType>), the two rules cannot be merged.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AuditRule AuditRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AuditRule AuditRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AuditFlags flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AuditRule ^ AuditRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AuditFlags flags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AuditRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="flags" Type="System.Security.AccessControl.AuditFlags" />
      </Parameters>
      <Docs>
        <param name="identityReference">
          <span data-ttu-id="76de9-211">
            <see cref="T:System.Security.Principal.IdentityReference" />，可識別套用這個規則的使用者或群組。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-211">An <see cref="T:System.Security.Principal.IdentityReference" /> that identifies the user or group the rule applies to.</span>
          </span>
        </param>
        <param name="accessMask">
          <span data-ttu-id="76de9-212">
            <see cref="T:System.Security.AccessControl.RegistryRights" /> 值的位元組合，指定要稽核的存取權限 (轉型成整數)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-212">A bitwise combination of <see cref="T:System.Security.AccessControl.RegistryRights" /> values specifying the access rights to audit, cast to an integer.</span>
          </span>
        </param>
        <param name="isInherited">
          <span data-ttu-id="76de9-213">布林值，指定規則是否是繼承的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-213">A Boolean value specifying whether the rule is inherited.</span>
          </span>
        </param>
        <param name="inheritanceFlags">
          <span data-ttu-id="76de9-214">
            <see cref="T:System.Security.AccessControl.InheritanceFlags" /> 值的位元組合，指定子機碼如何繼承規則。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-214">A bitwise combination of <see cref="T:System.Security.AccessControl.InheritanceFlags" /> values specifying how the rule is inherited by subkeys.</span>
          </span>
        </param>
        <param name="propagationFlags">
          <span data-ttu-id="76de9-215">
            <see cref="T:System.Security.AccessControl.PropagationFlags" /> 值的位元組合，這些值會修改子機碼繼承規則的方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-215">A bitwise combination of <see cref="T:System.Security.AccessControl.PropagationFlags" /> values that modify the way the rule is inherited by subkeys.</span>
          </span>
          <span data-ttu-id="76de9-216">如果 <c>inheritanceFlags</c> 的值為 <see cref="F:System.Security.AccessControl.InheritanceFlags.None" />，則沒有意義。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-216">Meaningless if the value of <c>inheritanceFlags</c> is <see cref="F:System.Security.AccessControl.InheritanceFlags.None" />.</span>
          </span>
        </param>
        <param name="flags">
          <span data-ttu-id="76de9-217">
            <see cref="T:System.Security.AccessControl.AuditFlags" /> 值的位元組合，指定是否要稽核成功存取、失敗存取或兩者皆稽核。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-217">A bitwise combination of <see cref="T:System.Security.AccessControl.AuditFlags" /> values specifying whether to audit successful access, failed access, or both.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="76de9-218">建立新的稽核規則，指定套用該規則的使用者、要稽核的存取權限、規則的繼承和傳用，以及觸發規則的結果。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-218">Creates a new audit rule, specifying the user the rule applies to, the access rights to audit, the inheritance and propagation of the rule, and the outcome that triggers the rule.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="76de9-219">
            <see cref="T:System.Security.AccessControl.RegistryAuditRule" /> 物件，表示指定之使用者的指定稽核規則，而且具有指定的旗標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-219">A <see cref="T:System.Security.AccessControl.RegistryAuditRule" /> object representing the specified audit rule for the specified user, with the specified flags.</span>
          </span>
          <span data-ttu-id="76de9-220">此方法的傳回型別為基底類別 <see cref="T:System.Security.AccessControl.AuditRule" />，但是傳回值可以安全地轉型為衍生類別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-220">The return type of the method is the base class, <see cref="T:System.Security.AccessControl.AuditRule" />, but the return value can be cast safely to the derived class.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="76de9-221">若要建立的稽核規則的建議的方式是使用的建構函式<xref:System.Security.AccessControl.RegistryAuditRule>類別。</span><span class="sxs-lookup"><span data-stu-id="76de9-221">The recommended way to create audit rules is to use the constructors of the <xref:System.Security.AccessControl.RegistryAuditRule> class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="76de9-222">雖然您可以指定<xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit?displayProperty=nameWithType>旗標，請在此情況下沒有點。</span><span class="sxs-lookup"><span data-stu-id="76de9-222">Although you can specify the <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit?displayProperty=nameWithType> flag, there is no point in doing so.</span></span> <span data-ttu-id="76de9-223">基於稽核控制，子機碼中的名稱/值組不是個別的物件。</span><span class="sxs-lookup"><span data-stu-id="76de9-223">For the purposes of audit control, the name/value pairs in a subkey are not separate objects.</span></span> <span data-ttu-id="76de9-224">名稱/值組的稽核權限是由子機碼的權限控制。</span><span class="sxs-lookup"><span data-stu-id="76de9-224">The audit rights to name/value pairs are controlled by the rights of the subkey.</span></span> <span data-ttu-id="76de9-225">此外，因為所有子機碼是容器 （也就是它們可以包含其他子機碼），它們不會影響<xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit>旗標。</span><span class="sxs-lookup"><span data-stu-id="76de9-225">Furthermore, since all subkeys are containers (that is, they can contain other subkeys), they are not affected by the <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> flag.</span></span> <span data-ttu-id="76de9-226">最後，指定<xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit>旗標不必要地變得非常複雜的維護的規則，因為它會干擾一般相容規則的組合。</span><span class="sxs-lookup"><span data-stu-id="76de9-226">Finally, specifying the <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> flag needlessly complicates the maintenance of rules, because it interferes with the normal combination of compatible rules.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="76de9-227">
            <paramref name="accessMask" />、<paramref name="inheritanceFlags" />、<paramref name="propagationFlags" /> 或 <paramref name="flags" /> 會指定無效的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-227">
              <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" />, or <paramref name="flags" /> specifies an invalid value.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="76de9-228">
            <paramref name="identityReference" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-228">
              <paramref name="identityReference" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="76de9-229">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-229">-or-</span>
          </span>
          <span data-ttu-id="76de9-230">
            <paramref name="accessMask" /> 為零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-230">
              <paramref name="accessMask" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="76de9-231">
            <paramref name="identityReference" /> 既不是 <see cref="T:System.Security.Principal.SecurityIdentifier" /> 型別，也不是可以轉換成 <see cref="T:System.Security.Principal.NTAccount" /> 型別的型別 (例如 <see cref="T:System.Security.Principal.SecurityIdentifier" />)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-231">
              <paramref name="identityReference" /> is neither of type <see cref="T:System.Security.Principal.SecurityIdentifier" />, nor of a type such as <see cref="T:System.Security.Principal.NTAccount" /> that can be converted to type <see cref="T:System.Security.Principal.SecurityIdentifier" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleType">
      <MemberSignature Language="C#" Value="public override Type AuditRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AuditRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.RegistrySecurity.AuditRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AuditRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AuditRuleType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="76de9-232">取得 <see cref="T:System.Security.AccessControl.RegistrySecurity" /> 類別用來表示稽核規則的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-232">Gets the type that the <see cref="T:System.Security.AccessControl.RegistrySecurity" /> class uses to represent audit rules.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="76de9-233">
            <see cref="T:System.Type" /> 物件，表示 <see cref="T:System.Security.AccessControl.RegistryAuditRule" /> 類別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-233">A <see cref="T:System.Type" /> object representing the <see cref="T:System.Security.AccessControl.RegistryAuditRule" /> class.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="76de9-234">類別衍生自<xref:System.Security.AccessControl.ObjectSecurity>類別覆寫<xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A>屬性和傳回類型，用以代表稽核權限。</span><span class="sxs-lookup"><span data-stu-id="76de9-234">Classes that derive from the <xref:System.Security.AccessControl.ObjectSecurity> class override the <xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A> property and return the type they use to represent audit rights.</span></span> <span data-ttu-id="76de9-235">當您使用陣列或包含多個類型的安全性物件的集合時，使用這個屬性來判斷用於每個安全性物件的正確的稽核規則類型。</span><span class="sxs-lookup"><span data-stu-id="76de9-235">When you work with arrays or collections that contain multiple types of security objects, use this property to determine the correct audit rule type to use with each security object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRule">
      <MemberSignature Language="C#" Value="public bool RemoveAccessRule (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAccessRule(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAccessRule (rule As RegistryAccessRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAccessRule(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <span data-ttu-id="76de9-236">
            <see cref="T:System.Security.AccessControl.RegistryAccessRule" />，其會指定要搜尋的使用者和 <see cref="T:System.Security.AccessControl.AccessControlType" />，以及必須與相符的規則 (如果找到的話) 相容的繼承和傳用旗標集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-236">A <see cref="T:System.Security.AccessControl.RegistryAccessRule" /> that specifies the user and <see cref="T:System.Security.AccessControl.AccessControlType" /> to search for, and a set of inheritance and propagation flags that a matching rule, if found, must be compatible with.</span>
          </span>
          <span data-ttu-id="76de9-237">如果找到的話，指定從相容的規則中移除此權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-237">Specifies the rights to remove from the compatible rule, if found.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="76de9-238">搜尋具有與指定之存取規則相同的使用者和 <see cref="T:System.Security.AccessControl.AccessControlType" /> (允許或拒絕) 以及具有相容的繼承和傳用旗標的存取控制規則。如果找到這樣的規則，則會移除指定之存取規則中所包含的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-238">Searches for an access control rule with the same user and <see cref="T:System.Security.AccessControl.AccessControlType" /> (allow or deny) as the specified access rule, and with compatible inheritance and propagation flags; if such a rule is found, the rights contained in the specified access rule are removed from it.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="76de9-239">如果找到相容的規則，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-239">
              <see langword="true" /> if a compatible rule is found; otherwise <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="76de9-240">目前<xref:System.Security.AccessControl.RegistrySecurity>擁有相同的使用者和相同的規則會搜尋<xref:System.Security.AccessControl.AccessControlType>視為`rule`。</span><span class="sxs-lookup"><span data-stu-id="76de9-240">The current <xref:System.Security.AccessControl.RegistrySecurity> is searched for a rule that has the same user and the same <xref:System.Security.AccessControl.AccessControlType> value as `rule`.</span></span> <span data-ttu-id="76de9-241">如果找到任何這類規則，會採取任何動作，而且方法會傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="76de9-241">If no such rule is found, no action is taken, and the method returns `false`.</span></span> <span data-ttu-id="76de9-242">如果找到比對規則，其繼承和相容性旗標會檢查在指定的旗標與相容性的`rule`。</span><span class="sxs-lookup"><span data-stu-id="76de9-242">If matching rules are found, their inheritance and compatibility flags are checked for compatibility with the flags specified in `rule`.</span></span> <span data-ttu-id="76de9-243">如果找到不相容的規則，會採取任何動作，而且方法會傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="76de9-243">If no compatible rule is found, no action is taken, and the method returns `false`.</span></span> <span data-ttu-id="76de9-244">如果找到具有相容的旗標的規則，在指定的權限`rule`移除了相容的規則，而且方法會傳回`true`。</span><span class="sxs-lookup"><span data-stu-id="76de9-244">If a rule with compatible flags is found, the rights specified in `rule` are removed from the compatible rule, and the method returns `true`.</span></span> <span data-ttu-id="76de9-245">如果`rule`指定不相容的規則中包含的權限，就會採取任何動作，與這些權限。</span><span class="sxs-lookup"><span data-stu-id="76de9-245">If `rule` specifies rights not contained in the compatible rule, no action is taken with respect to those rights.</span></span> <span data-ttu-id="76de9-246">如果從相容的規則會移除所有的權限，整個規則會移除從目前<xref:System.Security.AccessControl.RegistrySecurity>物件。</span><span class="sxs-lookup"><span data-stu-id="76de9-246">If all rights are removed from the compatible rule, the entire rule is removed from the current <xref:System.Security.AccessControl.RegistrySecurity> object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="76de9-247">下列程式碼範例示範如何<xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A>方法會將權限移除相容的規則，以及如何<xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A>方法就會合併相容規則的權限。</span><span class="sxs-lookup"><span data-stu-id="76de9-247">The following code example shows how the <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> method removes rights from a compatible rule, and how the <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> method merges rights with compatible rules.</span></span>  
  
 <span data-ttu-id="76de9-248">此範例會建立<xref:System.Security.AccessControl.RegistrySecurity>物件，並加入規則，可讓目前使用者<xref:System.Security.AccessControl.RegistryRights.ReadKey?displayProperty=nameWithType>權限。</span><span class="sxs-lookup"><span data-stu-id="76de9-248">The example creates a <xref:System.Security.AccessControl.RegistrySecurity> object and adds a rule that allows the current user <xref:System.Security.AccessControl.RegistryRights.ReadKey?displayProperty=nameWithType> rights.</span></span> <span data-ttu-id="76de9-249">這個範例會建立一個規則，會授與使用者<xref:System.Security.AccessControl.RegistryRights.SetValue?displayProperty=nameWithType>使用相同的繼承和傳播權限做為第一個規則，並使用<xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A>方法來移除此新的規則從<xref:System.Security.AccessControl.RegistrySecurity>物件。</span><span class="sxs-lookup"><span data-stu-id="76de9-249">The example then creates a rule that grants the user <xref:System.Security.AccessControl.RegistryRights.SetValue?displayProperty=nameWithType>, with the same inheritance and propagation rights as the first rule, and uses the <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> method to remove this new rule from the <xref:System.Security.AccessControl.RegistrySecurity> object.</span></span> <span data-ttu-id="76de9-250"><xref:System.Security.AccessControl.RegistryRights.SetValue> 是的構成部分<xref:System.Security.AccessControl.RegistryRights.ReadKey>，因此它會移除從相容的規則。</span><span class="sxs-lookup"><span data-stu-id="76de9-250"><xref:System.Security.AccessControl.RegistryRights.SetValue> is a constituent of <xref:System.Security.AccessControl.RegistryRights.ReadKey>, so it is removed from the compatible rule.</span></span> <span data-ttu-id="76de9-251">中的規則<xref:System.Security.AccessControl.RegistrySecurity>物件會出現，其中顯示剩餘的構成<xref:System.Security.AccessControl.RegistryRights.ReadKey>。</span><span class="sxs-lookup"><span data-stu-id="76de9-251">The rules in the <xref:System.Security.AccessControl.RegistrySecurity> object are displayed, showing the remaining constituents of <xref:System.Security.AccessControl.RegistryRights.ReadKey>.</span></span>  
  
 <span data-ttu-id="76de9-252">範例程式碼接著呼叫<xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A>方法，將合併<xref:System.Security.AccessControl.RegistryRights.SetValue>回規則中以滑鼠右鍵<xref:System.Security.AccessControl.RegistrySecurity>物件。</span><span class="sxs-lookup"><span data-stu-id="76de9-252">The example code then calls the <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> method to merge the <xref:System.Security.AccessControl.RegistryRights.SetValue> right back into the rule in the <xref:System.Security.AccessControl.RegistrySecurity> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="76de9-253">此範例不會附加安全性物件至<xref:Microsoft.Win32.RegistryKey>物件。</span><span class="sxs-lookup"><span data-stu-id="76de9-253">This example does not attach the security object to a <xref:Microsoft.Win32.RegistryKey> object.</span></span> <span data-ttu-id="76de9-254">此節中的第二個範例附加安全性物件，並因此做範例<xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="76de9-254">The second example in this section attaches a security object, and so do the examples in <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType><xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="76de9-255">
            <paramref name="rule" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-255">
              <paramref name="rule" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleAll (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleAll(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleAll (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleAll(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <span data-ttu-id="76de9-256">
            <see cref="T:System.Security.AccessControl.RegistryAccessRule" />，指定要搜尋的使用者和 <see cref="T:System.Security.AccessControl.AccessControlType" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-256">A <see cref="T:System.Security.AccessControl.RegistryAccessRule" /> that specifies the user and <see cref="T:System.Security.AccessControl.AccessControlType" /> to search for.</span>
          </span>
          <span data-ttu-id="76de9-257">這個規則所指定的任何權限、繼承旗標或傳用旗標都會被忽略。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-257">Any rights, inheritance flags, or propagation flags specified by this rule are ignored.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="76de9-258">搜尋與指定規則具有相同使用者和 <see cref="T:System.Security.AccessControl.AccessControlType" /> (允許或拒絕) 的所有存取控制規則，如果找到的話，便加以移除。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-258">Searches for all access control rules with the same user and <see cref="T:System.Security.AccessControl.AccessControlType" /> (allow or deny) as the specified rule and, if found, removes them.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="76de9-259">目前<xref:System.Security.AccessControl.RegistrySecurity>具備相同的使用者和相同的規則會搜尋<xref:System.Security.AccessControl.AccessControlType>視為`rule`。</span><span class="sxs-lookup"><span data-stu-id="76de9-259">The current <xref:System.Security.AccessControl.RegistrySecurity> is searched for rules that have the same user and the same <xref:System.Security.AccessControl.AccessControlType> value as `rule`.</span></span> <span data-ttu-id="76de9-260">任何權限、 繼承旗標或所指定的傳播旗標`rule`時執行這項搜尋將會被忽略。</span><span class="sxs-lookup"><span data-stu-id="76de9-260">Any rights, inheritance flags, or propagation flags specified by `rule` are ignored when performing this search.</span></span> <span data-ttu-id="76de9-261">如果找不到任何對應的規則，會不採取任何動作。</span><span class="sxs-lookup"><span data-stu-id="76de9-261">If no matching rules are found, no action is taken.</span></span>  
  
 <span data-ttu-id="76de9-262">例如，如果使用者有多個規則可讓具有不同的繼承和傳播旗標的各種權限，您可以移除所有這些規則建立<xref:System.Security.AccessControl.RegistryAccessRule>物件，指定使用者和<xref:System.Security.AccessControl.AccessControlType.Allow?displayProperty=nameWithType>、 任何任意的權限和旗標傳遞至該規則和<xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="76de9-262">For example, if a user has multiple rules that allow various rights with different inheritance and propagation flags, you can remove all those rules by creating a <xref:System.Security.AccessControl.RegistryAccessRule> object that specifies the user and <xref:System.Security.AccessControl.AccessControlType.Allow?displayProperty=nameWithType>, with any arbitrary rights and flags, and passing that rule to the <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="76de9-263">下列程式碼範例顯示<xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll%2A>方法移除符合使用者的所有規則和<xref:System.Security.AccessControl.AccessControlType>，略過權限和旗標。</span><span class="sxs-lookup"><span data-stu-id="76de9-263">The following code example shows that the <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll%2A> method removes all rules that match user and <xref:System.Security.AccessControl.AccessControlType>, ignoring rights and flags.</span></span>  
  
 <span data-ttu-id="76de9-264">此範例會建立<xref:System.Security.AccessControl.RegistrySecurity>物件並將加入規則，允許和拒絕目前的使用者，使用不同的繼承和傳播旗標的各種權限。</span><span class="sxs-lookup"><span data-stu-id="76de9-264">The example creates a <xref:System.Security.AccessControl.RegistrySecurity> object and adds rules that allow and deny various rights for the current user, with different inheritance and propagation flags.</span></span> <span data-ttu-id="76de9-265">這個範例會建立新的規則可讓目前的使用者取得擁有權，並傳遞至該規則<xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll%2A>方法移除兩個規則，以允許存取。</span><span class="sxs-lookup"><span data-stu-id="76de9-265">The example then creates a new rule that allows the current user to take ownership, and passes that rule to the <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll%2A> method to remove the two rules that allow access.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="76de9-266">此範例不會附加安全性物件至<xref:Microsoft.Win32.RegistryKey>物件。</span><span class="sxs-lookup"><span data-stu-id="76de9-266">This example does not attach the security object to a <xref:Microsoft.Win32.RegistryKey> object.</span></span> <span data-ttu-id="76de9-267">請參閱<xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType>方法和<xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="76de9-267">See the <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> method and the <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> method.</span></span>  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="76de9-268">
            <paramref name="rule" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-268">
              <paramref name="rule" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleSpecific (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleSpecific(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleSpecific (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleSpecific(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <span data-ttu-id="76de9-269">要移除的 <see cref="T:System.Security.AccessControl.RegistryAccessRule" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-269">The <see cref="T:System.Security.AccessControl.RegistryAccessRule" /> to remove.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="76de9-270">搜尋與指定規則完全相符的存取控制規則，如果找到的話，便加以移除。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-270">Searches for an access control rule that exactly matches the specified rule and, if found, removes it.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="76de9-271">此規則會移除它完全符合時，才`rule`中所有詳細資料，包括旗標。</span><span class="sxs-lookup"><span data-stu-id="76de9-271">The rule is removed only if it exactly matches `rule` in all details, including flags.</span></span> <span data-ttu-id="76de9-272">其他規則具有相同的使用者和<xref:System.Security.AccessControl.AccessControlType>不會受到影響。</span><span class="sxs-lookup"><span data-stu-id="76de9-272">Other rules with the same user and <xref:System.Security.AccessControl.AccessControlType> are not affected.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="76de9-273">規則表示一或多個基礎存取控制項目 (ACE)，而且這些項目分割或修改使用者存取安全性規則時，視需要結合。</span><span class="sxs-lookup"><span data-stu-id="76de9-273">A rule represents one or more underlying access control entries (ACE), and these entries are split or combined as necessary when you modify the access security rules for a user.</span></span> <span data-ttu-id="76de9-274">因此，規則不再存在於在特定的表單時加入，然後在此情況下<xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific%2A>方法無法將其移除。</span><span class="sxs-lookup"><span data-stu-id="76de9-274">Thus, a rule might no longer exist in the specific form it had when it was added, and in that case the <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific%2A> method cannot remove it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="76de9-275">下列程式碼範例顯示<xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific%2A>方法移除規則，只有當它完全符合。</span><span class="sxs-lookup"><span data-stu-id="76de9-275">The following code example shows that the <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific%2A> method removes a rule only if it matches exactly.</span></span>  
  
 <span data-ttu-id="76de9-276">此範例會建立兩個規則，以允許不同的權限。</span><span class="sxs-lookup"><span data-stu-id="76de9-276">The example creates two rules that allow different rights.</span></span> <span data-ttu-id="76de9-277">規則有相容的繼承和傳播旗標，因此當會新增第二個規則，它會合併的第一個。</span><span class="sxs-lookup"><span data-stu-id="76de9-277">The rules have compatible inheritance and propagation flags, so when the second rule is added it merges with the first.</span></span> <span data-ttu-id="76de9-278">範例會呼叫<xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific%2A>方法，指定第一個規則，但因為合併的規則沒有符合的規則。</span><span class="sxs-lookup"><span data-stu-id="76de9-278">The example calls the <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific%2A> method, specifying the first rule, but because the rules are merged there is no rule that matches.</span></span> <span data-ttu-id="76de9-279">此範例會接著呼叫<xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A>從合併的規則，以及最後呼叫的方法來移除第二個規則<xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific%2A>方法中移除第一個規則。</span><span class="sxs-lookup"><span data-stu-id="76de9-279">The example then calls the <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> method to the remove the second rule from the merged rule, and finally calls the <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific%2A> method to remove the first rule.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="76de9-280">此範例不會附加安全性物件至<xref:Microsoft.Win32.RegistryKey>物件。</span><span class="sxs-lookup"><span data-stu-id="76de9-280">This example does not attach the security object to a <xref:Microsoft.Win32.RegistryKey> object.</span></span> <span data-ttu-id="76de9-281">請參閱<xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType>方法和<xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="76de9-281">See the <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> method and the <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> method.</span></span>  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="76de9-282">
            <paramref name="rule" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-282">
              <paramref name="rule" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRule">
      <MemberSignature Language="C#" Value="public bool RemoveAuditRule (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAuditRule(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAuditRule(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAuditRule (rule As RegistryAuditRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAuditRule(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <span data-ttu-id="76de9-283">
            <see cref="T:System.Security.AccessControl.RegistryAuditRule" />，其會指定要搜尋的使用者，以及必須與相符的規則 (如果找到的話) 相容的繼承和傳用旗標集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-283">A <see cref="T:System.Security.AccessControl.RegistryAuditRule" /> that specifies the user to search for, and a set of inheritance and propagation flags that a matching rule, if found, must be compatible with.</span>
          </span>
          <span data-ttu-id="76de9-284">如果找到的話，指定從相容的規則中移除此權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-284">Specifies the rights to remove from the compatible rule, if found.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="76de9-285">搜尋具有與指定之規則相同的使用者以及具有相容的繼承和傳用旗標的稽核控制規則。如果找到了相容的規則，則會移除指定之規則中所包含的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-285">Searches for an audit control rule with the same user as the specified rule, and with compatible inheritance and propagation flags; if a compatible rule is found, the rights contained in the specified rule are removed from it.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="76de9-286">如果找到相容的規則，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-286">
              <see langword="true" /> if a compatible rule is found; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="76de9-287">目前<xref:System.Security.AccessControl.RegistrySecurity>搜尋具有相同的使用者的稽核規則`rule`。</span><span class="sxs-lookup"><span data-stu-id="76de9-287">The current <xref:System.Security.AccessControl.RegistrySecurity> is searched for an audit rule that has the same user as `rule`.</span></span> <span data-ttu-id="76de9-288">如果找到任何這類規則，會採取任何動作，而且方法會傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="76de9-288">If no such rule is found, no action is taken, and the method returns `false`.</span></span> <span data-ttu-id="76de9-289">如果找到比對規則，其繼承和相容性旗標會檢查在指定的旗標與相容性的`rule`。</span><span class="sxs-lookup"><span data-stu-id="76de9-289">If matching rules are found, their inheritance and compatibility flags are checked for compatibility with the flags specified in `rule`.</span></span> <span data-ttu-id="76de9-290">如果找到不相容的規則，會採取任何動作，而且方法會傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="76de9-290">If no compatible rule is found, no action is taken, and the method returns `false`.</span></span> <span data-ttu-id="76de9-291">如果找到具有相容的旗標的規則，在指定的權限`rule`移除了相容的規則，而且方法會傳回`true`。</span><span class="sxs-lookup"><span data-stu-id="76de9-291">If a rule with compatible flags is found, the rights specified in `rule` are removed from the compatible rule, and the method returns `true`.</span></span> <span data-ttu-id="76de9-292">如果`rule`指定不相容的規則中包含的權限，就會採取任何動作，與這些權限。</span><span class="sxs-lookup"><span data-stu-id="76de9-292">If `rule` specifies rights not contained in the compatible rule, no action is taken with respect to those rights.</span></span> <span data-ttu-id="76de9-293">如果從相容的規則會移除所有的權限，整個規則會移除從目前<xref:System.Security.AccessControl.RegistrySecurity>物件。</span><span class="sxs-lookup"><span data-stu-id="76de9-293">If all rights are removed from the compatible rule, the entire rule is removed from the current <xref:System.Security.AccessControl.RegistrySecurity> object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="76de9-294">
            <paramref name="rule" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-294">
              <paramref name="rule" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleAll (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleAll(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleAll (rule As RegistryAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleAll(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <span data-ttu-id="76de9-295">
            <see cref="T:System.Security.AccessControl.RegistryAuditRule" />，指定要搜尋的使用者。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-295">A <see cref="T:System.Security.AccessControl.RegistryAuditRule" /> that specifies the user to search for.</span>
          </span>
          <span data-ttu-id="76de9-296">這個規則所指定的任何權限、繼承旗標或傳用旗標都會被忽略。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-296">Any rights, inheritance flags, or propagation flags specified by this rule are ignored.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="76de9-297">搜尋與所指定規則有相同使用者的所有稽核規則，找到以後將其移除。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-297">Searches for all audit rules with the same user as the specified rule and, if found, removes them.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="76de9-298">目前<xref:System.Security.AccessControl.RegistrySecurity>搜尋中是否有具有相同的使用者的稽核規則`rule`。</span><span class="sxs-lookup"><span data-stu-id="76de9-298">The current <xref:System.Security.AccessControl.RegistrySecurity> is searched for audit rules that have the same user as `rule`.</span></span> <span data-ttu-id="76de9-299">任何權限、 繼承旗標或所指定的傳播旗標`rule`時執行這項搜尋將會被忽略。</span><span class="sxs-lookup"><span data-stu-id="76de9-299">Any rights, inheritance flags, or propagation flags specified by `rule` are ignored when performing this search.</span></span> <span data-ttu-id="76de9-300">如果找不到任何對應的規則，會不採取任何動作。</span><span class="sxs-lookup"><span data-stu-id="76de9-300">If no matching rules are found, no action is taken.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="76de9-301">
            <paramref name="rule" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-301">
              <paramref name="rule" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleSpecific (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleSpecific(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleSpecific (rule As RegistryAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleSpecific(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <span data-ttu-id="76de9-302">要移除的 <see cref="T:System.Security.AccessControl.RegistryAuditRule" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-302">The <see cref="T:System.Security.AccessControl.RegistryAuditRule" /> to be removed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="76de9-303">搜尋與指定規則完全相符的稽核規則，如果找到的話，便加以移除。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-303">Searches for an audit rule that exactly matches the specified rule and, if found, removes it.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="76de9-304">此規則會移除它完全符合時，才`rule`中所有詳細資料，包括旗標。</span><span class="sxs-lookup"><span data-stu-id="76de9-304">The rule is removed only if it exactly matches `rule` in all details, including flags.</span></span> <span data-ttu-id="76de9-305">不會影響同一個使用者的其他稽核規則。</span><span class="sxs-lookup"><span data-stu-id="76de9-305">Other audit rules for the same user are not affected.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="76de9-306">規則表示一或多個基礎存取控制項目 (ACE)，而且這些項目分割或修改使用者的安全性稽核規則時，視需要結合。</span><span class="sxs-lookup"><span data-stu-id="76de9-306">A rule represents one or more underlying access control entries (ACE), and these entries are split or combined as necessary when you modify the audit security rules for a user.</span></span> <span data-ttu-id="76de9-307">因此，規則不再存在於在特定的表單時加入，然後在此情況下<xref:System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific%2A>方法無法將其移除。</span><span class="sxs-lookup"><span data-stu-id="76de9-307">Thus, a rule might no longer exist in the specific form it had when it was added, and in that case the <xref:System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific%2A> method cannot remove it.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="76de9-308">
            <paramref name="rule" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-308">
              <paramref name="rule" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ResetAccessRule">
      <MemberSignature Language="C#" Value="public void ResetAccessRule (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetAccessRule(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.ResetAccessRule(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetAccessRule (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetAccessRule(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <span data-ttu-id="76de9-309">要加入的 <see cref="T:System.Security.AccessControl.RegistryAccessRule" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-309">The <see cref="T:System.Security.AccessControl.RegistryAccessRule" /> to add.</span>
          </span>
          <span data-ttu-id="76de9-310">這個規則指定的使用者會決定在加入這項規則之前要移除的規則。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-310">The user specified by this rule determines the rules to remove before this rule is added.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="76de9-311">移除與指定規則具有相同使用者的所有存取控制規則 (不論 <see cref="T:System.Security.AccessControl.AccessControlType" /> 為何)，然後加入指定規則。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-311">Removes all access control rules with the same user as the specified rule, regardless of <see cref="T:System.Security.AccessControl.AccessControlType" />, and then adds the specified rule.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="76de9-312">如果沒有使用者符合指定之規則的存取規則`rule`加入。</span><span class="sxs-lookup"><span data-stu-id="76de9-312">If there are no access rules whose user matches the specified rule, `rule` is added.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="76de9-313">下列程式碼範例示範如何<xref:System.Security.AccessControl.RegistrySecurity.ResetAccessRule%2A>方法會取代為指定的比對的規則比對使用者的所有規則。</span><span class="sxs-lookup"><span data-stu-id="76de9-313">The following code example shows how the <xref:System.Security.AccessControl.RegistrySecurity.ResetAccessRule%2A> method replaces all rules for the matching user with the rule specified for the match.</span></span>  
  
 <span data-ttu-id="76de9-314">此範例會建立<xref:System.Security.AccessControl.RegistrySecurity>物件並將加入規則，允許和拒絕目前的使用者，使用不同的繼承和傳播旗標的各種權限。</span><span class="sxs-lookup"><span data-stu-id="76de9-314">The example creates a <xref:System.Security.AccessControl.RegistrySecurity> object and adds rules that allow and deny various rights for the current user, with different inheritance and propagation flags.</span></span> <span data-ttu-id="76de9-315">這個範例會建立新的規則，可讓目前的使用者只能讀取機碼，並使用<xref:System.Security.AccessControl.RegistrySecurity.ResetAccessRule%2A>方法來移除使用者的所有規則，並取代為新的規則。</span><span class="sxs-lookup"><span data-stu-id="76de9-315">The example then creates a new rule that allows the current user only to read the key, and uses the <xref:System.Security.AccessControl.RegistrySecurity.ResetAccessRule%2A> method to remove the all rules for the user and replace them with the new rule.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="76de9-316">此範例不會附加安全性物件至<xref:Microsoft.Win32.RegistryKey>物件。</span><span class="sxs-lookup"><span data-stu-id="76de9-316">This example does not attach the security object to a <xref:Microsoft.Win32.RegistryKey> object.</span></span> <span data-ttu-id="76de9-317">請參閱<xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType>方法和<xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="76de9-317">See the <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> method and the <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> method.</span></span>  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.ResetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.ResetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.ResetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.ResetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAccessRule">
      <MemberSignature Language="C#" Value="public void SetAccessRule (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessRule(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.SetAccessRule(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessRule (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessRule(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <span data-ttu-id="76de9-318">要加入的 <see cref="T:System.Security.AccessControl.RegistryAccessRule" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-318">The <see cref="T:System.Security.AccessControl.RegistryAccessRule" /> to add.</span>
          </span>
          <span data-ttu-id="76de9-319">這個規則的使用者和 <see cref="T:System.Security.AccessControl.AccessControlType" /> 會決定在加入這項規則之前要移除的規則。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-319">The user and <see cref="T:System.Security.AccessControl.AccessControlType" /> of this rule determine the rules to remove before this rule is added.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="76de9-320">移除與指定規則具有相同使用者和 <see cref="T:System.Security.AccessControl.AccessControlType" /> (允許或拒絕) 的所有存取控制規則，然後加入指定規則。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-320">Removes all access control rules with the same user and <see cref="T:System.Security.AccessControl.AccessControlType" /> (allow or deny) as the specified rule, and then adds the specified rule.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="76de9-321">如果指定的規則有<xref:System.Security.AccessControl.AccessControlType.Allow>，這個方法的效果是要移除所有<xref:System.Security.AccessControl.AccessControlType.Allow>規則所指定的使用者，將其取代為指定的規則。</span><span class="sxs-lookup"><span data-stu-id="76de9-321">If the specified rule has <xref:System.Security.AccessControl.AccessControlType.Allow>, the effect of this method is to remove all <xref:System.Security.AccessControl.AccessControlType.Allow> rules for the specified user, replacing them with the specified rule.</span></span> <span data-ttu-id="76de9-322">如果指定的規則有<xref:System.Security.AccessControl.AccessControlType.Deny>，則所有<xref:System.Security.AccessControl.AccessControlType.Deny>規則指定的使用者都取代成指定的規則。</span><span class="sxs-lookup"><span data-stu-id="76de9-322">If the specified rule has <xref:System.Security.AccessControl.AccessControlType.Deny>, all <xref:System.Security.AccessControl.AccessControlType.Deny> rules for the specified user are replaced with the specified rule.</span></span>  
  
 <span data-ttu-id="76de9-323">如果沒有規則的使用者和<xref:System.Security.AccessControl.AccessControlType>符合指定之規則`rule`加入。</span><span class="sxs-lookup"><span data-stu-id="76de9-323">If there are no rules whose user and <xref:System.Security.AccessControl.AccessControlType> match the specified rule, `rule` is added.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="76de9-324">下列程式碼範例顯示<xref:System.Security.AccessControl.RegistrySecurity.SetAccessRule%2A>方法移除符合這兩個使用者的所有規則和<xref:System.Security.AccessControl.AccessControlType>的`rule`、 略過權限和旗標，並取代它們與`rule`。</span><span class="sxs-lookup"><span data-stu-id="76de9-324">The following code example shows that the <xref:System.Security.AccessControl.RegistrySecurity.SetAccessRule%2A> method removes all rules that match both the user and the <xref:System.Security.AccessControl.AccessControlType> of `rule`, ignoring rights and flags, and replaces them with `rule`.</span></span>  
  
 <span data-ttu-id="76de9-325">此範例會建立<xref:System.Security.AccessControl.RegistrySecurity>物件並將加入規則，允許和拒絕目前的使用者，使用不同的繼承和傳播旗標的各種權限。</span><span class="sxs-lookup"><span data-stu-id="76de9-325">The example creates a <xref:System.Security.AccessControl.RegistrySecurity> object and adds rules that allow and deny various rights for the current user, with different inheritance and propagation flags.</span></span> <span data-ttu-id="76de9-326">這個範例會建立新的規則，可讓目前的使用者只能讀取機碼，並使用<xref:System.Security.AccessControl.RegistrySecurity.SetAccessRule%2A>方法，以移除 允許存取的兩個規則並將它們取代成新的規則。</span><span class="sxs-lookup"><span data-stu-id="76de9-326">The example then creates a new rule that allows the current user only to read the key, and uses the <xref:System.Security.AccessControl.RegistrySecurity.SetAccessRule%2A> method to remove the two rules that allow access and to replace them with the new rule.</span></span> <span data-ttu-id="76de9-327">不受影響的規則，拒絕存取。</span><span class="sxs-lookup"><span data-stu-id="76de9-327">The rule that denies access is not affected.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="76de9-328">此範例不會附加安全性物件至<xref:Microsoft.Win32.RegistryKey>物件。</span><span class="sxs-lookup"><span data-stu-id="76de9-328">This example does not attach the security object to a <xref:Microsoft.Win32.RegistryKey> object.</span></span> <span data-ttu-id="76de9-329">請參閱<xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType>方法和<xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="76de9-329">See the <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> method and the <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> method.</span></span>  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.SetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.SetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.SetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.SetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="76de9-330">
            <paramref name="rule" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-330">
              <paramref name="rule" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetAuditRule">
      <MemberSignature Language="C#" Value="public void SetAuditRule (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAuditRule(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.SetAuditRule(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAuditRule (rule As RegistryAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAuditRule(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <span data-ttu-id="76de9-331">要加入的 <see cref="T:System.Security.AccessControl.RegistryAuditRule" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-331">The <see cref="T:System.Security.AccessControl.RegistryAuditRule" /> to add.</span>
          </span>
          <span data-ttu-id="76de9-332">這個規則指定的使用者會決定在加入這項規則之前要移除的規則。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-332">The user specified by this rule determines the rules to remove before this rule is added.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="76de9-333">移除與指定規則具有相同使用者的所有稽核規則 (不論 <see cref="T:System.Security.AccessControl.AuditFlags" /> 值為何)，然後加入指定規則。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-333">Removes all audit rules with the same user as the specified rule, regardless of the <see cref="T:System.Security.AccessControl.AuditFlags" /> value, and then adds the specified rule.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="76de9-334">如果沒有使用者符合指定之規則的稽核規則`rule`加入。</span><span class="sxs-lookup"><span data-stu-id="76de9-334">If there are no audit rules whose user matches the specified rule, `rule` is added.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="76de9-335">
            <paramref name="rule" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="76de9-335">
              <paramref name="rule" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
  </Members>
</Type>